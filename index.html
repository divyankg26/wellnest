
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NovaFix ‚Äì Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
:root{
  --waveA:#2196f3;
  --waveB:#ff9800;
  --primary:#2196f3;
  --accent:#ff9800;
  --glass:rgba(255,255,255,0.18);
  --text:#fff;
}

html,body{
  margin:0;
  height:100%;
  font-family:'Segoe UI',sans-serif;
  color:var(--text);
}

body{
  background:linear-gradient(120deg,var(--waveA),var(--waveB));
  background-size:200% 200%;
  animation:waveMove 16s ease-in-out infinite;
  overflow-x:hidden;
}

@keyframes waveMove{
  0%{background-position:0% 50%}
  50%{background-position:100% 50%}
  100%{background-position:0% 50%}
}

/* SPLASH */
#splash{
  position:fixed;
  inset:0;
  background:#FFFFFF;
  display:flex;
  justify-content:center;
  align-items:center;
  z-index:9999;
  transition:opacity 1s ease, transform 1s ease;
}
#splash.hide{
  opacity:0;
  transform:translateY(-40px);
  pointer-events:none;
}
#splash img{
  width:450px;
  max-width:80%;
  animation:popIn 1.2s ease;
}
@keyframes popIn{
  from{opacity:0;transform:scale(.85)}
  to{opacity:1;transform:scale(1)}
}

/* SIGN-IN / SIGN-UP MODAL */
#signInModal {
  display: none; 
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  justify-content: center;
  align-items: center;
  z-index: 10000;
}
.modal-content {
  background: rgba(255,255,255,0.15);
  backdrop-filter: blur(14px);
  padding: 40px;
  border-radius: 20px;
  text-align: center;
  width: 90%;
  max-width: 400px;
  color: #fff;
  box-shadow: 0 12px 30px rgba(0,0,0,0.3);
}
.modal-content input {
  width: 100%;
  margin: 10px 0;
  padding: 12px;
  border-radius: 12px;
  border: none;
  background: rgba(255,255,255,0.22);
  color: #fff;
  font-size: 16px;
}
.modal-content button {
  width: 100%;
  padding: 12px;
  margin-top: 10px;
  border-radius: 12px;
  border: none;
  cursor: pointer;
  background: linear-gradient(135deg,var(--primary),var(--accent));
  color: #fff;
  font-weight: bold;
  font-size: 16px;
}
.google-btn{
  background: rgba(255,255,255,0.28) !important;
}
.modal-content p {margin-top: 10px; font-size: 14px; cursor: pointer;}

/* HEADER */
header{
  text-align:center;
  padding:30px;
  background:var(--glass);
  backdrop-filter:blur(14px);
  border-radius:0 0 20px 20px;
  box-shadow:0 12px 30px rgba(0,0,0,.3);
  position:relative;
}
header h1{margin:0;color:var(--primary)}
header p{margin:6px 0 0}
#signOutBtn{
  width:100%;
  margin-top:8px;
}

#accountBtn{
  position:absolute;
  right:20px;
  top:30px;
  padding:8px 14px;
  border:none;
  border-radius:12px;
  cursor:pointer;
  background: linear-gradient(135deg,var(--accent),var(--primary));
  color:#fff;
  font-weight:bold;
  display:none;
}

#accountOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.55);
  display:none;
  z-index:10020;
}

#accountPanel{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:min(420px, calc(100vw - 32px));
  max-width:calc(100vw - 40px);
  max-height:80vh;
  overflow-y:auto;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.25);
  border-radius:14px;
  padding:16px;
  text-align:left;
  backdrop-filter:blur(12px);
  display:none;
  z-index:10021;
}

.account-row{
  font-size:13px;
  margin:8px 0;
  word-break:break-word;
}

.account-row b{
  margin-right:6px;
}

#clearDataBtn,
#accountResetPasswordBtn{
  width:100%;
  margin-top:10px;
}

#signOutBtn{
  margin-top:10px;
}

.account-transfer-box{
  margin-top:12px;
  padding:10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.28);
  background:rgba(255,255,255,.08);
}

.account-transfer-box .export-actions{
  margin-top:0;
  justify-content:center;
  flex-wrap:nowrap;
}

.account-transfer-box .export-actions button{
  width:calc(50% - 4px);
  min-width:0;
  text-align:center;
}

.account-transfer-box .export-note{
  margin-top:8px;
  text-align:center;
}

/* DASHBOARD */
.dashboard{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(300px,1fr));
  gap:24px;
  padding:24px 24px 190px;
  display:none;
}

/* CARD */
.card{
  background:var(--glass);
  backdrop-filter:blur(16px);
  border-radius:20px;
  padding:20px;
  box-shadow:0 16px 40px rgba(0,0,0,.3);
  display:flex;
  flex-direction:column;
  border:1px solid rgba(255,255,255,.25);
}
.card h2{margin-top:0;color:var(--primary)}

.input-group{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-top:8px;
}

input,select,textarea,button{
  padding:10px;
  border-radius:12px;
  border:none;
  background:rgba(255,255,255,.22);
  color:var(--text);
  font-family:inherit;
}

button{
  cursor:pointer;
  font-weight:bold;
  background:linear-gradient(135deg,var(--primary),var(--accent));
}

.chat,#gratitudeLogs,#reminders,#taskList,#timeMirror{
  flex-grow:1;
  min-height:0;
  overflow-y:scroll;
  padding:8px;
  border-radius:12px;
  background:rgba(0,0,0,.15);
  margin-top:8px;
}

#reminders,#taskList,#gratitudeLogs{
  margin-top:16px;
}

#reminders .item-row{
  align-items:flex-start;
  margin-bottom:10px;
}

#reminders .item-text{
  line-height:1.4;
  padding-top:2px;
}

#taskList .item-row,
#gratitudeLogs .item-row{
  align-items:flex-start;
  margin-bottom:10px;
}

#taskList .item-text,
#gratitudeLogs .item-text{
  line-height:1.4;
  padding-top:2px;
}

.scroll-card{
  height:430px;
  max-height:430px;
  overflow:hidden;
}

#timeMirror{white-space:pre-wrap;}

#taskList button,
#gratitudeLogs button,
#reminders button{
  margin-left:12px;
}

.item-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

.item-text{
  flex:1;
  min-width:0;
  word-break:break-word;
}

.item-actions{
  display:flex;
  align-items:center;
  gap:8px;
  flex-shrink:0;
}

.ai-header-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}

.ai-header-row h2{margin:0}

.ai-clear-btn{
  padding:6px 10px;
  border-radius:10px;
  font-size:12px;
}

.chat-message{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:8px;
  margin-bottom:8px;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.12);
}

.chat-text{
  font-size:14px;
  line-height:1.35;
  word-break:break-word;
}

.chat-edit-btn{
  padding:6px 10px;
  border-radius:10px;
  font-size:12px;
  white-space:nowrap;
}

.mood-item{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  margin-bottom:8px;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.12);
}

.mood-item span{
  font-size:14px;
}

.mood-remove{
  padding:6px 10px;
  border-radius:10px;
  border:none;
  font-size:12px;
}

.task-done{
  text-decoration:line-through;
  opacity:.75;
}

.insight-list{margin:6px 0 0;padding-left:18px}
.insight-list li{margin:4px 0}

.insight-row{margin-top:8px}
.insight-row small{display:block;margin-bottom:4px;opacity:.9}
.insight-bar{
  width:100%;
  height:10px;
  border-radius:10px;
  background:rgba(255,255,255,.2);
  overflow:hidden;
}
.insight-fill{
  height:100%;
  background:linear-gradient(135deg,var(--primary),var(--accent));
  width:0%;
}

.insight-switch-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-top:10px;
}

.insight-task-top{
  margin-top:10px;
}

.insight-task-label{
  display:block;
  text-align:center;
  margin:0 0 6px;
  font-weight:700;
}

.insight-metric-title{
  text-align:left;
  margin:0;
  font-weight:700;
}

.insight-metric-label{
  display:block;
  text-align:center;
  margin:0 0 6px;
  opacity:.95;
}

.insight-line-graph{
  width:100%;
  height:180px;
  margin-top:8px;
  border-radius:10px;
  background:rgba(0,0,0,.14);
}

.insight-line-path{
  fill:none;
  stroke:url(#insightGraphGradient);
  stroke-width:3;
  stroke-linecap:round;
  stroke-linejoin:round;
}

.export-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.export-note{font-size:13px;opacity:.9;margin-top:8px}

.wellness-badge{
  font-size:34px;
  font-weight:800;
  text-align:center;
  margin:6px 0;
}

.wellness-status{
  text-align:center;
  margin:0;
  font-weight:600;
}

.wellness-actions{
  margin:10px 0 0;
  padding-left:18px;
}

.wellness-actions li{
  margin:5px 0;
}

.water-clear-btn{
  display:block;
  margin-top:10px;
}

.crash-banner{
  display:none;
  position:fixed;
  right:18px;
  bottom:18px;
  width:min(360px, calc(100vw - 28px));
  padding:12px;
  border-radius:14px;
  background:rgba(0,0,0,.28);
  border:1px solid rgba(255,255,255,.24);
  backdrop-filter:blur(12px);
  box-shadow:0 12px 30px rgba(0,0,0,.35);
  z-index:10015;
}

.crash-banner-row{
  display:flex;
  gap:10px;
  align-items:flex-start;
  justify-content:space-between;
  flex-wrap:wrap;
}

.crash-banner-row button{
  padding:8px 10px;
  border-radius:10px;
  font-size:12px;
}

.crash-risk-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

.crash-risk-value{
  font-size:30px;
  font-weight:800;
  margin:2px 0;
}

.crash-risk-pill{
  font-size:12px;
  padding:6px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.16);
  border:1px solid rgba(255,255,255,.25);
  white-space:nowrap;
}

.crash-meter{
  width:100%;
  height:10px;
  border-radius:10px;
  margin-top:8px;
  background:rgba(255,255,255,.2);
  overflow:hidden;
}

.crash-meter-fill{
  height:100%;
  width:0%;
  background:linear-gradient(135deg,var(--primary),var(--accent));
}

.crash-risk-sub{
  margin:8px 0 0;
  opacity:.92;
  font-size:13px;
}

.crash-plan{
  margin:8px 0 0;
  padding-left:18px;
}

.crash-plan li{margin:4px 0}

.crash-rescue-btn{margin-top:10px}

.weekly-range{
  margin:0;
  opacity:.92;
  font-size:13px;
}

.weekly-section-title{
  margin:10px 0 6px;
  font-size:13px;
  font-weight:700;
  opacity:.95;
}

.weekly-list{
  margin:0;
  padding-left:18px;
}

.weekly-list li{margin:4px 0}

.weekly-target-box{
  margin-top:10px;
  padding:10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.24);
  background:rgba(255,255,255,.08);
}

.weekly-target-text{
  margin:0;
  font-size:13px;
  opacity:.92;
}

.weekly-target-btn{margin-top:10px}

.quest-top{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}

.quest-stat{
  font-size:13px;
  opacity:.95;
}

.quest-progress{
  width:100%;
  height:10px;
  border-radius:10px;
  background:rgba(255,255,255,.2);
  overflow:hidden;
  margin-top:8px;
}

.quest-progress-fill{
  height:100%;
  width:0%;
  background:linear-gradient(135deg,var(--primary),var(--accent));
}

.quest-list{margin:10px 0 0;padding:0;list-style:none}
.quest-item{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
  margin-bottom:8px;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.1);
}
.quest-text{font-size:14px;line-height:1.3;flex:1}
.quest-done{opacity:.7;text-decoration:line-through}

.burnout-risk{
  font-size:30px;
  font-weight:800;
  margin:4px 0;
}

.burnout-sub{margin:0;font-size:13px;opacity:.92}
.burnout-list{margin:8px 0 0;padding-left:18px}
.burnout-list li{margin:4px 0}
.burnout-btn{margin-top:10px}

#gCost,#gMonths,#buffer{
  margin-top:8px;
}

::-webkit-scrollbar{width:6px}
::-webkit-scrollbar-thumb{background:var(--primary);border-radius:3px}
</style>
</head>
<body>

<audio id="reminderSound" src="https://image2url.com/r2/default/audio/1770462028211-e2a46d69-8e18-430d-971b-e111cf9254b9.mp3" preload="auto"></audio>

<!-- SPLASH -->
<div id="splash">
  <img src="https://gcdnb.pbrd.co/images/T3DLjTXN0F9N.jpg?o=1">
</div>

<!-- SIGN-IN / SIGN-UP MODAL -->
<div id="signInModal">
  <div class="modal-content">
    <h2 id="modalTitle">Welcome to NovaFix üåü</h2>
    <input id="usernameInput" type="text" placeholder="Enter username" style="display:none;">
    <input id="emailInput" type="email" placeholder="Enter email">
    <input id="passwordInput" type="password" placeholder="Enter password">
    <button id="actionButton" onclick="handleAuth()">Sign In</button>
    <button id="resetPasswordButton" class="google-btn" onclick="sendResetPasswordEmail()">Reset Password</button>
    <button id="googleAuthButton" class="google-btn" onclick="handleGoogleAuth()">Sign In with Google</button>
    <p onclick="toggleAuth()"><span id="toggleText">Don't have an account? Sign Up</span></p>
    <p id="signInError" style="color:red; display:none;">Error message here!</p>
  </div>
</div>

<header>
  <h1>NovaFix</h1>
  <p>Mind ‚Ä¢ Body ‚Ä¢ Money ‚Ä¢ Music ‚Ä¢ Productivity</p>
<button id="accountBtn" onclick="toggleAccountPanel()">Account</button>
</header>

<div id="accountPanel">
  <div class="account-row"><b>Username:</b> <span id="accountName">-</span></div>
  <div class="account-row"><b>Email:</b> <span id="accountEmail">-</span></div>
  <div class="account-row"><b>Verification:</b> <span id="accountVerifyStatus">-</span></div>
  <button id="accountResetPasswordBtn" onclick="sendAccountResetPasswordEmail()">Change Password</button>
  <button id="clearDataBtn" onclick="clearAllAccountData()">Clear All Data</button>
  <button id="signOutBtn" onclick="signOutUser()">Sign Out</button>
  <div class="account-transfer-box">
    <div class="export-actions">
      <button onclick="exportAllData()">Export My Data</button>
      <button onclick="startImportData()">Import Data</button>
    </div>
    <p class="export-note">Download your full NovaFix data as JSON for transfering accounts</p>
    <input id="importFileInput" type="file" accept="application/json,.json" style="display:none" onchange="importDataFileChange(event)">
  </div>
</div>

<div id="accountOverlay" onclick="closeAccountPanel()"></div>

<div id="crashAlertBanner" class="crash-banner">
  <div class="crash-banner-row">
    <div>
      <strong>‚ö†Ô∏è Mood Crash Warning</strong>
      <p id="crashBannerText" class="crash-risk-sub">Your dip risk is elevated right now.</p>
    </div>
    <button onclick="runCrashRescueFlow()">Run 2-Min Rescue</button>
  </div>
</div>

<div class="dashboard">

<!-- AI Companion -->
<div class="card scroll-card">
<div class="ai-header-row">
<h2>ü§ñ AI Companion</h2>
<button class="ai-clear-btn" onclick="clearAiChats()">Clear</button>
</div>
<div class="chat" id="chat"></div>
<div class="input-group">
<input id="aiInput" placeholder="Talk to AI">
<button onclick="aiChat()">Talk</button>
</div>
</div>

<!-- Reminders -->
<div class="card scroll-card">
<h2>‚è∞ Reminders</h2>
<div class="input-group">
<input id="reminderText" placeholder="Reminder">
<input type="number" id="reminderMinutes" placeholder="Minutes">
<button onclick="addReminder()">Set</button>
</div>
<ul id="reminders"></ul>
</div>

<!-- Tasks -->
<div class="card scroll-card">
<h2>üìä Productivity</h2>
<div class="input-group">
<input id="task" placeholder="Task">
<button onclick="addTask()">Add</button>
</div>
<ul id="taskList"></ul>
</div>

<!-- Grocery Finance -->
<div class="card">
<h2>üßæ Grocery Financing</h2>
<input id="gCost" placeholder="Monthly ‚Çπ">
<input id="gMonths" placeholder="Months">
<input id="buffer" placeholder="Buffer %">
<button onclick="calculateFinance()">Plan</button>
<p id="financeResult"></p>
</div>

<!-- Mood Tracker -->
<div class="card">
<h2>üßò Mood Tracker</h2>
<select id="mood">
<option>üòä Happy</option>
<option>üòê Neutral</option>
<option>üòî Low</option>
</select>
<button onclick="saveMood()">Save</button>
<div id="moodLogs"></div>
</div>

<!-- Water -->
<div class="card">
<h2>üíß Water Intake</h2>
<input id="waterGoalInput" placeholder="Daily goal">
<button onclick="setWaterGoal()">Set Goal</button>
<input id="waterInput" placeholder="Glasses">
<button onclick="saveWater()">Track</button>
<button class="water-clear-btn" onclick="clearWaterData()">Clear Intake + Goal</button>
<p id="waterProgress"></p>
</div>

<!-- Sleep -->
<div class="card">
<h2>üí§ Sleep</h2>
<input id="sleepInput" placeholder="Hours">
<button onclick="saveSleep()">Save</button>
<p id="sleepResult"></p>
</div>

<!-- Wellness Music -->
<div class="card">
<h2>üéµ Wellness Music</h2>
<iframe style="border-radius:14px" src="https://open.spotify.com/embed/playlist/0Gwjm4uWLCSE7ZIiY6dK2X" width="100%" height="190"></iframe>
</div>

<!-- Time Traveller Mirror -->
<div class="card scroll-card">
<h2>ü™û Time Traveller Mirror</h2>
<input id="futureTask" placeholder="Enter goal">
<button onclick="timeTraveller()">Check</button>
<div id="timeMirror"></div>
</div>

<!-- Motivational Quotes -->
<div class="card">
<h2>üí° Motivational Quotes</h2>
<p id="quoteDisplay"></p>
<button onclick="newQuote()">Inspire Me</button>
</div>

<!-- Gratitude Journal -->
<div class="card scroll-card">
<h2>üôè Gratitude Journal</h2>
<textarea id="gratitudeInput" rows="3"></textarea>
<button onclick="saveGratitude()">Save</button>
<div id="gratitudeLogs"></div>
</div>

<!-- Daily Challenge -->
<div class="card">
<h2>üèÜ Daily Challenge</h2>
<p id="dailyChallenge"></p>
<button onclick="completeChallenge()">Complete</button>
<p id="challengeResult"></p>
</div>

<!-- Daily Wellness Score -->
<div class="card">
<h2>‚≠ê Daily Wellness Score</h2>
<div id="wellnessScore" class="wellness-badge">0/100</div>
<p id="wellnessStatus" class="wellness-status">Needs Focus</p>
<ul id="wellnessActions" class="wellness-actions">
  <li>Log your first check-in for today.</li>
  <li>Set your water target and drink one glass.</li>
  <li>Add one gratitude note tonight.</li>
</ul>
</div>

<!-- Mood Crash Prevention -->
<div class="card">
<h2>üö® Mood Crash Prevention</h2>
<div class="crash-risk-head">
  <div id="crashRiskValue" class="crash-risk-value">0/100</div>
  <div id="crashRiskLevel" class="crash-risk-pill">Low Risk</div>
</div>
<div class="crash-meter"><div id="crashRiskFill" class="crash-meter-fill"></div></div>
<p id="crashRiskReason" class="crash-risk-sub">Log your first entries to generate risk analysis.</p>
<button class="crash-rescue-btn" onclick="runCrashRescueFlow()">Run 2-Min Rescue</button>
<ul id="crashRescuePlan" class="crash-plan"></ul>
</div>

<!-- Weekly Review + AI Coach -->
<div class="card">
<h2>üß† Weekly Review + AI Coach</h2>
<p id="weeklyRange" class="weekly-range">Last 7 days review</p>

<p class="weekly-section-title">‚úÖ What Improved</p>
<ul id="weeklyImproved" class="weekly-list"></ul>

<p class="weekly-section-title">‚ö†Ô∏è What Dropped</p>
<ul id="weeklyDropped" class="weekly-list"></ul>

<p class="weekly-section-title">üéØ Top 3 Next-Week Actions</p>
<ul id="weeklyActions" class="weekly-list"></ul>

<div class="weekly-target-box">
  <p id="weeklyTargetsDisplay" class="weekly-target-text">Targets: Water -, Sleep -, Tasks -</p>
  <button class="weekly-target-btn" onclick="setNextWeekTargets()">Set Next Week Targets</button>
</div>
</div>

<!-- Adaptive Habit Quest -->
<div class="card">
<h2>üéÆ Adaptive Habit Quest</h2>
<div class="quest-top">
  <div id="questXp" class="quest-stat">XP 0/100</div>
</div>
<div class="quest-progress"><div id="questProgressFill" class="quest-progress-fill"></div></div>
<p id="questShield" class="burnout-sub">Streak shield: Inactive</p>
<ul id="questList" class="quest-list"></ul>
</div>

<!-- Predictive Burnout Radar -->
<div class="card">
<h2>üì° Predictive Burnout Radar</h2>
<div id="burnoutRisk" class="burnout-risk">0/100</div>
<p id="burnoutWindow" class="wellness-status">Low Risk ‚Ä¢ Stable window</p>
<p id="burnoutReason" class="burnout-sub">Forecast appears stable right now.</p>
<ul id="burnoutSchedule" class="burnout-list"></ul>
<button class="burnout-btn" onclick="applyRecoverySchedule()">Apply Recovery Schedule</button>
</div>

<!-- Insights -->
<div class="card" id="insightsCard">
<h2>üìà Insights & Streaks</h2>

<div class="insight-task-top">
  <small id="insightTaskTopLabel" class="insight-task-label">Tasks completed 0/0</small>
  <div class="insight-bar"><div id="insightTaskTopBar" class="insight-fill"></div></div>
</div>

<div class="insight-switch-head">
  <p id="insightMetricTitle" class="insight-metric-title">Productivity Trend</p>
  <button id="insightNextBtn" onclick="nextInsightMetric()">Next</button>
</div>
<small id="insightMetricLabel" class="insight-metric-label">0%</small>
<svg id="insightLineGraph" class="insight-line-graph" viewBox="0 0 320 74" preserveAspectRatio="none">
  <defs>
    <linearGradient id="insightGraphGradient" x1="0" y1="0" x2="1" y2="0">
      <stop offset="0%" stop-color="var(--primary)" />
      <stop offset="100%" stop-color="var(--accent)" />
    </linearGradient>
  </defs>
  <path id="insightLinePath" class="insight-line-path" d="" />
</svg>
</div>

<script type="module">
  // üî• Firebase Imports
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { initializeFirestore, persistentLocalCache, getFirestore, collection, addDoc, getDocs, serverTimestamp, deleteDoc, doc, updateDoc, setDoc, getDoc } 
from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
import { 
  getAuth,
  createUserWithEmailAndPassword, 
  signInWithEmailAndPassword, 
  onAuthStateChanged, 
  signOut,
  sendEmailVerification,
  sendPasswordResetEmail,
  fetchSignInMethodsForEmail,
  updateProfile,
  GoogleAuthProvider,
  signInWithPopup
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

// üî• Your Firebase Config
const firebaseConfig = {
  apiKey: "AIzaSyCirCkRGlsODEExB9VLVY08Zw7b84zm_Qc",
  authDomain: "novaafix-86912.firebaseapp.com",
  projectId: "novaafix-86912",
  storageBucket: "novaafix-86912.firebasestorage.app",
  messagingSenderId: "699084708640",
  appId: "1:699084708640:web:401f5d6990d818551e1545",
  measurementId: "G-WHHXFW3N7R"
};

// üî• Initialize Firebase
const app = initializeApp(firebaseConfig);
let analytics = null;
try {
  analytics = getAnalytics(app);
} catch (_) {}
const auth = getAuth(app);
let db;
try {
  db = initializeFirestore(app, {
    localCache: persistentLocalCache()
  });
} catch (_) {
  db = getFirestore(app);
}
const googleProvider = new GoogleAuthProvider();
googleProvider.setCustomParameters({
  prompt: "select_account"
});

// ---------- DOM REFERENCES ----------
const emailInput = document.getElementById("emailInput");
const passwordInput = document.getElementById("passwordInput");
const usernameInput = document.getElementById("usernameInput");
const googleAuthButton = document.getElementById("googleAuthButton");
const splash = document.getElementById("splash");
const signInModal = document.getElementById("signInModal");
const dashboard = document.querySelector(".dashboard");
const accountBtn = document.getElementById("accountBtn");
const accountOverlay = document.getElementById("accountOverlay");
const accountPanel = document.getElementById("accountPanel");
const crashAlertBanner = document.getElementById("crashAlertBanner");
const crashBannerText = document.getElementById("crashBannerText");
const crashRiskValue = document.getElementById("crashRiskValue");
const crashRiskFill = document.getElementById("crashRiskFill");
const crashRiskLevel = document.getElementById("crashRiskLevel");
const crashRiskReason = document.getElementById("crashRiskReason");
const crashRescuePlan = document.getElementById("crashRescuePlan");
const weeklyRange = document.getElementById("weeklyRange");
const weeklyImproved = document.getElementById("weeklyImproved");
const weeklyDropped = document.getElementById("weeklyDropped");
const weeklyActions = document.getElementById("weeklyActions");
const weeklyTargetsDisplay = document.getElementById("weeklyTargetsDisplay");
const questXpEl = document.getElementById("questXp");
const questProgressFill = document.getElementById("questProgressFill");
const questShieldEl = document.getElementById("questShield");
const questListEl = document.getElementById("questList");
const burnoutRiskEl = document.getElementById("burnoutRisk");
const burnoutWindowEl = document.getElementById("burnoutWindow");
const burnoutReasonEl = document.getElementById("burnoutReason");
const burnoutScheduleEl = document.getElementById("burnoutSchedule");
const accountName = document.getElementById("accountName");
const accountEmail = document.getElementById("accountEmail");
const accountVerifyStatus = document.getElementById("accountVerifyStatus");
const accountUid = document.getElementById("accountUid");
const signOutBtn = document.getElementById("signOutBtn");
const chat = document.getElementById("chat");
const aiInput = document.getElementById("aiInput");
const reminderText = document.getElementById("reminderText");
const reminderMinutes = document.getElementById("reminderMinutes");
const reminders = document.getElementById("reminders");
const task = document.getElementById("task");
const taskList = document.getElementById("taskList");
const gCost = document.getElementById("gCost");
const gMonths = document.getElementById("gMonths");
const buffer = document.getElementById("buffer");
const financeResult = document.getElementById("financeResult");
const mood = document.getElementById("mood");
const moodLogs = document.getElementById("moodLogs");
const waterGoalInput = document.getElementById("waterGoalInput");
const waterInput = document.getElementById("waterInput");
const waterProgress = document.getElementById("waterProgress");
const sleepInput = document.getElementById("sleepInput");
const sleepResult = document.getElementById("sleepResult");
const futureTask = document.getElementById("futureTask");
const timeMirror = document.getElementById("timeMirror");
const quoteDisplay = document.getElementById("quoteDisplay");
const gratitudeInput = document.getElementById("gratitudeInput");
const gratitudeLogs = document.getElementById("gratitudeLogs");
const dailyChallengeElement = document.getElementById("dailyChallenge");
const challengeResultElement = document.getElementById("challengeResult");
const importFileInput = document.getElementById("importFileInput");
const wellnessScoreEl = document.getElementById("wellnessScore");
const wellnessStatusEl = document.getElementById("wellnessStatus");
const wellnessActionsEl = document.getElementById("wellnessActions");
const insightsCard = document.getElementById("insightsCard");
const insightTaskTopLabel = document.getElementById("insightTaskTopLabel");
const insightTaskTopBar = document.getElementById("insightTaskTopBar");
const insightMetricTitle = document.getElementById("insightMetricTitle");
const insightMetricLabel = document.getElementById("insightMetricLabel");
const insightLinePath = document.getElementById("insightLinePath");

// ---------- SPLASH + AUTH CHECK ----------
document.body.style.overflow = "hidden";
let splashRemoved = false;

function hideSplash() {
  if (splashRemoved || !splash) return;
  splash.classList.add("hide");
  setTimeout(() => {
    if (!splashRemoved) {
      splash.remove();
      splashRemoved = true;
      document.body.style.overflow = "auto";
    }
  }, 1000);
}

function toggleAccountPanel() {
  if (!accountPanel || !accountOverlay) return;
  const isOpen = accountPanel.style.display === "block";
  accountPanel.style.display = isOpen ? "none" : "block";
  accountOverlay.style.display = isOpen ? "none" : "block";
}

function closeAccountPanel() {
  if (!accountPanel || !accountOverlay) return;
  accountPanel.style.display = "none";
  accountOverlay.style.display = "none";
}

function updateAccountPanel(user) {
  if (!user) {
    if (accountName) accountName.innerText = "-";
    if (accountEmail) accountEmail.innerText = "-";
    if (accountVerifyStatus) accountVerifyStatus.innerText = "-";
    if (accountUid) accountUid.innerText = "-";
    return;
  }

  const fallbackName = (user.email || "").split("@")[0] || "User";
  if (accountName) accountName.innerText = user.displayName || fallbackName;
  if (accountEmail) accountEmail.innerText = user.email || "Not available";
  if (accountVerifyStatus) accountVerifyStatus.innerText = user.emailVerified ? "Verified ‚úÖ" : "Not verified ‚ö†Ô∏è";
  if (accountUid) accountUid.innerText = user.uid || "Not available";
}

document.addEventListener("click", (event) => {
  if (!accountPanel || !accountBtn) return;
  const clickedInside = accountPanel.contains(event.target) || accountBtn.contains(event.target);
  if (!clickedInside) closeAccountPanel();
});

async function clearAllAccountData() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const warningOne = confirm("‚ö†Ô∏è This will permanently delete all your NovaFix data (tasks, mood, water, sleep, gratitude, reminders, AI chats, and insights). Continue?");
  if (!warningOne) return;

  const warningTwo = confirm("Final warning: this cannot be undone. Your account will stay signed in, but all app data will be erased. Proceed?");
  if (!warningTwo) return;

  try {
    clearAllReminderTimers();

    const targetCollections = [
      "moods",
      "tasks",
      "waterIntake",
      "sleepLogs",
      "gratitudeLogs",
      "aiChats",
      "reminders",
      "challengeHistory",
      "rescueEvents"
    ];

    await Promise.all(targetCollections.map((name) => clearUserCollection(user.uid, name)));
    await deleteDoc(doc(db, "users", user.uid, "settings", "water")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "dailyChallenge")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "aiUsage")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "weeklyTargets")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "habitQuest")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "insights", "current")).catch(() => {});

    moodLogs.innerHTML = "";
    chat.innerHTML = "";
    taskList.innerHTML = "";
    reminders.innerHTML = "";
    gratitudeLogs.innerHTML = "";
    waterProgress.innerText = "";
    sleepResult.innerText = "";
    challengeResultElement.innerText = "";
    waterGoalInput.value = "";
    waterInput.value = "";
    sleepInput.value = "";
    task.value = "";
    reminderText.value = "";
    reminderMinutes.value = "";
    gratitudeInput.value = "";

    moodHistory.length = 0;
    waterHistory.length = 0;
    sleepHistory.length = 0;
    moodDates.length = 0;
    waterDates.length = 0;
    sleepDates.length = 0;
    taskEntries.length = 0;
    gratitudeEntries.length = 0;
    challengeDates.length = 0;
    aiRecentPrompts.length = 0;
    habitQuests.length = 0;
    burnoutRecoveryPlan.length = 0;
    dailyChallengeCompleted = false;
    currentChallengeDateKey = "";
    questDateKey = "";
    questXp = 0;
    questShieldAvailable = false;
    waterGoal = 0;
    aiUsageDateKeyGMT = "";
    aiUsageCount = 0;

    await Promise.all([
      loadDailyChallenge(user.uid),
      loadMoods(user.uid),
      loadAiUsage(user.uid),
      loadAiChats(user.uid),
      loadTasks(user.uid),
      loadReminders(user.uid),
      loadWaterData(user.uid),
      loadSleepData(user.uid),
      loadGratitude(user.uid),
      loadWeeklyTargets(user.uid),
      loadRescueEvents(user.uid),
      loadHabitQuest(user.uid)
    ]);

    closeAccountPanel();
    alert("‚úÖ All account data cleared. You are still signed in.");
  } catch (err) {
    notifyFirestoreError(err);
  }
}

try {
  onAuthStateChanged(auth, (user) => {
    hideSplash();

    setTimeout(async () => {
      if (user) {
        await user.reload();
        if (!user.emailVerified) {
          const verificationError = document.getElementById("signInError");
          if (verificationError) {
            verificationError.style.display = "block";
            verificationError.style.color = "#ff6b6b";
            verificationError.innerText = "Please verify your email before signing in.";
          }
          await signOut(auth);
          return;
        }

        dashboard.style.display = "grid";
        accountBtn.style.display = "block";
        closeAccountPanel();
        updateAccountPanel(user);
        signInModal.style.display = "none";
        loadDailyChallenge(user.uid);
        loadMoods(user.uid);
        loadAiUsage(user.uid);
        loadAiChats(user.uid);
        loadTasks(user.uid);
        loadReminders(user.uid);
        loadWeeklyTargets(user.uid);
        loadRescueEvents(user.uid);
        loadHabitQuest(user.uid);
        loadWaterData(user.uid);
        loadSleepData(user.uid);
        loadGratitude(user.uid);
        startDailyChallengeWatcher();
        scheduleWaterGoalReset(user.uid);
      } else {
        stopDailyChallengeWatcher();
        clearWaterGoalResetSchedule();
        closeAccountPanel();
        updateAccountPanel(null);
        signInModal.style.display = "flex";
        dashboard.style.display = "none";
        accountBtn.style.display = "none";
        moodLogs.innerHTML = "";
        chat.innerHTML = "";
        taskList.innerHTML = "";
        reminders.innerHTML = "";
        gratitudeLogs.innerHTML = "";
        clearAllReminderTimers();
        waterProgress.innerText = "";
        sleepResult.innerText = "";
        wellnessScoreEl.innerText = "0/100";
        wellnessStatusEl.innerText = "Needs Focus";
        wellnessActionsEl.innerHTML = "<li>Log your first check-in for today.</li><li>Set your water target and drink one glass.</li><li>Add one gratitude note tonight.</li>";
        if (crashAlertBanner) crashAlertBanner.style.display = "none";
        if (crashRiskValue) crashRiskValue.innerText = "0/100";
        if (crashRiskFill) crashRiskFill.style.width = "0%";
        if (crashRiskLevel) crashRiskLevel.innerText = "Low Risk";
        if (crashRiskReason) crashRiskReason.innerText = "Log your first entries to generate risk analysis.";
        if (crashRescuePlan) crashRescuePlan.innerHTML = "";
        rescueEvents.length = 0;
        habitQuests.length = 0;
        burnoutRecoveryPlan.length = 0;
        questDateKey = "";
        questXp = 0;
        questShieldAvailable = false;
        weeklyTargets = { waterGoal: 0, sleepTarget: 8, taskTarget: 5 };
        if (weeklyRange) weeklyRange.innerText = "Last 7 days review";
        if (weeklyTargetsDisplay) weeklyTargetsDisplay.innerText = "Targets: Water -, Sleep -, Tasks -";
        if (weeklyImproved) weeklyImproved.innerHTML = "";
        if (weeklyDropped) weeklyDropped.innerHTML = "";
        if (weeklyActions) weeklyActions.innerHTML = "";
        if (questXpEl) questXpEl.innerText = "XP 0/100";
        if (questProgressFill) questProgressFill.style.width = "0%";
        if (questShieldEl) questShieldEl.innerText = "Streak shield: Inactive";
        if (questListEl) questListEl.innerHTML = "";
        if (burnoutRiskEl) burnoutRiskEl.innerText = "0/100";
        if (burnoutWindowEl) burnoutWindowEl.innerText = "Low Risk ‚Ä¢ Stable window";
        if (burnoutReasonEl) burnoutReasonEl.innerText = "Forecast appears stable right now.";
        if (burnoutScheduleEl) burnoutScheduleEl.innerHTML = "";
        challengeResultElement.innerText = "";
        moodHistory.length = 0;
        waterHistory.length = 0;
        sleepHistory.length = 0;
        moodDates.length = 0;
        waterDates.length = 0;
        sleepDates.length = 0;
        taskEntries.length = 0;
        gratitudeEntries.length = 0;
        challengeDates.length = 0;
        dailyChallengeCompleted = false;
        currentChallengeDateKey = "";
        waterGoal = 0;
        aiUsageDateKeyGMT = "";
        aiUsageCount = 0;
        waterGoalInput.value = "";
      }
    }, 1000); // match your splash transition
  });
} catch (_) {
  setTimeout(() => {
    hideSplash();
    signInModal.style.display = "flex";
    dashboard.style.display = "none";
    accountBtn.style.display = "none";
    closeAccountPanel();
    updateAccountPanel(null);
  }, 1000);
}

setTimeout(hideSplash, 2000);

// ---------- COLOR WAVES ----------
const waves = [
  ["#2196f3","#ff9800"],
  ["#9c27b0","#03a9f4"],
  ["#ff5722","#4caf50"],
  ["#3f51b5","#e91e63"],
  ["#009688","#ffc107"],
  ["#8e24aa","#ff6f91"],
  ["#00c853","#ff9100"],
  ["#1e88e5","#ff7043"],
  ["#6a1b9a","#f06292"],
  ["#00bfa5","#ffca28"],
  ["#43a047","#fb8c00"],
  ["#3949ab","#ec407a"],
  ["#7e57c2","#26c6da"],
  ["#2e7d32","#ff6d00"],
  ["#5e35b1","#ff8a65"],
  ["#26a69a","#ffb300"],
  ["#4a148c","#ff80ab"],
  ["#ab47bc","#26a69a"],
  ["#ef5350","#7cb342"],
  ["#1a237e","#00acc1"],
  ["#8e24aa","#26c6da"],
  ["#00897b","#f4511e"],
  ["#5c6bc0","#ffa726"],
  ["#d81b60","#5e35b1"],
  ["#039be5","#8bc34a"],
  ["#7b1fa2","#ff7043"],
  ["#43a047","#ec407a"],
  ["#3949ab","#26a69a"],
  ["#e53935","#1e88e5"],
  ["#6d4c41","#29b6f6"],
  ["#8e24aa","#42a5f5"],
  ["#ad1457","#26a69a"],
  ["#283593","#ef5350"],
  ["#0277bd","#ab47bc"],
  ["#00695c","#ff7043"],
  ["#4527a0","#66bb6a"],
  ["#00838f","#ff8f00"],
  ["#5d4037","#42a5f5"],
  ["#c2185b","#7e57c2"],
  ["#33691e","#ff6f00"],
  ["#1565c0","#ec407a"],
  ["#00897b","#5c6bc0"],
  ["#6a1b9a","#26c6da"],
  ["#7b1fa2","#66bb6a"],
  ["#303f9f","#ffa726"]
];
let w = 1;
let currentWaveA = waves[0][0];
let currentWaveB = waves[0][1];
let waveAnimationId = null;
const WAVE_HOLD_MS = 9000;
const WAVE_TRANSITION_MS = 8000;

function hexToRgb(hex) {
  const normalized = hex.replace("#", "");
  const value = normalized.length === 3
    ? normalized.split("").map((char) => char + char).join("")
    : normalized;
  const parsed = Number.parseInt(value, 16);
  return {
    r: (parsed >> 16) & 255,
    g: (parsed >> 8) & 255,
    b: parsed & 255
  };
}

function rgbToHex({ r, g, b }) {
  const toHex = (value) => Math.max(0, Math.min(255, Math.round(value))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

function lerp(start, end, progress) {
  return start + (end - start) * progress;
}

function setWaveColors(colorA, colorB) {
  document.documentElement.style.setProperty("--waveA", colorA);
  document.documentElement.style.setProperty("--waveB", colorB);
  document.documentElement.style.setProperty("--primary", colorA);
  document.documentElement.style.setProperty("--accent", colorB);
}

function animateWaveTo(targetA, targetB, durationMs) {
  if (waveAnimationId) cancelAnimationFrame(waveAnimationId);

  const startA = hexToRgb(currentWaveA);
  const startB = hexToRgb(currentWaveB);
  const endA = hexToRgb(targetA);
  const endB = hexToRgb(targetB);
  const startTime = performance.now();

  const tick = (now) => {
    const elapsed = now - startTime;
    const progress = Math.min(1, elapsed / durationMs);
    const eased = progress < 0.5
      ? 2 * progress * progress
      : 1 - Math.pow(-2 * progress + 2, 2) / 2;

    const nextA = rgbToHex({
      r: lerp(startA.r, endA.r, eased),
      g: lerp(startA.g, endA.g, eased),
      b: lerp(startA.b, endA.b, eased)
    });

    const nextB = rgbToHex({
      r: lerp(startB.r, endB.r, eased),
      g: lerp(startB.g, endB.g, eased),
      b: lerp(startB.b, endB.b, eased)
    });

    setWaveColors(nextA, nextB);

    if (progress < 1) {
      waveAnimationId = requestAnimationFrame(tick);
      return;
    }

    currentWaveA = targetA;
    currentWaveB = targetB;
    setTimeout(rotateWave, WAVE_HOLD_MS);
  };

  waveAnimationId = requestAnimationFrame(tick);
}

function rotateWave() {
  const [targetA, targetB] = waves[w];
  w = (w + 1) % waves.length;
  animateWaveTo(targetA, targetB, WAVE_TRANSITION_MS);
}

setWaveColors(currentWaveA, currentWaveB);
setTimeout(rotateWave, WAVE_HOLD_MS);

// ---------- SIGN-IN / SIGN-UP ----------
let authMode="signin";
function toggleAuth(){
  authMode=authMode==="signin"?"signup":"signin";
  const title=document.getElementById("modalTitle");
  const button=document.getElementById("actionButton");
  const toggleText=document.getElementById("toggleText");
  const error=document.getElementById("signInError");
  error.style.display="none";
  if(authMode==="signup"){
    title.innerText="Create a NovaFix Account üåü";
    button.innerText="Sign Up";
    googleAuthButton.innerText = "Sign Up with Google";
    toggleText.innerText="Already have an account? Sign In";
    usernameInput.style.display = "block";
  } else {
    title.innerText="Welcome to NovaFix üåü";
    button.innerText="Sign In";
    googleAuthButton.innerText = "Sign In with Google";
    toggleText.innerText="Don't have an account? Sign Up";
    usernameInput.style.display = "none";
  }
}

async function handleAuth() {
  const username = usernameInput.value.trim();
  const email = emailInput.value.trim();
  const password = passwordInput.value.trim();
  const error = document.getElementById("signInError");

  if (!email || !password) {
    error.style.display = "block";
    error.innerText = "Email and password are required!";
    return;
  }

  if (authMode === "signup" && !username) {
    error.style.display = "block";
    error.innerText = "Username is required for sign up!";
    return;
  }

  try {
    if (authMode === "signup") {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      await updateProfile(userCredential.user, { displayName: username });
      try {
        await sendEmailVerification(userCredential.user, {
          url: window.location.protocol === "file:" ? "https://novaafix-86912.firebaseapp.com" : window.location.origin,
          handleCodeInApp: false
        });
      } catch (verifyErr) {
        console.error("Signup verification send error:", verifyErr?.code || verifyErr);
      }

      await signOut(auth);
      authMode = "signin";
      const title = document.getElementById("modalTitle");
      const button = document.getElementById("actionButton");
      const toggleText = document.getElementById("toggleText");
      title.innerText = "Welcome to NovaFix üåü";
      button.innerText = "Sign In";
      googleAuthButton.innerText = "Sign In with Google";
      toggleText.innerText = "Don't have an account? Sign Up";
      usernameInput.style.display = "none";

      error.style.display = "block";
      error.style.color = "#7CFFB2";
      error.innerText = "Account created. Verify your email first, then sign in.";
      return;
    } else {
      const credential = await signInWithEmailAndPassword(auth, email, password);
      await credential.user.reload();
      if (!credential.user.emailVerified) {
        try {
          await sendEmailVerification(credential.user, {
            url: window.location.protocol === "file:" ? "https://novaafix-86912.firebaseapp.com" : window.location.origin,
            handleCodeInApp: false
          });
        } catch (verifyErr) {
          console.error("Signin verification resend error:", verifyErr?.code || verifyErr);
        }
        await signOut(auth);
        error.style.display = "block";
        error.style.color = "#ff6b6b";
        error.innerText = "Please verify your email before signing in. We sent a verification email.";
        return;
      }
    }
  } catch (err) {
    error.style.display = "block";
    error.style.color = "#ff6b6b";
    error.innerText = err.message;
  }
}

function signOutUser() {
  closeAccountPanel();
  signOut(auth);
}

async function handleGoogleAuth() {
  const error = document.getElementById("signInError");
  error.style.display = "none";

  if (window.location.protocol === "file:") {
    error.style.display = "block";
    error.innerText = "Google auth does not work on file://. Start a local server and open via http://localhost:<port>.";
    return;
  }

  try {
    await signInWithPopup(auth, googleProvider);
  } catch (err) {
    const currentOrigin = window.location.origin || "unknown-origin";
    const currentHost = window.location.hostname || "unknown-host";
    const isUnauthorizedDomain = (err?.code || "").includes("unauthorized-domain");
    error.style.display = "block";
    error.innerText = isUnauthorizedDomain
      ? `Unauthorized domain. Current origin: ${currentOrigin}. Add '${currentHost}' in Firebase Auth > Settings > Authorized domains, then hard refresh.`
      : (err.message || "Google authentication failed.");
  }
}

async function sendResetPasswordEmail() {
  const email = emailInput.value.trim();
  const error = document.getElementById("signInError");
  error.style.display = "none";

  if (!email) {
    error.style.display = "block";
    error.style.color = "#ff6b6b";
    error.innerText = "Enter your email first, then tap Reset Password.";
    return;
  }

  try {
    const methods = await fetchSignInMethodsForEmail(auth, email);
    if (methods.includes("google.com") && !methods.includes("password")) {
      error.style.display = "block";
      error.style.color = "#ff6b6b";
      error.innerText = "This email uses Google sign-in. Use Google login (no password to reset).";
      return;
    }

    const actionCodeSettings = {
      url: window.location.protocol === "file:" ? "https://novaafix-86912.firebaseapp.com" : window.location.origin,
      handleCodeInApp: false
    };

    await sendPasswordResetEmail(auth, email, actionCodeSettings);
    error.style.display = "block";
    error.style.color = "#7CFFB2";
    error.innerText = "Password reset email sent. Check Inbox/Spam/Promotions.";
  } catch (err) {
    error.style.display = "block";
    error.style.color = "#ff6b6b";
    error.innerText = err?.message || "Could not send reset email.";
    console.error("Reset password error:", err?.code || err);
  }
}

async function sendAccountResetPasswordEmail() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const email = (user.email || accountEmail?.innerText || "").trim();
  if (!email || email === "-") {
    alert("No email found for this account.");
    return;
  }

  try {
    const methods = await fetchSignInMethodsForEmail(auth, email);
    if (methods.includes("google.com") && !methods.includes("password")) {
      alert("This account uses Google sign-in. There is no password to reset.");
      return;
    }

    const actionCodeSettings = {
      url: window.location.protocol === "file:" ? "https://novaafix-86912.firebaseapp.com" : window.location.origin,
      handleCodeInApp: false
    };

    await sendPasswordResetEmail(auth, email, actionCodeSettings);
    alert(`‚úÖ Password reset email sent to ${email}. Check Inbox/Spam/Promotions.`);
  } catch (err) {
    console.error("Account reset password error:", err?.code || err);
    alert(err?.message || "Could not send reset email.");
  }
}

// ---------- DASHBOARD JS ----------
const moodHistory=[],waterHistory=[],sleepHistory=[];
const moodDates=[];
const waterDates=[];
const sleepDates=[];
const taskEntries=[];
const gratitudeEntries=[];
const rescueEvents=[];
const habitQuests=[];
const burnoutRecoveryPlan=[];
const aiRecentPrompts=[];
const aiSessionState = {
  lastIntent: "",
  lastAdvice: [],
  userEmotion: "",
  lastUserMessage: "",
  turnCount: 0,
  userFacts: {
    name: "",
    goal: "",
    likes: [],
    dislikes: []
  },
  lastSnapshot: null,
  conversationSummary: "",
  topicHistory: []
};
const AI_MODE_PRESETS = {
  balanced: { depth: 2, style: "balanced" },
  coach: { depth: 3, style: "coach" },
  strict: { depth: 3, style: "strict" },
  creative: { depth: 3, style: "creative" },
  ultra: { depth: 4, style: "ultra" }
};
let aiReasoningMode = "ultra";
const challengeDates=[];
let dailyChallengeCompleted=false;
let currentChallengeText="";
let currentChallengeDateKey="";
let challengeWatcherInterval=null;
let insightsPersistTimer=null;
let waterGoalResetTimeoutId = null;
let insightMetricIndex = 0;
let questDateKey = "";
let questXp = 0;
let questShieldAvailable = false;
let weeklyTargets = {
  waterGoal: 0,
  sleepTarget: 8,
  taskTarget: 5
};
const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || "local";
const FIRESTORE_CRASH_MESSAGE = "Something went wrong. Please try again later.";
const AI_DAILY_LIMIT = 20;
let aiUsageDateKeyGMT = "";
let aiUsageCount = 0;
let lastFirestoreErrorAlertAt = 0;
const reminderIntervals = new Map();

function notifyFirestoreError(err) {
  console.error("Firestore operation failed:", err);
  const now = Date.now();
  if (now - lastFirestoreErrorAlertAt > 4000) {
    alert(FIRESTORE_CRASH_MESSAGE);
    lastFirestoreErrorAlertAt = now;
  }
}

function dateToKey(dateValue) {
  const date = dateValue instanceof Date ? dateValue : new Date(dateValue);
  if (Number.isNaN(date.getTime())) return null;
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

function calcStreak(dateValues) {
  const daySet = new Set(
    dateValues
      .map((value) => dateToKey(value))
      .filter(Boolean)
  );

  let streak = 0;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  while (true) {
    const dayKey = dateToKey(today);
    if (!daySet.has(dayKey)) break;
    streak++;
    today.setDate(today.getDate() - 1);
  }

  return streak;
}

function setInsightBar(element, percent) {
  const bounded = Math.max(0, Math.min(100, percent));
  element.style.width = `${bounded}%`;
}

function buildLinePath(values) {
  if (!Array.isArray(values) || !values.length) return "";
  const width = 320;
  const height = 74;
  const padding = 8;
  const maxValue = Math.max(1, ...values);
  const minValue = Math.min(0, ...values);
  const range = Math.max(1, maxValue - minValue);
  const stepX = values.length > 1 ? (width - (padding * 2)) / (values.length - 1) : 0;

  return values.map((value, index) => {
    const x = padding + stepX * index;
    const normalized = (value - minValue) / range;
    const y = height - padding - (normalized * (height - (padding * 2)));
    return `${index === 0 ? "M" : "L"}${x.toFixed(2)} ${y.toFixed(2)}`;
  }).join(" ");
}

function getLastNDates(n) {
  const days = [];
  const today = new Date();
  for (let index = n - 1; index >= 0; index -= 1) {
    const day = new Date(today);
    day.setDate(today.getDate() - index);
    day.setHours(0, 0, 0, 0);
    days.push(day);
  }
  return days;
}

function getInsightSeries(metricType) {
  const days = getLastNDates(7);

  if (metricType === "tasks") {
    const values = days.map((day) => {
      const dayKey = dateToKey(day);
      const dayTasks = taskEntries.filter((entry) => dateToKey(entry.time) === dayKey);
      if (!dayTasks.length) return 0;
      const completed = dayTasks.filter((entry) => !!entry.completed).length;
      return Math.round((completed / dayTasks.length) * 100);
    });
    return values;
  }

  if (metricType === "sleep") {
    return days.map((day) => {
      const dayKey = dateToKey(day);
      let latest = 0;
      sleepHistory.forEach((value, index) => {
        if (dateToKey(sleepDates[index]) === dayKey) latest = Number(value) || latest;
      });
      return Number(latest.toFixed(1));
    });
  }

  return days.map((day) => {
    const dayKey = dateToKey(day);
    return Number(waterHistory.reduce((sum, value, index) => {
      return dateToKey(waterDates[index]) === dayKey ? sum + (Number(value) || 0) : sum;
    }, 0).toFixed(1));
  });
}

function renderInsightMetricView(payload) {
  if (insightMetricTitle) insightMetricTitle.innerText = payload.title;
  if (insightMetricLabel) insightMetricLabel.innerText = payload.label;
  if (insightLinePath) {
    const path = buildLinePath(payload.series);
    insightLinePath.setAttribute("d", path);
  }
}

function nextInsightMetric() {
  insightMetricIndex = (insightMetricIndex + 1) % 3;
  updateInsights();
  if (insightsCard?.scrollIntoView) {
    insightsCard.scrollIntoView({ behavior: "smooth", block: "start" });
  }
}

function dateKeyToDate(dateKey) {
  if (!dateKey || typeof dateKey !== "string") return null;
  const [year, month, day] = dateKey.split("-").map(Number);
  if (!year || !month || !day) return null;
  const parsed = new Date(year, month - 1, day, 12, 0, 0, 0);
  return Number.isNaN(parsed.getTime()) ? null : parsed;
}

function toDateSafe(value) {
  if (!value) return null;
  if (value instanceof Date) return Number.isNaN(value.getTime()) ? null : value;
  const viaToDate = value?.toDate?.();
  if (viaToDate instanceof Date && !Number.isNaN(viaToDate.getTime())) return viaToDate;
  const parsed = new Date(value);
  return Number.isNaN(parsed.getTime()) ? null : parsed;
}

function isInRange(dateValue, startDate, endDate) {
  const parsed = toDateSafe(dateValue);
  if (!parsed) return false;
  return parsed >= startDate && parsed <= endDate;
}

function getWeekRanges() {
  const now = new Date();
  const currentEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
  const currentStart = new Date(currentEnd);
  currentStart.setDate(currentStart.getDate() - 6);
  currentStart.setHours(0, 0, 0, 0);

  const previousEnd = new Date(currentStart);
  previousEnd.setMilliseconds(previousEnd.getMilliseconds() - 1);
  const previousStart = new Date(previousEnd);
  previousStart.setDate(previousStart.getDate() - 6);
  previousStart.setHours(0, 0, 0, 0);

  return {
    currentStart,
    currentEnd,
    previousStart,
    previousEnd
  };
}

function computeWeekMetrics(startDate, endDate) {
  let moodSum = 0;
  let moodCount = 0;
  moodHistory.forEach((entry, index) => {
    const moodDate = moodDates[index];
    if (!isInRange(moodDate, startDate, endDate)) return;
    const score = String(entry || "").includes("üòä") ? 3 : String(entry || "").includes("üòê") ? 2 : String(entry || "").includes("üòî") ? 1 : 0;
    if (!score) return;
    moodSum += score;
    moodCount += 1;
  });

  let sleepSum = 0;
  let sleepCount = 0;
  sleepHistory.forEach((entry, index) => {
    const sleepDate = sleepDates[index];
    if (!isInRange(sleepDate, startDate, endDate)) return;
    sleepSum += Number(entry) || 0;
    sleepCount += 1;
  });

  const waterByDay = new Map();
  waterHistory.forEach((entry, index) => {
    const waterDate = waterDates[index];
    if (!isInRange(waterDate, startDate, endDate)) return;
    const dayKey = dateToKey(waterDate);
    if (!dayKey) return;
    waterByDay.set(dayKey, (waterByDay.get(dayKey) || 0) + (Number(entry) || 0));
  });

  const tasksInPeriod = taskEntries.filter((entry) => {
    const taskDate = toDateSafe(entry.time);
    return isInRange(taskDate, startDate, endDate);
  });
  const completedInPeriod = tasksInPeriod.filter((entry) => !!entry.completed).length;

  const rescuesInPeriod = rescueEvents.filter((entry) => isInRange(entry.time, startDate, endDate)).length;

  return {
    moodScore: moodCount ? moodSum / moodCount : 0,
    sleepAvg: sleepCount ? sleepSum / sleepCount : 0,
    waterDailyAvg: waterByDay.size ? [...waterByDay.values()].reduce((a, b) => a + b, 0) / 7 : 0,
    taskCompletion: tasksInPeriod.length ? completedInPeriod / tasksInPeriod.length : 0,
    rescues: rescuesInPeriod,
    taskCount: tasksInPeriod.length
  };
}

function setListItems(listElement, items, fallbackText) {
  if (!listElement) return;
  if (!items.length) {
    listElement.innerHTML = `<li>${fallbackText}</li>`;
    return;
  }
  listElement.innerHTML = items.map((item) => `<li>${item}</li>`).join("");
}

function renderWeeklyTargets() {
  if (!weeklyTargetsDisplay) return;
  weeklyTargetsDisplay.innerText = `Targets: Water ${weeklyTargets.waterGoal || "-"} glasses/day ‚Ä¢ Sleep ${weeklyTargets.sleepTarget || "-"} hrs ‚Ä¢ Tasks ${weeklyTargets.taskTarget || "-"}/day`;
}

function updateWeeklyReview() {
  const user = auth.currentUser;
  if (!user) return;

  const { currentStart, currentEnd, previousStart, previousEnd } = getWeekRanges();
  const current = computeWeekMetrics(currentStart, currentEnd);
  const previous = computeWeekMetrics(previousStart, previousEnd);

  if (weeklyRange) {
    weeklyRange.innerText = `Review window: ${currentStart.toLocaleDateString()} - ${currentEnd.toLocaleDateString()}`;
  }

  const improved = [];
  if (current.sleepAvg > previous.sleepAvg + 0.2) improved.push(`Sleep improved to ${current.sleepAvg.toFixed(1)}h avg.`);
  if (current.waterDailyAvg > previous.waterDailyAvg + 0.4) improved.push(`Hydration improved to ${current.waterDailyAvg.toFixed(1)} glasses/day.`);
  if (current.taskCompletion > previous.taskCompletion + 0.08) improved.push(`Task completion improved to ${Math.round(current.taskCompletion * 100)}%.`);
  if (current.moodScore > previous.moodScore + 0.15) improved.push("Mood trend improved this week.");
  if (current.rescues < previous.rescues) improved.push("Fewer rescue triggers than last week.");

  const dropped = [];
  if (current.sleepAvg < previous.sleepAvg - 0.2) dropped.push(`Sleep dropped to ${current.sleepAvg.toFixed(1)}h avg.`);
  if (current.waterDailyAvg < previous.waterDailyAvg - 0.4) dropped.push(`Hydration dipped to ${current.waterDailyAvg.toFixed(1)} glasses/day.`);
  if (current.taskCompletion < previous.taskCompletion - 0.08) dropped.push(`Task completion dropped to ${Math.round(current.taskCompletion * 100)}%.`);
  if (current.moodScore < previous.moodScore - 0.15) dropped.push("Mood trend dipped this week.");
  if (current.rescues > previous.rescues) dropped.push("Rescue triggers increased this week.");

  const actions = [];
  if (current.sleepAvg < 7) actions.push("Set wind-down reminder 60 minutes before sleep for 5 nights.");
  if (current.waterDailyAvg < Math.max(8, weeklyTargets.waterGoal || 8)) actions.push("Hit hydration target by scheduling 3 fixed water check-ins.");
  if (current.taskCompletion < 0.7) actions.push("Limit daily priority tasks to 3 and finish one before noon.");
  if (current.moodScore < 2) actions.push("Log mood twice daily and run one 2-minute rescue when stress rises.");
  if (current.rescues >= 3) actions.push("Use preventive reset every afternoon before the usual dip window.");
  while (actions.length < 3) actions.push("Keep the current routine and protect your strongest streak.");

  setListItems(weeklyImproved, improved, "No major gains yet ‚Äî consistency this week will unlock visible progress.");
  setListItems(weeklyDropped, dropped, "No clear drops this week ‚Äî maintain the trend.");
  setListItems(weeklyActions, actions.slice(0, 3), "Set one small target and repeat it daily.");
  renderWeeklyTargets();
}

async function loadWeeklyTargets(userId) {
  weeklyTargets = { waterGoal: 0, sleepTarget: 8, taskTarget: 5 };
  try {
    const snap = await getDoc(doc(db, "users", userId, "settings", "weeklyTargets"));
    if (snap.exists()) {
      const data = snap.data();
      weeklyTargets = {
        waterGoal: Number(data.waterGoal) || 0,
        sleepTarget: Number(data.sleepTarget) || 8,
        taskTarget: Number(data.taskTarget) || 5
      };
    }
  } catch (err) {
    notifyFirestoreError(err);
  }
  renderWeeklyTargets();
  updateWeeklyReview();
}

async function loadRescueEvents(userId) {
  rescueEvents.length = 0;
  try {
    const snap = await getDocs(collection(db, "users", userId, "rescueEvents"));
    snap.docs.forEach((docSnap) => {
      const data = docSnap.data();
      const time = toDateSafe(data.time);
      if (!time) return;
      rescueEvents.push({
        id: docSnap.id,
        time,
        level: data.level || ""
      });
    });
  } catch (err) {
    notifyFirestoreError(err);
  }
  updateWeeklyReview();
}

async function setNextWeekTargets() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const { currentStart, currentEnd } = getWeekRanges();
  const current = computeWeekMetrics(currentStart, currentEnd);
  const waterGoalTarget = Math.max(8, Math.min(16, Math.round(current.waterDailyAvg || 8) + 1));
  const sleepTarget = Math.max(7, Math.min(9, Math.round(((current.sleepAvg || 7) + 0.5) * 2) / 2));
  const taskTarget = Math.max(3, Math.min(10, Math.round((current.taskCount / 7) || 4)));

  weeklyTargets = {
    waterGoal: waterGoalTarget,
    sleepTarget,
    taskTarget
  };

  try {
    await setDoc(doc(db, "users", user.uid, "settings", "weeklyTargets"), {
      ...weeklyTargets,
      updatedAt: serverTimestamp()
    }, { merge: true });

    waterGoal = waterGoalTarget;
    waterGoalInput.value = String(waterGoalTarget);
    await setDoc(doc(db, "users", user.uid, "settings", "water"), {
      goal: waterGoalTarget,
      goalDateKey: getTodayKey()
    }, { merge: true });

    updateWaterProgress();
    updateWeeklyReview();
    alert(`‚úÖ Targets set: Water ${waterGoalTarget}, Sleep ${sleepTarget}h, Tasks ${taskTarget}/day.`);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function getQuestCandidatePool() {
  const snapshot = getWellnessSnapshot();
  const currentRisk = getCrashRiskSnapshot();
  const candidates = [];

  if (snapshot.sleepToday < 7) candidates.push({ id: "sleep", text: "Log at least 7 hours of sleep today.", type: "recovery", requirement: { kind: "sleep", min: 7 } });
  if (snapshot.waterToday < snapshot.todayGoal) candidates.push({ id: "water", text: `Reach water target (${snapshot.todayGoal} glasses) today.`, type: "hydration", requirement: { kind: "water", min: snapshot.todayGoal } });
  if (!snapshot.moodToday) candidates.push({ id: "mood", text: "Log your mood at least once today.", type: "mind", requirement: { kind: "mood" } });
  if (!snapshot.gratitudeToday) candidates.push({ id: "gratitude", text: "Write one gratitude note today.", type: "mind", requirement: { kind: "gratitude", min: 1 } });
  if (snapshot.pendingTasks > 0) candidates.push({ id: "task", text: "Complete at least 1 task today.", type: "focus", requirement: { kind: "tasksCompleted", min: 1 } });
  if (currentRisk.risk >= 60) candidates.push({ id: "rescue", text: "Run one mood crash rescue today.", type: "resilience", requirement: { kind: "rescue", min: 1 } });

  candidates.push(
    { id: "challenge", text: "Complete today‚Äôs daily challenge.", type: "consistency", requirement: { kind: "challenge" } },
    { id: "water8", text: "Log at least 8 glasses of water today.", type: "hydration", requirement: { kind: "water", min: 8 } },
    { id: "tasks2", text: "Complete at least 2 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 2 } }
  );

  const uniqueById = new Map();
  candidates.forEach((item) => {
    if (!uniqueById.has(item.id)) uniqueById.set(item.id, item);
  });
  return [...uniqueById.values()];
}

function generateAdaptiveQuests() {
  const pool = getQuestCandidatePool();
  const selected = pool.slice(0, 4).map((item, index) => ({
    id: `${item.id}-${index + 1}`,
    text: item.text,
    type: item.type,
    requirement: item.requirement || null,
    completed: false
  }));

  habitQuests.length = 0;
  selected.forEach((quest) => habitQuests.push(quest));
}

function renderHabitQuestUI() {
  if (questXpEl) questXpEl.innerText = `XP ${questXp}/100`;
  if (questProgressFill) questProgressFill.style.width = `${Math.max(0, Math.min(100, questXp))}%`;
  if (questShieldEl) questShieldEl.innerText = `Streak shield: ${questShieldAvailable ? "Active" : "Inactive"}`;

  if (!questListEl) return;
  questListEl.innerHTML = "";

  if (!habitQuests.length) {
    questListEl.innerHTML = "<li class=\"quest-item\"><span class=\"quest-text\">No quests yet. Log today‚Äôs stats to generate quests.</span></li>";
    return;
  }

  habitQuests.forEach((quest, index) => {
    const item = document.createElement("li");
    item.className = "quest-item";

    const text = document.createElement("span");
    text.className = `quest-text${quest.completed ? " quest-done" : ""}`;
    text.textContent = quest.text;

    const button = document.createElement("button");
    button.textContent = quest.completed ? "Done" : "Complete";
    button.disabled = !!quest.completed;
    button.onclick = () => completeHabitQuest(index);

    item.append(text, button);
    questListEl.appendChild(item);
  });
}

async function saveHabitQuestState(userId) {
  if (!userId) return;
  try {
    await setDoc(doc(db, "users", userId, "settings", "habitQuest"), {
      dateKey: questDateKey,
      xp: questXp,
      shield: questShieldAvailable,
      quests: habitQuests,
      updatedAt: serverTimestamp()
    }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadHabitQuest(userId) {
  questDateKey = getTodayKey();

  try {
    const snap = await getDoc(doc(db, "users", userId, "settings", "habitQuest"));
    if (snap.exists()) {
      const data = snap.data();
      questXp = Number(data.xp) || 0;
      questShieldAvailable = !!data.shield;

      if (data.dateKey === questDateKey && Array.isArray(data.quests) && data.quests.length >= 4) {
        habitQuests.length = 0;
        data.quests.forEach((quest) => {
          habitQuests.push({
            id: String(quest.id || ""),
            text: String(quest.text || "Daily quest"),
            type: String(quest.type || "general"),
            requirement: quest.requirement || null,
            completed: !!quest.completed
          });
        });

        const hasUnverifiableQuest = habitQuests.some((quest) => {
          const baseId = String(quest.id || "").split("-")[0];
          return baseId === "walk" || baseId === "plan";
        });
        if (hasUnverifiableQuest) {
          generateAdaptiveQuests();
          await saveHabitQuestState(userId);
        }
      } else {
        generateAdaptiveQuests();
        await saveHabitQuestState(userId);
      }
    } else {
      questXp = 0;
      questShieldAvailable = false;
      generateAdaptiveQuests();
      await saveHabitQuestState(userId);
    }
  } catch (err) {
    notifyFirestoreError(err);
  }

  renderHabitQuestUI();
}

function getTodayCompletedTaskCount() {
  const todayKey = getTodayKey();
  return taskEntries.filter((entry) => !!entry.completed && dateToKey(entry.time) === todayKey).length;
}

function getTodayRescueCount() {
  const todayKey = getTodayKey();
  return rescueEvents.filter((entry) => dateToKey(entry.time) === todayKey).length;
}

function getTodayGratitudeCount() {
  const todayKey = getTodayKey();
  return gratitudeEntries.filter((entry) => dateToKey(entry.time) === todayKey).length;
}

function validateHabitQuestCompletion(quest) {
  const requirement = quest?.requirement || null;
  const snapshot = getWellnessSnapshot();

  if (!requirement?.kind) {
    const baseId = String(quest?.id || "").split("-")[0];
    if (baseId === "water" || baseId === "water8") {
      const min = baseId === "water8" ? 8 : snapshot.todayGoal;
      if (snapshot.waterToday < min) return { valid: false, message: `Log at least ${min} glasses first (current: ${snapshot.waterToday}).` };
      return { valid: true };
    }
    if (baseId === "sleep") {
      if (snapshot.sleepToday < 7) return { valid: false, message: `Log at least 7 hours sleep first (current: ${snapshot.sleepToday}).` };
      return { valid: true };
    }
    if (baseId === "mood") {
      if (!snapshot.moodToday) return { valid: false, message: "Log your mood first." };
      return { valid: true };
    }
    if (baseId === "gratitude") {
      const count = getTodayGratitudeCount();
      if (count < 1) return { valid: false, message: `Add a gratitude note first (current: ${count}).` };
      return { valid: true };
    }
    if (baseId === "task" || baseId === "tasks2") {
      const min = baseId === "tasks2" ? 2 : 1;
      const completed = getTodayCompletedTaskCount();
      if (completed < min) return { valid: false, message: `Complete at least ${min} task${min > 1 ? "s" : ""} first (current: ${completed}).` };
      return { valid: true };
    }
    if (baseId === "challenge") {
      if (!dailyChallengeCompleted) return { valid: false, message: "Complete today‚Äôs daily challenge first." };
      return { valid: true };
    }
    if (baseId === "rescue") {
      const rescues = getTodayRescueCount();
      if (rescues < 1) return { valid: false, message: `Run mood crash rescue first (current: ${rescues}).` };
      return { valid: true };
    }
    return { valid: false, message: "This quest cannot be verified yet. Refresh to get a measurable quest." };
  }

  if (requirement.kind === "water") {
    const min = Math.max(1, Number(requirement.min) || 1);
    if (snapshot.waterToday < min) return { valid: false, message: `Log at least ${min} glasses first (current: ${snapshot.waterToday}).` };
    return { valid: true };
  }
  if (requirement.kind === "sleep") {
    const min = Math.max(1, Number(requirement.min) || 7);
    if (snapshot.sleepToday < min) return { valid: false, message: `Log at least ${min} hours sleep first (current: ${snapshot.sleepToday}).` };
    return { valid: true };
  }
  if (requirement.kind === "mood") {
    if (!snapshot.moodToday) return { valid: false, message: "Log your mood first." };
    return { valid: true };
  }
  if (requirement.kind === "gratitude") {
    const min = Math.max(1, Number(requirement.min) || 1);
    const count = getTodayGratitudeCount();
    if (count < min) return { valid: false, message: `Add at least ${min} gratitude note${min > 1 ? "s" : ""} first (current: ${count}).` };
    return { valid: true };
  }
  if (requirement.kind === "tasksCompleted") {
    const min = Math.max(1, Number(requirement.min) || 1);
    const completed = getTodayCompletedTaskCount();
    if (completed < min) return { valid: false, message: `Complete at least ${min} task${min > 1 ? "s" : ""} first (current: ${completed}).` };
    return { valid: true };
  }
  if (requirement.kind === "challenge") {
    if (!dailyChallengeCompleted) return { valid: false, message: "Complete today‚Äôs daily challenge first." };
    return { valid: true };
  }
  if (requirement.kind === "rescue") {
    const min = Math.max(1, Number(requirement.min) || 1);
    const rescues = getTodayRescueCount();
    if (rescues < min) return { valid: false, message: `Run mood crash rescue at least ${min} time${min > 1 ? "s" : ""} first (current: ${rescues}).` };
    return { valid: true };
  }

  return { valid: false, message: "This quest requirement is not trackable yet." };
}

async function completeHabitQuest(index) {
  const user = auth.currentUser;
  if (!user) return;
  const quest = habitQuests[index];
  if (!quest || quest.completed) return;

  const validation = validateHabitQuestCompletion(quest);
  if (!validation.valid) {
    alert(`‚ùå ${validation.message}`);
    return;
  }

  quest.completed = true;
  questXp += 20;

  const allDone = habitQuests.length > 0 && habitQuests.every((entry) => entry.completed);
  if (allDone) {
    questXp += 20;
    questShieldAvailable = true;
  }

  while (questXp >= 100) questXp -= 100;

  renderHabitQuestUI();
  await saveHabitQuestState(user.uid);
  updateInsights();
}

function ensureHabitQuestCurrent() {
  const todayKey = getTodayKey();
  if (!questDateKey) {
    questDateKey = todayKey;
    if (!habitQuests.length) generateAdaptiveQuests();
    renderHabitQuestUI();
    return;
  }

  if (questDateKey !== todayKey) {
    questDateKey = todayKey;
    generateAdaptiveQuests();
    const user = auth.currentUser;
    if (user) saveHabitQuestState(user.uid);
  }

  renderHabitQuestUI();
}

function updateBurnoutRadarUI() {
  const crash = getCrashRiskSnapshot();
  const now = new Date();
  const hour = now.getHours();
  const dipStart = Math.min(23, hour + 2);
  const dipEnd = Math.min(23, hour + 6);

  const rescueLast3Days = rescueEvents.filter((entry) => {
    const time = toDateSafe(entry.time);
    if (!time) return false;
    const threshold = new Date();
    threshold.setDate(threshold.getDate() - 3);
    return time >= threshold;
  }).length;

  let forecast = Math.round(crash.risk * 0.75);
  if (rescueLast3Days >= 2) forecast += 12;
  if (sleepHistory.length > 1) {
    const recent = Number(sleepHistory[sleepHistory.length - 1]) || 0;
    const prev = Number(sleepHistory[sleepHistory.length - 2]) || 0;
    if (recent < prev - 1) forecast += 8;
  }
  forecast = Math.max(0, Math.min(100, forecast));

  const level = forecast >= 75 ? "High Risk" : forecast >= 50 ? "Moderate Risk" : "Low Risk";
  const reason =
    forecast >= 75 ? "Burnout pressure is building fast from current stress signals." :
    forecast >= 50 ? "Early fatigue markers detected; proactive recovery is recommended." :
    "Recovery trajectory is stable. Keep consistency.";

  burnoutRecoveryPlan.length = 0;
  burnoutRecoveryPlan.push(
    `At ${String(dipStart).padStart(2, "0")}:00 do a 2-minute breathing reset.`,
    `At ${String(Math.min(23, dipStart + 1)).padStart(2, "0")}:00 drink water + 5-minute stretch.`,
    `At ${String(dipEnd).padStart(2, "0")}:00 reduce workload to one small closure task.`
  );
  if (forecast >= 60) burnoutRecoveryPlan.push("Avoid back-to-back high-focus sessions without a break today.");

  if (burnoutRiskEl) burnoutRiskEl.innerText = `${forecast}/100`;
  if (burnoutWindowEl) burnoutWindowEl.innerText = `${level} ‚Ä¢ Dip window ${String(dipStart).padStart(2, "0")}:00-${String(dipEnd).padStart(2, "0")}:00`;
  if (burnoutReasonEl) burnoutReasonEl.innerText = reason;
  if (burnoutScheduleEl) burnoutScheduleEl.innerHTML = burnoutRecoveryPlan.map((item) => `<li>${item}</li>`).join("");
}

async function applyRecoverySchedule() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  if (!burnoutRecoveryPlan.length) updateBurnoutRadarUI();

  try {
    const remindersToSet = [20, 60, 120];
    for (let index = 0; index < remindersToSet.length; index += 1) {
      const minutes = remindersToSet[index];
      const text = `Recovery step ${index + 1}: ${burnoutRecoveryPlan[index] || "Take a reset break."}`;
      const targetAtMs = Date.now() + minutes * 60000;
      const ref = await addDoc(collection(db, "users", user.uid, "reminders"), {
        text,
        minutes,
        targetAtMs,
        createdAt: serverTimestamp()
      });
      renderReminder({ id: ref.id, text, minutes, targetAtMs });
    }
    alert("‚úÖ Recovery schedule applied with reminders.");
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function pickChallengeForDate(dateKey) {
  const sum = [...dateKey].reduce((total, char) => total + char.charCodeAt(0), 0);
  return dailyChallenges[sum % dailyChallenges.length];
}

function queueInsightsPersist(payload) {
  if (insightsPersistTimer) clearTimeout(insightsPersistTimer);
  insightsPersistTimer = setTimeout(async () => {
    const user = auth.currentUser;
    if (!user) return;
    try {
      await setDoc(doc(db, "users", user.uid, "insights", "current"), {
        ...payload,
        updatedAt: serverTimestamp()
      }, { merge: true });
    } catch (err) {
      notifyFirestoreError(err);
    }
  }, 350);
}

function getTodayKey() {
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: userTimeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  });
  return formatter.format(new Date());
}

function getTodayKeyGMT() {
  return new Date().toISOString().slice(0, 10);
}

async function saveAiUsage(userId) {
  try {
    await setDoc(doc(db, "users", userId, "settings", "aiUsage"), {
      dateKeyGMT: aiUsageDateKeyGMT,
      count: aiUsageCount,
      updatedAt: serverTimestamp()
    }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadAiUsage(userId) {
  aiUsageDateKeyGMT = getTodayKeyGMT();
  aiUsageCount = 0;

  try {
    const snapshot = await getDoc(doc(db, "users", userId, "settings", "aiUsage"));
    if (snapshot.exists()) {
      const data = snapshot.data();
      if (data.dateKeyGMT === aiUsageDateKeyGMT) {
        aiUsageCount = Number(data.count) || 0;
      } else {
        aiUsageCount = 0;
        await saveAiUsage(userId);
      }
    } else {
      await saveAiUsage(userId);
    }
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function ensureAiUsageCurrent(userId) {
  const todayKeyGMT = getTodayKeyGMT();
  if (aiUsageDateKeyGMT !== todayKeyGMT) {
    aiUsageDateKeyGMT = todayKeyGMT;
    aiUsageCount = 0;
    await saveAiUsage(userId);
  }
}

function startDailyChallengeWatcher() {
  if (challengeWatcherInterval) clearInterval(challengeWatcherInterval);
  challengeWatcherInterval = setInterval(async () => {
    const user = auth.currentUser;
    if (!user) return;
    const todayKey = getTodayKey();
    if (todayKey !== currentChallengeDateKey) {
      await loadDailyChallenge(user.uid);
    }
  }, 30000);
}

function stopDailyChallengeWatcher() {
  if (challengeWatcherInterval) {
    clearInterval(challengeWatcherInterval);
    challengeWatcherInterval = null;
  }
}

function clearWaterGoalResetSchedule() {
  if (waterGoalResetTimeoutId) {
    clearTimeout(waterGoalResetTimeoutId);
    waterGoalResetTimeoutId = null;
  }
}

function getMillisecondsUntilNextMidnight() {
  const now = new Date();
  const nextMidnight = new Date(now);
  nextMidnight.setHours(24, 0, 0, 0);
  return Math.max(1, nextMidnight.getTime() - now.getTime());
}

function scheduleWaterGoalReset(userId) {
  clearWaterGoalResetSchedule();

  const runReset = async () => {
    const activeUser = auth.currentUser;
    if (!activeUser || activeUser.uid !== userId) {
      scheduleWaterGoalReset(userId);
      return;
    }

    waterGoal = 0;
    waterGoalInput.value = "";
    updateWaterProgress();

    try {
      await setDoc(doc(db, "users", userId, "settings", "water"), {
        goal: 0,
        goalDateKey: getTodayKey()
      }, { merge: true });
    } catch (err) {
      notifyFirestoreError(err);
    }

    scheduleWaterGoalReset(userId);
  };

  waterGoalResetTimeoutId = setTimeout(runReset, getMillisecondsUntilNextMidnight());
}

function updateWellnessScore() {
  const todayKey = getTodayKey();

  const waterToday = waterHistory.reduce((sum, value, index) => {
    const dateKey = dateToKey(waterDates[index]);
    return dateKey === todayKey ? sum + value : sum;
  }, 0);
  const effectiveWaterGoal = waterGoal > 0 ? waterGoal : 8;
  const waterRatio = Math.min(1, waterToday / effectiveWaterGoal);
  const waterPoints = Math.round(waterRatio * 30);

  const sleepToday = sleepHistory.reduce((lastValue, value, index) => {
    const dateKey = dateToKey(sleepDates[index]);
    return dateKey === todayKey ? value : lastValue;
  }, 0);
  const sleepRatio = Math.min(1, sleepToday / 8);
  const sleepPoints = Math.round(sleepRatio * 25);

  const moodToday = moodHistory.reduce((lastMood, value, index) => {
    const dateKey = dateToKey(moodDates[index]);
    return dateKey === todayKey ? value : lastMood;
  }, "");
  const moodFactor = moodToday.includes("üòä") ? 1 : moodToday.includes("üòê") ? 0.65 : moodToday.includes("üòî") ? 0.3 : 0;
  const moodPoints = Math.round(moodFactor * 20);

  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const taskRatio = totalTasks ? doneTasks / totalTasks : 0;
  const taskPoints = Math.round(taskRatio * 15);

  const hasGratitudeToday = gratitudeEntries.some((entry) => dateToKey(entry.time) === todayKey);
  const gratitudePoints = hasGratitudeToday ? 10 : 0;
  const challengePoints = dailyChallengeCompleted ? 10 : 0;

  const totalScore = Math.max(0, Math.min(100, waterPoints + sleepPoints + moodPoints + taskPoints + gratitudePoints + challengePoints));

  wellnessScoreEl.innerText = `${totalScore}/100`;

  let status = "Needs Focus";
  if (totalScore >= 80) status = "Excellent";
  else if (totalScore >= 60) status = "Good";
  wellnessStatusEl.innerText = status;

  const actions = [];
  if (waterRatio < 1) {
    const remaining = Math.max(0, effectiveWaterGoal - waterToday);
    actions.push(`Drink ${remaining} more glass${remaining === 1 ? "" : "es"} to hit your goal.`);
  }
  if (sleepToday < 7) actions.push("Aim for at least 7‚Äì8 hours of sleep tonight.");
  if (!moodToday) actions.push("Log your mood for today.");
  else if (moodToday.includes("üòî")) actions.push("Take a 10-minute breathing or walk break.");
  if (taskRatio < 0.7) actions.push("Complete one pending task to boost productivity.");
  if (!hasGratitudeToday) actions.push("Write one gratitude note before the day ends.");
  if (!dailyChallengeCompleted) actions.push("Complete today‚Äôs daily challenge for an extra score boost.");

  while (actions.length < 3) actions.push("Keep your current streak alive with one small check-in.");
  wellnessActionsEl.innerHTML = actions.slice(0, 3).map((item) => `<li>${item}</li>`).join("");
}

function getCrashRiskSnapshot() {
  const todayKey = getTodayKey();

  const waterToday = waterHistory.reduce((sum, value, index) => {
    const dateKey = dateToKey(waterDates[index]);
    return dateKey === todayKey ? sum + value : sum;
  }, 0);
  const effectiveWaterGoal = waterGoal > 0 ? waterGoal : 8;
  const waterRatio = Math.min(1, waterToday / effectiveWaterGoal);

  const sleepToday = sleepHistory.reduce((lastValue, value, index) => {
    const dateKey = dateToKey(sleepDates[index]);
    return dateKey === todayKey ? value : lastValue;
  }, 0);

  const moodToday = moodHistory.reduce((lastMood, value, index) => {
    const dateKey = dateToKey(moodDates[index]);
    return dateKey === todayKey ? value : lastMood;
  }, "");

  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const pendingRatio = totalTasks ? Math.max(0, (totalTasks - doneTasks) / totalTasks) : 0;
  const gratitudeToday = gratitudeEntries.some((entry) => dateToKey(entry.time) === todayKey);

  let risk = 0;
  const reasons = [];

  if (!sleepToday) {
    risk += 22;
    reasons.push("No sleep entry logged today");
  } else if (sleepToday < 6) {
    risk += 30;
    reasons.push("Very low sleep");
  } else if (sleepToday < 7) {
    risk += 16;
    reasons.push("Sleep slightly below recovery zone");
  }

  const hydrationRisk = Math.round((1 - waterRatio) * 25);
  risk += hydrationRisk;
  if (hydrationRisk >= 10) reasons.push("Hydration below target");

  if (!moodToday) {
    risk += 14;
    reasons.push("Mood not logged yet");
  } else if (moodToday.includes("üòî")) {
    risk += 24;
    reasons.push("Low mood detected");
  } else if (moodToday.includes("üòê")) {
    risk += 10;
  }

  const taskRisk = Math.round(pendingRatio * 20);
  risk += taskRisk;
  if (taskRisk >= 10) reasons.push("Too many pending tasks");

  if (!gratitudeToday) risk += 6;
  if (!dailyChallengeCompleted) risk += 4;

  const wellnessScore = Number((wellnessScoreEl?.innerText || "0/100").split("/")[0]) || 0;
  if (wellnessScore < 50) {
    risk += 10;
    reasons.push("Wellness score currently low");
  }

  risk = Math.max(0, Math.min(100, risk));
  const level = risk >= 70 ? "High Risk" : risk >= 45 ? "Medium Risk" : "Low Risk";

  return {
    risk,
    level,
    reasons,
    waterToday,
    sleepToday,
    wellnessScore
  };
}

function updateCrashPreventionUI() {
  if (!crashRiskValue || !crashRiskLevel || !crashRiskReason || !crashAlertBanner || !crashBannerText) return;

  const snapshot = getCrashRiskSnapshot();
  crashRiskValue.innerText = `${snapshot.risk}/100`;
  crashRiskLevel.innerText = snapshot.level;
  if (crashRiskFill) crashRiskFill.style.width = `${snapshot.risk}%`;
  crashRiskReason.innerText = snapshot.reasons[0] || "Keep your streaks active to maintain resilience.";

  const shortReason = snapshot.reasons.slice(0, 2).join(" ‚Ä¢ ") || "Stay consistent with your health basics.";
  if (snapshot.risk >= 65) {
    crashAlertBanner.style.display = "block";
    crashBannerText.innerText = `${snapshot.level}: ${shortReason}`;
  } else {
    crashAlertBanner.style.display = "none";
    crashBannerText.innerText = "Your dip risk is elevated right now.";
  }
}

async function runCrashRescueFlow(options = {}) {
  const showAlert = options.showAlert !== false;
  const user = auth.currentUser;
  if (!user) {
    if (showAlert) alert("Please sign in first.");
    return { ok: false, message: "Please sign in first." };
  }

  const snapshot = getCrashRiskSnapshot();
  const steps = [
    "Do 6 breathing rounds (inhale 4s ‚Ä¢ hold 4s ‚Ä¢ exhale 6s).",
    "Drink 1 glass of water now.",
    "Start one 10-minute micro-task.",
    "Check in after 20 minutes and log your mood again."
  ];

  if (crashRescuePlan) {
    crashRescuePlan.innerHTML = steps.map((step) => `<li>${step}</li>`).join("");
  }

  try {
    const reminderLabel = `Rescue check-in (${snapshot.level})`;
    const targetAtMs = Date.now() + (20 * 60 * 1000);
    const ref = await addDoc(collection(db, "users", user.uid, "reminders"), {
      text: reminderLabel,
      minutes: 20,
      targetAtMs,
      createdAt: serverTimestamp()
    });
    renderReminder({ id: ref.id, text: reminderLabel, minutes: 20, targetAtMs });

    const rescueRef = await addDoc(collection(db, "users", user.uid, "rescueEvents"), {
      level: snapshot.level,
      reason: (snapshot.reasons && snapshot.reasons[0]) || "",
      time: serverTimestamp()
    });
    rescueEvents.push({ id: rescueRef.id, time: new Date(), level: snapshot.level });

    updateCrashPreventionUI();
    updateWeeklyReview();
    if (showAlert) {
      alert("‚úÖ Rescue protocol started. I set a 20-minute recovery reminder.");
    }
    return {
      ok: true,
      level: snapshot.level,
      reason: (snapshot.reasons && snapshot.reasons[0]) || "General resilience support"
    };
  } catch (err) {
    notifyFirestoreError(err);
    return { ok: false, message: "Could not start rescue right now." };
  }
}

function updateInsights() {
  ensureHabitQuestCurrent();
  const moodStreak = calcStreak(moodDates);
  const waterStreak = calcStreak(waterDates);
  const gratitudeStreak = calcStreak(gratitudeEntries.map((entry) => entry.time));
  const challengeStreak = calcStreak(challengeDates);

  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const taskCompletion = totalTasks ? Math.round((doneTasks / totalTasks) * 100) : 0;

  const avgSleep = sleepHistory.length
    ? sleepHistory.reduce((a, b) => a + b, 0) / sleepHistory.length
    : 0;
  const sleepPercent = Math.round(Math.min(100, (avgSleep / 8) * 100));

  const waterSum = waterHistory.reduce((a, b) => a + b, 0);
  const waterPercent = waterGoal > 0 ? Math.round((waterSum / waterGoal) * 100) : 0;

  if (insightTaskTopLabel) {
    insightTaskTopLabel.innerText = `Tasks completed ${doneTasks}/${totalTasks}`;
  }
  if (insightTaskTopBar) {
    setInsightBar(insightTaskTopBar, taskCompletion);
  }

  const taskSeries = getInsightSeries("tasks");
  const sleepSeries = getInsightSeries("sleep");
  const waterSeries = getInsightSeries("water");

  const metricViews = [
    {
      title: "Productivity Trend",
      label: `Last 7 days completion trend ‚Ä¢ ${taskCompletion}% current`,
      percent: taskCompletion,
      series: taskSeries
    },
    {
      title: "Sleep Trend",
      label: `Last 7 days sleep trend ‚Ä¢ ${avgSleep.toFixed(1)} hrs avg`,
      percent: sleepPercent,
      series: sleepSeries
    },
    {
      title: "Water Intake Trend",
      label: `Last 7 days hydration trend ‚Ä¢ goal progress ${waterPercent}%`,
      percent: waterPercent,
      series: waterSeries
    }
  ];

  if (insightMetricIndex < 0 || insightMetricIndex >= metricViews.length) insightMetricIndex = 0;
  renderInsightMetricView(metricViews[insightMetricIndex]);

  updateWellnessScore();
  updateCrashPreventionUI();
  updateBurnoutRadarUI();
  updateWeeklyReview();

  const currentScore = Number((wellnessScoreEl?.innerText || "0/100").split("/")[0]) || 0;
  queueInsightsPersist({
    moodStreak,
    waterStreak,
    gratitudeStreak,
    challengeStreak,
    taskCompletion,
    avgSleep: Number(avgSleep.toFixed(1)),
    waterGoalProgress: waterPercent,
    wellnessScore: currentScore,
    wellnessStatus: wellnessStatusEl.innerText || "Needs Focus",
    dailyChallengeCompleted,
    dailyChallenge: currentChallengeText || ""
  });
}

// AI Companion
function escapeHtml(text) {
  return text
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function getUserName(user) {
  if (user?.displayName && user.displayName.trim()) return user.displayName.trim();
  if (user?.email) return user.email.split("@")[0];
  return "there";
}

function rememberPrompt(promptText) {
  if (!promptText) return;
  aiRecentPrompts.push(promptText);
  if (aiRecentPrompts.length > 6) aiRecentPrompts.shift();
}

function pushTopicHistory(topic) {
  if (!topic) return;
  aiSessionState.topicHistory.push(topic);
  if (aiSessionState.topicHistory.length > 12) aiSessionState.topicHistory.shift();
}

function tokenizeText(text) {
  return String(text || "")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .split(/\s+/)
    .filter(Boolean);
}

function jaccardSimilarity(a, b) {
  const aSet = new Set(tokenizeText(a));
  const bSet = new Set(tokenizeText(b));
  if (!aSet.size || !bSet.size) return 0;
  let intersection = 0;
  aSet.forEach((token) => {
    if (bSet.has(token)) intersection += 1;
  });
  const union = new Set([...aSet, ...bSet]).size;
  return union ? intersection / union : 0;
}

function rememberUserFact(type, value) {
  if (!value) return;

  if (type === "name") {
    aiSessionState.userFacts.name = value.trim();
    return;
  }

  if (type === "goal") {
    aiSessionState.userFacts.goal = value.trim();
    return;
  }

  if (type === "likes") {
    const normalized = value.trim().toLowerCase();
    if (!normalized) return;
    if (!aiSessionState.userFacts.likes.includes(normalized)) {
      aiSessionState.userFacts.likes.push(normalized);
      if (aiSessionState.userFacts.likes.length > 8) aiSessionState.userFacts.likes.shift();
    }
    return;
  }

  if (type === "dislikes") {
    const normalized = value.trim().toLowerCase();
    if (!normalized) return;
    if (!aiSessionState.userFacts.dislikes.includes(normalized)) {
      aiSessionState.userFacts.dislikes.push(normalized);
      if (aiSessionState.userFacts.dislikes.length > 8) aiSessionState.userFacts.dislikes.shift();
    }
  }
}

function learnFromUserInput(input) {
  const text = String(input || "").trim();
  if (!text) return;

  const nameMatch = text.match(/(?:my name is|i am|i'm)\s+([a-z][a-z\s'-]{1,24})/i);
  if (nameMatch?.[1]) {
    rememberUserFact("name", nameMatch[1]);
  }

  const goalMatch = text.match(/(?:my goal is|i want to|i need to|i plan to)\s+(.+)/i);
  if (goalMatch?.[1] && goalMatch[1].length < 120) {
    rememberUserFact("goal", goalMatch[1]);
  }

  const likeMatch = text.match(/(?:i like|i love)\s+(.+)/i);
  if (likeMatch?.[1] && likeMatch[1].length < 80) {
    rememberUserFact("likes", likeMatch[1]);
  }

  const dislikeMatch = text.match(/(?:i dislike|i hate|i don't like)\s+(.+)/i);
  if (dislikeMatch?.[1] && dislikeMatch[1].length < 80) {
    rememberUserFact("dislikes", dislikeMatch[1]);
  }
}

function buildUserContextLabel(defaultName) {
  const memoryName = aiSessionState.userFacts.name;
  if (memoryName) return memoryName;
  return defaultName;
}

function calculateExpressionFromText(text) {
  const match = text.match(/(?:calculate|solve|what is|what's)\s*([\d+\-*/().%\s]+)/i);
  if (!match || !match[1]) return null;
  const expression = match[1].trim();
  if (!/^[\d+\-*/().%\s]+$/.test(expression)) return null;

  try {
    const result = Function(`"use strict"; return (${expression});`)();
    if (typeof result !== "number" || !Number.isFinite(result)) return null;
    return { expression, result };
  } catch (_) {
    return null;
  }
}

function detectEmotionFromText(text) {
  if (/\b(stress|anxious|anxiety|overwhelm|panic|sad|depressed|down|tired|burnout)\b/.test(text)) return "low";
  if (/\b(good|great|awesome|amazing|happy|motivated|energized|fine)\b/.test(text)) return "positive";
  return "neutral";
}

function classifyIntent(input) {
  const msg = String(input || "").toLowerCase();
  const intents = [
    { key: "greeting", score: /\b(hi|hello|hey|yo|hola)\b/.test(msg) ? 0.95 : 0 },
    { key: "smalltalk-health", score: /\b(how are you|how are u|how's it going|how you doing|how r you)\b/.test(msg) ? 0.98 : 0 },
    { key: "smalltalk-activity", score: /\b(what are you doing|what are u doing|wyd|what you doing)\b/.test(msg) ? 0.97 : 0 },
    { key: "identity", score: /who are you|what are you|your name|are you ai|are you real/.test(msg) ? 0.94 : 0 },
    { key: "analysis", score: /analyze|analysis|report|conclude|insight|summary|score/.test(msg) ? 0.93 : 0 },
    { key: "plan", score: /plan|routine|today|schedule|what should i do/.test(msg) ? 0.92 : 0 },
    { key: "stress", score: /stress|anxious|anxiety|overwhelm|panic|sad|depressed|down/.test(msg) ? 0.91 : 0 },
    { key: "sleep", score: /sleep|tired|exhausted|fatigue|insomnia/.test(msg) ? 0.9 : 0 },
    { key: "water", score: /water|hydrate|hydration|thirsty/.test(msg) ? 0.89 : 0 },
    { key: "productivity", score: /task|focus|productivity|procrastin|work|study/.test(msg) ? 0.88 : 0 },
    { key: "gratitude", score: /gratitude|thankful|grateful/.test(msg) ? 0.87 : 0 },
    { key: "capabilities", score: /help|what can you do|features|assist|commands/.test(msg) ? 0.86 : 0 },
    { key: "followup", score: /\b(and then|then what|what next|next step|continue|go deeper)\b/.test(msg) ? 0.85 : 0 },
    { key: "joke", score: /\b(joke|make me laugh|funny)\b/.test(msg) ? 0.84 : 0 },
    { key: "thanks", score: /\b(thanks|thank you|thx|ty)\b/.test(msg) ? 0.83 : 0 },
    { key: "bye", score: /\b(bye|goodbye|see you|cya|gn|good night)\b/.test(msg) ? 0.82 : 0 }
  ];

  const sorted = intents.sort((a, b) => b.score - a.score);
  const best = sorted[0];
  if (!best || best.score < 0.5) return { key: "fallback", confidence: 0 };
  return { key: best.key, confidence: best.score };
}

function buildAdaptiveTone(userEmotion, turnCount) {
  if (userEmotion === "low") return "supportive";
  if (turnCount > 8) return "compact";
  return "energetic";
}

function getAiModePreset() {
  return AI_MODE_PRESETS[aiReasoningMode] || AI_MODE_PRESETS.balanced;
}

function setAiMode(nextMode) {
  const normalized = String(nextMode || "").toLowerCase().trim();
  if (!AI_MODE_PRESETS[normalized]) return false;
  aiReasoningMode = normalized;
  return true;
}

function parseModeFromInput(input) {
  const match = String(input || "").toLowerCase().match(/(?:mode|style)\s*(?:to)?\s*(ultra|balanced|coach|strict|creative)/);
  return match?.[1] || null;
}

function getMemorySummary() {
  const { name, goal, likes, dislikes } = aiSessionState.userFacts;
  const lines = [];
  if (name) lines.push(`Name: ${name}`);
  if (goal) lines.push(`Goal: ${goal}`);
  if (likes.length) lines.push(`Likes: ${likes.slice(-3).join(", ")}`);
  if (dislikes.length) lines.push(`Dislikes: ${dislikes.slice(-3).join(", ")}`);
  if (!lines.length) return "No remembered user facts yet.";
  return lines.join(" | ");
}

function parseCompareRequest(input) {
  const text = String(input || "").trim();
  const versusMatch = text.match(/(.+?)\s+(?:vs|versus|or)\s+(.+)/i);
  if (!versusMatch) return null;
  const left = versusMatch[1].replace(/^(compare|difference between|choose between)\s+/i, "").trim();
  const right = versusMatch[2].trim();
  if (!left || !right) return null;
  if (left.length > 60 || right.length > 60) return null;
  return { left, right };
}

function buildComparisonResponse(left, right, snapshot) {
  const remainingWater = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
  return {
    summary: `If your priority is fast execution today, choose the option with lower setup friction right now.`,
    prosLeft: [
      `${left} may be easier to start immediately.`,
      `${left} can create quicker momentum if you‚Äôre low on energy.`,
      `${left} likely has lower cognitive overhead.`
    ],
    prosRight: [
      `${right} may provide stronger long-term upside.`,
      `${right} can improve skill depth if sustained consistently.`,
      `${right} might align better if your energy is high right now.`
    ],
    decisionRule: `Decision rule: pick the option you can start in <10 minutes, then hydrate ${remainingWater > 0 ? `(${remainingWater} glass(es) left today)` : "and maintain hydration"}.`
  };
}

function buildModeAwarePrefix(tone) {
  const preset = getAiModePreset();
  if (preset.style === "strict") return "Direct answer: ";
  if (preset.style === "coach") return "Coach mode: ";
  if (preset.style === "creative") return "Creative mode: ";
  if (preset.style === "ultra") return "Focused mode: ";
  if (tone === "supportive") return "I‚Äôm with you. ";
  if (tone === "compact") return "Quick answer: ";
  return "Let‚Äôs go: ";
}

function buildUltraFallback(snapshot, name) {
  const plan = buildDeepPlan(snapshot);
  const goalLine = aiSessionState.userFacts.goal
    ? `<br>üéØ Goal alignment: <i>${escapeHtml(aiSessionState.userFacts.goal)}</i>`
    : "";
  return `üß† <b>Strategic Response</b><br>Hey ${escapeHtml(name)}, here is your best move stack now:<br>1) ${plan[0]}<br>2) ${plan[1]}<br>3) ${plan[2]}<br>4) ${plan[3]}${goalLine}<br><br>Reply with <i>execute step 1</i>, <i>mode strict</i>, or ask a direct comparison like <i>A vs B</i>.`;
}

function buildKnowledgeAnswer(input) {
  const text = String(input || "");
  const knowledge = [
    {
      topic: "sleep",
      triggers: ["sleep", "insomnia", "tired", "fatigue", "bed"],
      answer: "For better sleep: keep a fixed sleep window, reduce bright light 60 minutes before bed, avoid caffeine after afternoon, and use a short wind-down ritual (breathing + low-stimulation activity)."
    },
    {
      topic: "focus",
      triggers: ["focus", "procrastination", "deep work", "study", "work"],
      answer: "Use the 25-5 cycle: define one outcome, remove distractions, sprint 25 minutes, then 5-minute reset. Repeat 2-3 rounds before checking messages."
    },
    {
      topic: "stress",
      triggers: ["stress", "anxiety", "panic", "overwhelmed"],
      answer: "When stressed, reduce physiological load first: long exhale breathing, hydration, and one very small actionable step. Momentum usually lowers anxiety faster than overthinking."
    },
    {
      topic: "hydration",
      triggers: ["water", "hydration", "dehydrated", "thirsty"],
      answer: "Hydration works best with timing: one glass after waking, one with each meal, and one before evening wind-down. Small consistent doses beat large late intake."
    },
    {
      topic: "habits",
      triggers: ["habit", "consistency", "discipline", "routine"],
      answer: "Build habits with tiny minimums: define a trigger, make the action small, and track daily completion. Consistency compounds faster than intensity."
    }
  ];

  const scored = knowledge
    .map((entry) => {
      const triggerScore = entry.triggers.reduce((score, trigger) => score + (text.toLowerCase().includes(trigger) ? 1 : 0), 0);
      const similarity = jaccardSimilarity(text, `${entry.topic} ${entry.triggers.join(" ")}`);
      return { ...entry, score: triggerScore + similarity };
    })
    .sort((a, b) => b.score - a.score);

  if (!scored[0] || scored[0].score < 0.5) return null;
  pushTopicHistory(scored[0].topic);
  return scored[0].answer;
}

function buildActionCoaching(snapshot) {
  const actions = [];
  if (snapshot.pendingTasks > 0) actions.push("Pick 1 pending task and do a focused 25-minute sprint.");
  if (snapshot.waterToday < snapshot.todayGoal) {
    const left = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
    actions.push(`Drink ${left} more glass${left === 1 ? "" : "es"} of water.`);
  }
  if (snapshot.sleepToday < 7) actions.push("Plan an earlier wind-down to target 7‚Äì8 hours sleep.");
  if (!snapshot.gratitudeToday) actions.push("Write one gratitude line before bed.");
  if (!snapshot.moodToday) actions.push("Log your mood to improve your daily insights.");
  while (actions.length < 3) actions.push("Keep momentum with one small healthy action right now.");
  return actions.slice(0, 3);
}

function buildDeepPlan(snapshot) {
  const waterLeft = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
  return [
    snapshot.pendingTasks > 0
      ? "Block 1 (0-25 min): close one pending task with single-task focus."
      : "Block 1 (0-25 min): define and start one meaningful task.",
    waterLeft > 0
      ? `Block 2 (25-35 min): drink ${Math.max(1, waterLeft)} glass(es) and reset posture/breathing.`
      : "Block 2 (25-35 min): movement + posture reset.",
    snapshot.sleepToday < 7
      ? "Block 3 (35-50 min): finish priority work and set a wind-down reminder."
      : "Block 3 (35-50 min): second deep-focus sprint.",
    snapshot.gratitudeToday
      ? "Block 4 (50-60 min): quick reflection and tomorrow‚Äôs first action."
      : "Block 4 (50-60 min): write one gratitude line and set tomorrow‚Äôs first action."
  ];
}

function getTodayWater() {
  const todayKey = getTodayKey();
  return waterHistory.reduce((sum, value, index) => {
    const dateKey = dateToKey(waterDates[index]);
    return dateKey === todayKey ? sum + value : sum;
  }, 0);
}

function getTodayMood() {
  const todayKey = getTodayKey();
  return moodHistory.reduce((lastMood, value, index) => {
    const dateKey = dateToKey(moodDates[index]);
    return dateKey === todayKey ? value : lastMood;
  }, "");
}

function getTodaySleep() {
  const todayKey = getTodayKey();
  return sleepHistory.reduce((lastSleep, value, index) => {
    const dateKey = dateToKey(sleepDates[index]);
    return dateKey === todayKey ? value : lastSleep;
  }, 0);
}

function getWellnessSnapshot() {
  const waterToday = getTodayWater();
  const todayGoal = waterGoal > 0 ? waterGoal : 8;
  const moodToday = getTodayMood();
  const sleepToday = getTodaySleep();
  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const pendingTasks = taskEntries.filter((entry) => !entry.completed).length;
  const gratitudeToday = gratitudeEntries.some((entry) => dateToKey(entry.time) === getTodayKey());
  const score = Number((wellnessScoreEl?.innerText || "0/100").split("/")[0]) || 0;

  return {
    waterToday,
    todayGoal,
    moodToday,
    sleepToday,
    totalTasks,
    doneTasks,
    pendingTasks,
    gratitudeToday,
    score
  };
}

async function tryAiAction(input, user) {
  const msg = input.trim();
  const lower = msg.toLowerCase();

  const requestedMode = parseModeFromInput(msg);
  if (requestedMode) {
    const changed = setAiMode(requestedMode);
    if (changed) {
      return `‚úÖ Response style updated.`;
    }
    return "‚ÑπÔ∏è Unknown mode. Use: balanced, coach, strict, creative.";
  }

  const rememberMatch = msg.match(/^remember\s+(?:that\s+)?(.+)/i);
  if (rememberMatch?.[1]) {
    learnFromUserInput(rememberMatch[1]);
    return `‚úÖ Saved memory: ${escapeHtml(rememberMatch[1].trim())}`;
  }

  if (/^(?:what do you remember|recall memory|memory|show memory)$/i.test(msg)) {
    return `üß† Memory: ${escapeHtml(getMemorySummary())}`;
  }

  if (/^(start\s+reset|reset\s+me|calm\s+me)$/i.test(msg)) {
    return "‚úÖ 60-second reset: inhale 4s ‚Üí hold 4s ‚Üí exhale 6s for 6 rounds, drink a glass of water, then do one 10-minute micro-task.";
  }

  if (/^(?:run|start|do|begin|trigger)\s+(?:the\s+)?(?:mood\s+)?(?:crash\s+)?rescue$/i.test(msg)) {
    const rescueResult = await runCrashRescueFlow({ showAlert: false });
    if (!rescueResult?.ok) {
      return `‚ÑπÔ∏è ${rescueResult?.message || "Could not start rescue right now."}`;
    }
    return `üõü Mood crash rescue started (${rescueResult.level}). I added a 20-minute recovery reminder. Focus now: ${rescueResult.reason}.`;
  }

  const taskMatch = msg.match(/^(add|create)\s+(a\s+)?task\s*[:\-]?\s*(.+)$/i);
  if (taskMatch && taskMatch[3]) {
    task.value = taskMatch[3].trim();
    await addTask();
    return `‚úÖ Added task: ${taskMatch[3].trim()}`;
  }

  const waterGoalMatch = lower.match(/(?:set|update)\s+(?:my\s+)?water\s+goal\s+(?:to\s+)?(\d+)/i);
  if (waterGoalMatch) {
    waterGoalInput.value = String(Number(waterGoalMatch[1]) || 0);
    await setWaterGoal();
    return `‚úÖ Water goal updated to ${waterGoalInput.value} glasses.`;
  }

  const waterLogMatch = lower.match(/(?:log|add|track)\s+(\d+)\s*(?:glass|glasses)\s*(?:of\s+water)?/i);
  if (waterLogMatch) {
    waterInput.value = String(Number(waterLogMatch[1]) || 0);
    await saveWater();
    return `‚úÖ Logged ${waterInput.value || waterLogMatch[1]} glasses of water.`;
  }

  const sleepMatch = lower.match(/(?:log|save|track)\s+sleep\s+(?:for\s+)?(\d+(?:\.\d+)?)\s*(?:h|hr|hrs|hour|hours)?/i);
  if (sleepMatch) {
    sleepInput.value = sleepMatch[1];
    await saveSleep();
    return `‚úÖ Sleep logged: ${sleepMatch[1]} hours.`;
  }

  const moodMatch = lower.match(/(?:log|set|save)\s+mood\s+(happy|neutral|nuetral|low|sad)/i);
  if (moodMatch) {
    const map = { happy: "üòä Happy", neutral: "üòê Neutral", nuetral: "üòê Neutral", low: "üòî Low", sad: "üòî Low" };
    mood.value = map[moodMatch[1]] || mood.value;
    await saveMood();
    return `‚úÖ Mood logged: ${mood.value}`;
  }

  const gratitudeMatch = msg.match(/^(?:add|log|save)\s+gratitude\s*[:\-]?\s*(.+)$/i);
  if (gratitudeMatch && gratitudeMatch[1]) {
    gratitudeInput.value = gratitudeMatch[1].trim();
    await saveGratitude();
    return `‚úÖ Gratitude saved.`;
  }

  const reminderMatch = msg.match(/^remind\s+me\s+to\s+(.+)\s+in\s+(\d+)\s*(m|min|mins|minute|minutes)$/i);
  if (reminderMatch) {
    reminderText.value = reminderMatch[1].trim();
    reminderMinutes.value = String(Number(reminderMatch[2]) || 0);
    addReminder();
    return `‚úÖ Reminder set: ${reminderMatch[1].trim()} in ${reminderMatch[2]} min.`;
  }

  const reminderDeleteMatch = msg.match(/^(?:delete|remove|cancel|clear)\s+(?:the\s+)?reminder\b(.*)$/i);
  if (reminderDeleteMatch && user?.uid) {
    const rawQuery = (reminderDeleteMatch[1] || "")
      .replace(/^\s*(?:for|about|named|:)\s*/i, "")
      .trim();

    const result = await deleteReminderFromAi(user.uid, rawQuery);
    if (result.ok) {
      const label = result.entry?.text || "selected reminder";
      return `‚úÖ Deleted reminder: ${label}`;
    }
    return `‚ÑπÔ∏è ${result.message}`;
  }

  if (/^(?:list|show|view)\s+reminders$/i.test(msg) && user?.uid) {
    try {
      const snapshot = await getDocs(collection(db, "users", user.uid, "reminders"));
      const items = snapshot.docs
        .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
        .sort((a, b) => (Number(a.targetAtMs) || 0) - (Number(b.targetAtMs) || 0));

      if (!items.length) return "‚ÑπÔ∏è You have no reminders right now.";

      const lines = items.slice(0, 8).map((entry, index) => `${index + 1}) ${entry.text || "Reminder"}`);
      return `‚è∞ Reminders:<br>${lines.map((line) => `‚Ä¢ ${escapeHtml(line)}`).join("<br>")}`;
    } catch (err) {
      notifyFirestoreError(err);
      return "‚ÑπÔ∏è Could not load reminders right now.";
    }
  }

  if (/^(?:clear|delete|remove)\s+all\s+reminders$/i.test(msg) && user?.uid) {
    try {
      const snapshot = await getDocs(collection(db, "users", user.uid, "reminders"));
      await Promise.all(snapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
      clearAllReminderTimers();
      reminders.innerHTML = "";
      return "‚úÖ Cleared all reminders.";
    } catch (err) {
      notifyFirestoreError(err);
      return "‚ÑπÔ∏è Could not clear reminders right now.";
    }
  }

  return null;
}

async function buildSmartAiResponse(input, user) {
  const actionResult = await tryAiAction(input, user);
  if (actionResult) {
    return {
      response: `${actionResult}<br>ü§ñ I can also run: <i>add task ..., set water goal 8, log mood sad, log sleep 7, remind me to ... in 20 min, list reminders, delete reminder 1</i>.`,
      isHtml: true
    };
  }

  const msg = input.toLowerCase();
  const baseName = getUserName(user);
  learnFromUserInput(input);
  const name = buildUserContextLabel(baseName);
  const hour = new Date().getHours();
  const greeting = hour < 12 ? "Good morning" : hour < 18 ? "Good afternoon" : "Good evening";
  const snapshot = getWellnessSnapshot();
  aiSessionState.lastSnapshot = snapshot;
  const recentContext = aiRecentPrompts.slice(-3).join(" ‚Ä¢ ");
  const mathResult = calculateExpressionFromText(input);
  const emotion = detectEmotionFromText(msg);
  const intent = classifyIntent(input);
  const tone = buildAdaptiveTone(emotion, aiSessionState.turnCount);
  const knowledgeAnswer = buildKnowledgeAnswer(input);
  const compareRequest = parseCompareRequest(input);
  const modePreset = getAiModePreset();

  aiSessionState.turnCount += 1;
  aiSessionState.lastUserMessage = input;
  aiSessionState.userEmotion = emotion;

  const coachingMoves = buildActionCoaching(snapshot);
  const deepPlan = buildDeepPlan(snapshot);

  const stylePrefix = buildModeAwarePrefix(tone);

  if (compareRequest) {
    const comparison = buildComparisonResponse(compareRequest.left, compareRequest.right, snapshot);
    aiSessionState.lastIntent = "compare";
    aiSessionState.lastAdvice = [comparison.decisionRule];
    return {
      response: `‚öñÔ∏è <b>Comparison: ${escapeHtml(compareRequest.left)} vs ${escapeHtml(compareRequest.right)}</b><br><br><b>Summary</b>: ${comparison.summary}<br><br><b>${escapeHtml(compareRequest.left)} Pros</b><br>‚Ä¢ ${comparison.prosLeft.join("<br>‚Ä¢ ")}<br><br><b>${escapeHtml(compareRequest.right)} Pros</b><br>‚Ä¢ ${comparison.prosRight.join("<br>‚Ä¢ ")}<br><br><b>Decision Rule</b>: ${comparison.decisionRule}`,
      isHtml: true
    };
  }

  if (intent.key === "greeting") {
    const pending = snapshot.pendingTasks;
    const waterLeft = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
    aiSessionState.lastIntent = "greeting";
    return {
      response: `${greeting}, ${name}! üåü Quick status: score ${snapshot.score}/100, ${pending} pending task${pending === 1 ? "" : "s"}, ${waterLeft} glass${waterLeft === 1 ? "" : "es"} left. Want a high-performance 60-minute plan?`,
      isHtml: false
    };
  }

  if (intent.key === "smalltalk-health") {
    aiSessionState.lastIntent = "smalltalk-health";
    return {
      response: `${stylePrefix}I‚Äôm sharp and fully focused, ${name}. I‚Äôm tracking your live pattern (tasks, hydration, sleep, mood) and helping you make high-quality decisions quickly. You‚Äôre at ${snapshot.score}/100 right now.`,
      isHtml: false
    };
  }

  if (intent.key === "smalltalk-activity") {
    aiSessionState.lastIntent = "smalltalk-activity";
    return {
      response: `${stylePrefix}I‚Äôm analyzing your dashboard state in real time: tasks (${snapshot.doneTasks}/${snapshot.totalTasks}), hydration (${snapshot.waterToday}/${snapshot.todayGoal}), sleep (${snapshot.sleepToday || 0}h), and mood. I can either reason deeply or execute direct commands for you.`,
      isHtml: false
    };
  }

  if (intent.key === "identity") {
    aiSessionState.lastIntent = "identity";
    return {
      response: "I‚Äôm your NovaFix AI coach ü§ñ ‚Äî local, context-aware, memory-enabled, and action-capable. I can converse naturally, analyze your state, and execute dashboard actions instantly.",
      isHtml: false
    };
  }

  if (intent.key === "thanks") {
    aiSessionState.lastIntent = "thanks";
    return {
      response: `Always, ${name}. You‚Äôre building momentum. Next best move: ${coachingMoves[0]}`,
      isHtml: false
    };
  }

  if (intent.key === "bye") {
    aiSessionState.lastIntent = "bye";
    return {
      response: `See you soon, ${name} üëã Before you go: ${coachingMoves[0]}`,
      isHtml: false
    };
  }

  if (intent.key === "joke") {
    aiSessionState.lastIntent = "joke";
    return {
      response: "Why did the task finally get done? It stopped dating ‚Äòlater‚Äô and committed to ‚Äònow.‚Äô üòÑ",
      isHtml: false
    };
  }

  if (mathResult) {
    aiSessionState.lastIntent = "math";
    return {
      response: `üß† ${mathResult.expression} = ${mathResult.result}`,
      isHtml: false
    };
  }

  if (intent.key === "analysis") {
    const waterPct = Math.round((snapshot.waterToday / snapshot.todayGoal) * 100);
    const taskPct = snapshot.totalTasks ? Math.round((snapshot.doneTasks / snapshot.totalTasks) * 100) : 0;
    const moodText = snapshot.moodToday || "Not logged";

    let actions = [];
    if (snapshot.waterToday < snapshot.todayGoal) actions.push(`Drink ${Math.max(0, snapshot.todayGoal - snapshot.waterToday)} more glass${snapshot.todayGoal - snapshot.waterToday === 1 ? "" : "es"}.`);
    if (snapshot.sleepToday < 7) actions.push("Target 7‚Äì8 hours sleep tonight.");
    if (snapshot.pendingTasks > 0) actions.push("Finish 1 pending task in the next 25 minutes.");
    if (!snapshot.gratitudeToday) actions.push("Add one gratitude line before bed.");
    if (!snapshot.moodToday) actions.push("Log your mood to improve prediction quality.");
    while (actions.length < 3) actions.push("Keep momentum with one small healthy action now.");

    aiSessionState.lastIntent = "analysis";
    aiSessionState.lastAdvice = actions.slice(0, 3);

    return {
      response: `üìä <b>Deep Wellness Analysis</b><br>‚≠ê Score: <b>${snapshot.score}/100</b><br>üíß Water: ${snapshot.waterToday}/${snapshot.todayGoal} (${Math.max(0, waterPct)}%)<br>üí§ Sleep today: ${snapshot.sleepToday || 0} hrs<br>üßò Mood: ${moodText}<br>üìå Tasks done: ${snapshot.doneTasks}/${snapshot.totalTasks} (${taskPct}%)<br>üôè Gratitude today: ${snapshot.gratitudeToday ? "Yes" : "No"}<br><br><b>Best next moves</b><br>1) ${actions[0]}<br>2) ${actions[1]}<br>3) ${actions[2]}${recentContext ? `<br><br>üß† Recent context: <i>${escapeHtml(recentContext)}</i>` : ""}`,
      isHtml: true
    };
  }

  if (intent.key === "plan") {
    const planItems = deepPlan;
    aiSessionState.lastIntent = "plan";
    aiSessionState.lastAdvice = planItems;
    const depthNote = modePreset.depth >= 4
      ? "<br><b>Extra layer</b>: execute step 1 immediately, then re-evaluate after 25 minutes."
      : "";
    return {
      response: `üóÇÔ∏è <b>Your 60-min execution plan</b><br>‚Ä¢ ${planItems[0]}<br>‚Ä¢ ${planItems[1]}<br>‚Ä¢ ${planItems[2]}<br>‚Ä¢ ${planItems[3]}${depthNote}<br><br><b>Command mode</b>: say <i>add task ...</i> or <i>remind me to ... in 25 min</i> and I‚Äôll execute instantly.`,
      isHtml: true
    };
  }

  if (intent.key === "followup") {
    aiSessionState.lastIntent = "followup";
    const advice = aiSessionState.lastAdvice.length ? aiSessionState.lastAdvice : coachingMoves;
    return {
      response: `Perfect. Next level plan:<br>1) ${advice[0]}<br>2) ${advice[1]}<br>3) ${advice[2]}<br><br>If you want execution, use direct commands and I‚Äôll run them immediately.`,
      isHtml: true
    };
  }

  if (intent.key === "stress") {
    aiSessionState.lastIntent = "stress";
    aiSessionState.lastAdvice = [
      "Do 6 rounds of 4-4-6 breathing.",
      "Drink one glass of water.",
      "Start one 10-minute micro-task."
    ];
    return {
      response: `I hear you, ${name}. Let‚Äôs use a fast reset: 6 breathing rounds (4-4-6), drink water, then do one 10-minute micro-task. Reply ‚Äústart reset‚Äù and I‚Äôll guide step-by-step.`,
      isHtml: false
    };
  }

  if (intent.key === "sleep") {
    aiSessionState.lastIntent = "sleep";
    return {
      response: `Sleep protocol: no caffeine after 2 PM, dim lights 60 min pre-bed, and no scrolling in bed. Latest logged sleep: ${snapshot.sleepToday || (sleepHistory[sleepHistory.length-1] || 0)} hrs.`,
      isHtml: false
    };
  }

  if (intent.key === "water") {
    const left = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
    aiSessionState.lastIntent = "water";
    return {
      response: `Hydration check üíß You‚Äôre at ${snapshot.waterToday}/${snapshot.todayGoal}. Remaining: ${left} glass${left === 1 ? "" : "es"}. Want me to set a reminder right now?`,
      isHtml: false
    };
  }

  if (intent.key === "productivity") {
    aiSessionState.lastIntent = "productivity";
    return {
      response: `Focus mode ‚ö° Completed ${snapshot.doneTasks}/${snapshot.totalTasks}. Try: pick one pending task, 25-min timer, then 5-min break. Say ‚Äúadd task ‚Ä¶‚Äù and I‚Äôll add it instantly.`,
      isHtml: false
    };
  }

  if (intent.key === "gratitude") {
    aiSessionState.lastIntent = "gratitude";
    return {
      response: "Gratitude prompt: ‚ÄòOne small thing that made today easier was‚Ä¶‚Äô Want me to save your line now? Say: add gratitude <your text> üôè",
      isHtml: false
    };
  }

  if (intent.key === "capabilities") {
    aiSessionState.lastIntent = "capabilities";
    return {
      response: "I can chat naturally, reason over your context, compare options, remember user facts, and execute app actions. Commands: mode strict|coach|balanced|creative, remember that..., show memory, add task..., set water goal 8, log mood sad, log sleep 7, add gratitude..., remind me to ... in 20 min, list reminders, delete reminder 1, clear all reminders.",
      isHtml: false
    };
  }

  if (knowledgeAnswer) {
    aiSessionState.lastIntent = "knowledge";
    aiSessionState.lastAdvice = coachingMoves;
    return {
      response: `${stylePrefix}${knowledgeAnswer}<br><br><b>Applied to you now</b>: ${coachingMoves[0]}`,
      isHtml: true
    };
  }

  if (emotion === "low") {
    aiSessionState.lastIntent = "emotional-support";
    aiSessionState.lastAdvice = [
      "Slow breathing for 60‚Äì90 seconds.",
      "Hydrate now.",
      "Start a tiny 10-minute task."
    ];
    return {
      response: `You‚Äôre not alone, ${name}. Let‚Äôs reduce pressure: one deep breath cycle, one sip of water, one tiny win in 10 minutes. I can help you pick that tiny win now.`,
      isHtml: false
    };
  }

  if (emotion === "positive") {
    aiSessionState.lastIntent = "positive-momentum";
    return {
      response: `Love that energy, ${name} üî• Best use of momentum: ${coachingMoves[0]} Then I‚Äôll help you stack the next move.`,
      isHtml: false
    };
  }

  aiSessionState.lastIntent = "fallback";
  aiSessionState.conversationSummary = `Last topic: ${intent.key}; mood: ${emotion}; score: ${snapshot.score}`;
  const personalGoal = aiSessionState.userFacts.goal ? `<br>üéØ Your stated goal: <i>${escapeHtml(aiSessionState.userFacts.goal)}</i>` : "";

  if (modePreset.style === "ultra") {
    return {
      response: buildUltraFallback(snapshot, name),
      isHtml: true
    };
  }

  return {
    response: `üß† I got your context and here‚Äôs the best move stack now:<br>1) ${coachingMoves[0]}<br>2) ${coachingMoves[1]}<br>3) ${coachingMoves[2]}${personalGoal}<br><br>I can talk naturally or execute commands immediately.`,
    isHtml: true
  };
}

function setChatText(textNode, text, isHtml) {
  if (isHtml) textNode.innerHTML = text;
  else textNode.textContent = text;
}

function renderChatMessage(role, messageText, isHtml, chatId, fieldName) {
  const row = document.createElement("div");
  row.className = "chat-message";

  const textNode = document.createElement("div");
  textNode.className = "chat-text";
  textNode.dataset.rawText = messageText;
  setChatText(textNode, `${role === "user" ? "You" : "AI"}: ${messageText}`, isHtml);

  row.append(textNode);

  if (role === "user") {
    const editBtn = document.createElement("button");
    editBtn.className = "chat-edit-btn";
    editBtn.textContent = "Edit";
    editBtn.onclick = () => editChatMessage(chatId, fieldName, textNode, role);
    row.append(editBtn);
  }

  chat.appendChild(row);
  chat.scrollTop = chat.scrollHeight;
}

async function editChatMessage(chatId, fieldName, textNode, role) {
  const currentText = textNode.dataset.rawText || "";
  const updatedText = prompt("Edit message", currentText);
  if (updatedText === null) return;

  const nextText = updatedText.trim();
  if (!nextText) {
    alert("Message cannot be empty.");
    return;
  }

  textNode.dataset.rawText = nextText;
  setChatText(textNode, `${role === "user" ? "You" : "AI"}: ${nextText}`, false);

  const user = auth.currentUser;
  if (!user || !chatId) return;

  try {
    const snapshot = await getDocs(collection(db, "users", user.uid, "aiChats"));
    const chatEntries = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.createdAt?.toMillis?.() ?? new Date(a.createdAt || 0).getTime();
        const bTime = b.createdAt?.toMillis?.() ?? new Date(b.createdAt || 0).getTime();
        return aTime - bTime;
      });

    const editedIndex = chatEntries.findIndex((entry) => entry.id === chatId);
    if (editedIndex < 0) return;

    const smart = await buildSmartAiResponse(nextText, user);
    await updateDoc(doc(db, "users", user.uid, "aiChats", chatId), {
      userMessage: nextText,
      aiResponse: smart.response,
      aiResponseIsHtml: smart.isHtml,
      updatedAt: serverTimestamp()
    });

    const entriesAfterEdited = chatEntries.slice(editedIndex + 1);
    if (entriesAfterEdited.length) {
      await Promise.all(
        entriesAfterEdited.map((entry) =>
          deleteDoc(doc(db, "users", user.uid, "aiChats", entry.id))
        )
      );
    }

    await loadAiChats(user.uid);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function renderChatPair(entry) {
  renderChatMessage("user", entry.userMessage || "", false, entry.id, "userMessage");
  renderChatMessage("ai", entry.aiResponse || "", !!entry.aiResponseIsHtml, entry.id, "aiResponse");
}

async function loadAiChats(userId) {
  chat.innerHTML = "";
  aiRecentPrompts.length = 0;
  aiSessionState.lastIntent = "";
  aiSessionState.lastAdvice = [];
  aiSessionState.lastUserMessage = "";
  aiSessionState.conversationSummary = "";
  aiSessionState.topicHistory.length = 0;

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "aiChats"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.createdAt?.toMillis?.() ?? new Date(a.createdAt || 0).getTime();
        const bTime = b.createdAt?.toMillis?.() ?? new Date(b.createdAt || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      if (entry.userMessage) rememberPrompt(entry.userMessage);
      renderChatPair(entry);
    });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function storeAiChat(userId, userMessage, aiResponse, aiResponseIsHtml) {
  try {
    const ref = await addDoc(
      collection(db, "users", userId, "aiChats"),
      {
        userMessage,
        aiResponse,
        aiResponseIsHtml,
        createdAt: serverTimestamp()
      }
    );
    return ref.id;
  } catch (err) {
    notifyFirestoreError(err);
    return null;
  }
}

async function clearAiChats() {
  const user = auth.currentUser;
  if (!user) return;
  if (!confirm("Clear all AI conversations?")) return;

  try {
    const snapshot = await getDocs(collection(db, "users", user.uid, "aiChats"));
    await Promise.all(snapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
    chat.innerHTML = "";
    aiRecentPrompts.length = 0;
    aiSessionState.lastIntent = "";
    aiSessionState.lastAdvice = [];
    aiSessionState.lastUserMessage = "";
    aiSessionState.conversationSummary = "";
    aiSessionState.topicHistory.length = 0;
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function aiChat(){
  const input = aiInput.value.trim();
  if(!input) return;
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  await ensureAiUsageCurrent(user.uid);
  if (aiUsageCount >= AI_DAILY_LIMIT) {
    renderChatMessage("ai", "Daily AI limit reached", false, null, null);
    aiInput.value = "";
    return;
  }

  const smart = await buildSmartAiResponse(input, user);
  const response = smart.response;
  const responseIsHtml = smart.isHtml;
  rememberPrompt(input);

  const chatId = await storeAiChat(user.uid, input, response, responseIsHtml);
  renderChatPair({
    id: chatId,
    userMessage: input,
    aiResponse: response,
    aiResponseIsHtml: responseIsHtml
  });
  aiUsageCount += 1;
  await saveAiUsage(user.uid);
  aiInput.value="";
}

// Reminders
function clearReminderTimer(reminderId) {
  const timerId = reminderIntervals.get(reminderId);
  if (timerId) {
    clearInterval(timerId);
    reminderIntervals.delete(reminderId);
  }
}

function clearAllReminderTimers() {
  reminderIntervals.forEach((timerId) => clearInterval(timerId));
  reminderIntervals.clear();
}

async function deleteReminderFromAi(userId, query) {
  try {
    const snapshot = await getDocs(collection(db, "users", userId, "reminders"));
    const remindersList = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => (Number(a.targetAtMs) || 0) - (Number(b.targetAtMs) || 0));

    if (!remindersList.length) {
      return { ok: false, message: "No reminders found." };
    }

    const trimmedQuery = (query || "").trim();
    let targetReminder = null;

    if (!trimmedQuery) {
      targetReminder = remindersList[0];
    } else if (/^\d+$/.test(trimmedQuery)) {
      const index = Number(trimmedQuery) - 1;
      if (index >= 0 && index < remindersList.length) {
        targetReminder = remindersList[index];
      }
    }

    if (!targetReminder && trimmedQuery) {
      const lowered = trimmedQuery.toLowerCase();
      targetReminder = remindersList.find((entry) => (entry.text || "").toLowerCase().includes(lowered));
    }

    if (!targetReminder) {
      return { ok: false, message: `No reminder matched \"${trimmedQuery}\".` };
    }

    await deleteDoc(doc(db, "users", userId, "reminders", targetReminder.id));
    clearReminderTimer(targetReminder.id);
    await loadReminders(userId);

    return { ok: true, entry: targetReminder };
  } catch (err) {
    notifyFirestoreError(err);
    return { ok: false, message: "Could not delete reminder right now." };
  }
}

function renderReminder(entry) {
  const li = document.createElement("li");
  li.className = "item-row";

  const label = document.createElement("span");
  label.className = "item-text";
  const reminderTextValue = entry.text || "Reminder";
  const reminderMinutes = Number(entry.minutes) || 0;
  const targetAtMs = Number(entry.targetAtMs) || (Date.now() + reminderMinutes * 60000);

  const actions = document.createElement("div");
  actions.className = "item-actions";

  const deleteBtn = document.createElement("button");
  deleteBtn.textContent = "Delete";
  deleteBtn.onclick = async () => {
    const user = auth.currentUser;
    clearReminderTimer(entry.id);

    if (user && entry.id) {
      try {
        await deleteDoc(doc(db, "users", user.uid, "reminders", entry.id));
      } catch (err) {
        notifyFirestoreError(err);
      }
    }
    li.remove();
  };

  const setLabelText = (secondsLeft) => {
    if (secondsLeft <= 0) {
      label.textContent = `‚Ä¢ ${reminderTextValue} ‚Äì Time's up!`;
      return;
    }
    const mins = Math.floor(secondsLeft / 60);
    const secs = secondsLeft % 60;
    label.textContent = `‚Ä¢ ${reminderTextValue} ‚Äì ${mins}m ${secs}s`;
  };

  let secondsRemaining = Math.max(0, Math.ceil((targetAtMs - Date.now()) / 1000));
  setLabelText(secondsRemaining);

  if (secondsRemaining > 0) {
    const audio = document.getElementById("reminderSound");
    const timer = setInterval(() => {
      secondsRemaining -= 1;
      if (secondsRemaining <= 0) {
        clearReminderTimer(entry.id);
        setLabelText(0);
        if (audio) audio.play();
        return;
      }
      setLabelText(secondsRemaining);
    }, 1000);
    if (entry.id) reminderIntervals.set(entry.id, timer);
  }

  actions.append(deleteBtn);
  li.append(label, actions);
  reminders.appendChild(li);
}

async function loadReminders(userId) {
  reminders.innerHTML = "";
  clearAllReminderTimers();

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "reminders"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => (Number(a.targetAtMs) || 0) - (Number(b.targetAtMs) || 0));

    docs.forEach((entry) => renderReminder(entry));
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function addReminder() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const t = reminderText.value.trim();
  const m = +reminderMinutes.value;
  if (!t || m <= 0) return;

  const targetAtMs = Date.now() + (m * 60 * 1000);

  try {
    const ref = await addDoc(collection(db, "users", user.uid, "reminders"), {
      text: t,
      minutes: m,
      targetAtMs,
      createdAt: serverTimestamp()
    });

    renderReminder({ id: ref.id, text: t, minutes: m, targetAtMs });
    reminderText.value = "";
    reminderMinutes.value = "";
  } catch (err) {
    notifyFirestoreError(err);
  }
}

// Tasks
function renderTask(entry) {
  const li = document.createElement("li");
  li.className = "item-row";
  const span = document.createElement("span");
  span.className = "item-text";
  span.textContent = entry.text;
  if (entry.completed) span.classList.add("task-done");

  const actions = document.createElement("div");
  actions.className = "item-actions";

  const toggleBtn = document.createElement("button");
  toggleBtn.textContent = entry.completed ? "‚úÖ" : "‚¨ú";
  toggleBtn.title = "Toggle complete";
  toggleBtn.onclick = async () => {
    entry.completed = !entry.completed;
    span.classList.toggle("task-done", entry.completed);
    toggleBtn.textContent = entry.completed ? "‚úÖ" : "‚¨ú";

    const listIndex = taskEntries.findIndex((taskItem) => taskItem.id === entry.id);
    if (listIndex >= 0) taskEntries[listIndex].completed = entry.completed;
    updateInsights();

    const user = auth.currentUser;
    if (!user || !entry.id) return;
    try {
      await updateDoc(doc(db, "users", user.uid, "tasks", entry.id), { completed: entry.completed });
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  const editBtn = document.createElement("button");
  editBtn.textContent = "‚úèÔ∏è";
  editBtn.onclick = async () => {
    const newText = prompt("Edit task", span.textContent);
    if (!newText || !newText.trim()) return;
    span.textContent = newText.trim();

    const user = auth.currentUser;
    if (!user || !entry.id) return;
    try {
      await updateDoc(doc(db, "users", user.uid, "tasks", entry.id), { text: newText.trim() });
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  const deleteBtn = document.createElement("button");
  deleteBtn.textContent = "üóëÔ∏è";
  deleteBtn.onclick = async () => {
    const user = auth.currentUser;
    if (!user || !entry.id) {
      const fallbackIndex = taskEntries.findIndex((taskItem) => taskItem.id === entry.id);
      if (fallbackIndex >= 0) taskEntries.splice(fallbackIndex, 1);
      updateInsights();
      li.remove();
      return;
    }
    try {
      await deleteDoc(doc(db, "users", user.uid, "tasks", entry.id));
      const listIndex = taskEntries.findIndex((taskItem) => taskItem.id === entry.id);
      if (listIndex >= 0) taskEntries.splice(listIndex, 1);
      updateInsights();
      li.remove();
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  actions.append(toggleBtn, editBtn, deleteBtn);
  li.append(span, actions);
  taskList.appendChild(li);
}

async function loadTasks(userId) {
  taskList.innerHTML = "";
  taskEntries.length = 0;
  try {
    const snapshot = await getDocs(collection(db, "users", userId, "tasks"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });
    docs.forEach((entry) => {
      const normalized = {
        ...entry,
        completed: !!entry.completed
      };
      taskEntries.push(normalized);
      renderTask(normalized);
    });
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function addTask(){
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const t=task.value.trim();
  if(!t)return;

  try {
    const ref = await addDoc(collection(db, "users", user.uid, "tasks"), {
      text: t,
      completed: false,
      time: serverTimestamp()
    });
    const newTask = { id: ref.id, text: t, completed: false, time: new Date() };
    taskEntries.push(newTask);
    renderTask(newTask);
    updateInsights();
    task.value="";
  } catch (err) {
    notifyFirestoreError(err);
  }
}

// Finance
function calculateFinance(){
  const cost = parseFloat(gCost.value) || 0;
  const months = parseFloat(gMonths.value) || 1;
  const buf = parseFloat(buffer.value) || 0;

  const total = cost * months * (1 + buf/100);
  const monthly = total / months;

  financeResult.innerText = `Total: ‚Çπ${total.toFixed(0)} | Monthly: ‚Çπ${monthly.toFixed(0)}`;
}

// Mood
function renderMoodLog(entry) {
  const moodRow = document.createElement("div");
  moodRow.className = "mood-item";

  const moodLabel = document.createElement("span");
  const rawTime = entry.time?.toDate?.() ?? new Date(entry.time || Date.now());
  moodLabel.textContent = `${rawTime.toLocaleTimeString()} - ${entry.mood}`;

  const removeBtn = document.createElement("button");
  removeBtn.className = "mood-remove";
  removeBtn.textContent = "Remove";
  removeBtn.onclick = () => deleteMoodLog(entry.id, moodRow, entry.mood);

  moodRow.append(moodLabel, removeBtn);
  moodLogs.appendChild(moodRow);
}

async function deleteMoodLog(moodId, moodElement, moodValue) {
  const user = auth.currentUser;
  if (!user || !moodId) return;

  try {
    await deleteDoc(doc(db, "users", user.uid, "moods", moodId));
    moodElement.remove();
    const moodIndex = moodHistory.findIndex((m) => m === moodValue);
    if (moodIndex >= 0) moodHistory.splice(moodIndex, 1);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadMoods(userId) {
  moodLogs.innerHTML = "";
  moodHistory.length = 0;
  moodDates.length = 0;

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "moods"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      moodHistory.push(entry.mood);
      const moodTime = entry.time?.toDate?.() ?? new Date(entry.time || Date.now());
      moodDates.push(moodTime);
      renderMoodLog(entry);
    });
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveMood() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const moodValue = mood.value;

  try {
    const moodRef = await addDoc(
      collection(db, "users", user.uid, "moods"),
      {
        mood: moodValue,
        uid: user.uid,
        email: user.email || null,
        time: serverTimestamp()
      }
    );

    moodHistory.push(moodValue);
    moodDates.push(new Date());
    renderMoodLog({ id: moodRef.id, mood: moodValue, time: new Date() });
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

// Water
let waterGoal=0;
function updateWaterProgress() {
  const todayKey = getTodayKey();
  const sum = waterHistory.reduce((accumulator, value, index) => {
    const dateKey = dateToKey(waterDates[index]);
    return dateKey === todayKey ? accumulator + value : accumulator;
  }, 0);
  const percent = waterGoal > 0 ? Math.round((sum / waterGoal) * 100) : 0;
  waterProgress.innerText = `${sum}/${waterGoal} (${percent}%)`;
  updateInsights();
}

async function setWaterGoal(){
  const user = auth.currentUser;
  waterGoal = +waterGoalInput.value || 0;
  updateWaterProgress();

  if (waterGoal > 0) {
    alert(`‚úÖ Water goal set to ${waterGoal} glasses.`);
  } else {
    alert("‚ÑπÔ∏è Water goal cleared.");
  }

  if (!user) return;
  try {
    await setDoc(doc(db, "users", user.uid, "settings", "water"), {
      goal: waterGoal,
      goalDateKey: getTodayKey()
    }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadWaterData(userId) {
  waterHistory.length = 0;
  waterDates.length = 0;

  try {
    const waterSettings = await getDoc(doc(db, "users", userId, "settings", "water"));
    if (waterSettings.exists()) {
      const settings = waterSettings.data();
      const savedGoal = Number(settings.goal) || 0;
      const goalDateKey = settings.goalDateKey || null;
      const todayKey = getTodayKey();

      if (savedGoal > 0 && goalDateKey && goalDateKey !== todayKey) {
        waterGoal = 0;
        await setDoc(doc(db, "users", userId, "settings", "water"), {
          goal: 0,
          goalDateKey: todayKey
        }, { merge: true });
      } else {
        waterGoal = savedGoal;
      }
    } else {
      waterGoal = 0;
    }
    waterGoalInput.value = waterGoal || "";

    const snapshot = await getDocs(collection(db, "users", userId, "waterIntake"));
    const docs = snapshot.docs
      .map((docSnap) => docSnap.data())
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      if (entry.glasses) {
        waterHistory.push(entry.glasses);
        const waterTime = entry.time?.toDate?.() ?? new Date(entry.time || Date.now());
        waterDates.push(waterTime);
      }
    });

    updateWaterProgress();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveWater() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const v = +waterInput.value;
  if (!v) return; // ignore empty or 0 input

  waterHistory.push(v);

  try {
    await addDoc(collection(db, "users", user.uid, "waterIntake"), {
      glasses: v,
      time: serverTimestamp()
    });
    waterDates.push(new Date());
    updateWaterProgress();
    waterInput.value = "";
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function clearWaterData() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const confirmed = confirm("Clear your current water intake and goal?");
  if (!confirmed) return;

  waterHistory.length = 0;
  waterDates.length = 0;
  waterGoal = 0;
  waterGoalInput.value = "";
  waterInput.value = "";
  updateWaterProgress();

  try {
    const intakeSnapshot = await getDocs(collection(db, "users", user.uid, "waterIntake"));
    await Promise.all(intakeSnapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
    await setDoc(doc(db, "users", user.uid, "settings", "water"), {
      goal: 0,
      goalDateKey: getTodayKey()
    }, { merge: true });
    alert("‚úÖ Water intake and goal cleared.");
  } catch (err) {
    notifyFirestoreError(err);
  }
}

// Sleep
async function loadSleepData(userId) {
  sleepHistory.length = 0;
  sleepDates.length = 0;
  sleepResult.innerText = "";

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "sleepLogs"));
    const docs = snapshot.docs
      .map((docSnap) => docSnap.data())
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      if (entry.hours) {
        sleepHistory.push(entry.hours);
        const sleepTime = entry.time?.toDate?.() ?? new Date(entry.time || Date.now());
        sleepDates.push(sleepTime);
      }
    });

    if (sleepHistory.length) {
      const latest = sleepHistory[sleepHistory.length - 1];
      sleepResult.innerText = `${latest} hrs üí§`;
    }
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveSleep(){
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const hours = +sleepInput.value;
  if (!hours) return;

  sleepHistory.push(hours);
  sleepDates.push(new Date());
  sleepResult.innerText = `${hours} hrs üí§`;
  updateInsights();

  try {
    await addDoc(collection(db, "users", user.uid, "sleepLogs"), {
      hours,
      time: serverTimestamp()
    });
    sleepInput.value = "";
  } catch (err) {
    notifyFirestoreError(err);
  }
}

// Time Mirror
function timeTraveller() {
  const goalText = futureTask.value.trim();
  if (!goalText) return alert("Enter a task or goal.");

  const snapshot = getWellnessSnapshot();
  const lower = goalText.toLowerCase();

  const goalType =
    /study|exam|learn|course|revision|assignment/.test(lower) ? "learning" :
    /workout|gym|run|fitness|exercise|walk/.test(lower) ? "fitness" :
    /project|build|launch|startup|business|client|career/.test(lower) ? "career" :
    /sleep|rest|bed|wake/.test(lower) ? "recovery" :
    /water|hydrate|hydration/.test(lower) ? "hydration" :
    "general";

  const energyState = snapshot.sleepToday >= 7 ? "steady" : "low";
  const focusState = snapshot.pendingTasks <= 2 ? "clear" : "crowded";
  const hydrationLeft = Math.max(0, snapshot.todayGoal - snapshot.waterToday);

  const typeBoost = {
    learning: "your understanding compounds and recall becomes faster",
    fitness: "your energy improves and stress load drops noticeably",
    career: "your momentum builds and confidence in execution rises",
    recovery: "your nervous system settles and tomorrow starts stronger",
    hydration: "your focus gets sharper and fatigue drops in the next few hours",
    general: "your consistency grows and your confidence rises"
  };

  const skipCost = {
    learning: "you carry cognitive friction and last-minute pressure",
    fitness: "stress stays high and motivation weakens tomorrow",
    career: "momentum stalls and the task feels heavier later",
    recovery: "fatigue compounds and tomorrow starts with lower focus",
    hydration: "mental clarity dips and energy feels flat",
    general: "the task becomes heavier emotionally and mentally"
  };

  const firstStep =
    goalType === "learning" ? "Open your notes and do a 15-minute focused sprint." :
    goalType === "fitness" ? "Do a 5-minute warm-up and start the first set." :
    goalType === "career" ? "Break this into one shippable 20-minute action." :
    goalType === "recovery" ? "Set a wind-down alarm and reduce screen/light now." :
    goalType === "hydration" ? "Drink one glass now, then set a 30-minute follow-up." :
    "Do one 10-minute starter action right now.";

  const readinessHint = `${energyState === "steady" ? "Energy is on your side" : "Energy is low, so start tiny"} ‚Ä¢ ${focusState === "clear" ? "task load is manageable" : "task load is crowded"}${hydrationLeft > 0 ? ` ‚Ä¢ ${hydrationLeft} glass(es) hydration gap` : ""}`;

  timeMirror.innerHTML = `
    <p>‚ú® <b>Future if you do "${escapeHtml(goalText)}"</b><br>
    In 24 hours: ${typeBoost[goalType]}, and your self-trust strengthens. üí™</p>
    <p>‚è≥ <b>Future if you delay it</b><br>
    In 24 hours: ${skipCost[goalType]}, and starting feels harder than it is now. üòî</p>
    <p>üß≠ <b>Best first step</b><br>${firstStep}</p>
    <p>üìå <small>${readinessHint}</small></p>
  `;

  futureTask.value = "";
}

// Quotes
const quotes=["üå± 'The journey of a thousand miles begins with one step.' ‚Äì Lao Tzu","üí™ 'Your body can stand almost anything. It‚Äôs your mind that you have to convince.'","‚òÄÔ∏è 'Every morning we are born again. What we do today matters most.' ‚Äì Buddha","üåü 'Success is the sum of small efforts repeated day in and day out.' ‚Äì Robert Collier","üßò 'Happiness is not something ready-made. It comes from your own actions.' ‚Äì Dalai Lama","üî• 'Don‚Äôt watch the clock; do what it does. Keep going.' ‚Äì Sam Levenson"];
function newQuote(){quoteDisplay.innerText=quotes[Math.floor(Math.random()*quotes.length)];}
newQuote();

// Gratitude
function renderGratitude(entry) {
  const row = document.createElement("div");
  row.className = "item-row";
  const rawTime = entry.time?.toDate?.() ?? new Date(entry.time || Date.now());

  const label = document.createElement("span");
  label.className = "item-text";
  label.textContent = `${rawTime.toLocaleTimeString()} - ${entry.text}`;

  const actions = document.createElement("div");
  actions.className = "item-actions";

  const editBtn = document.createElement("button");
  editBtn.textContent = "‚úèÔ∏è";
  editBtn.onclick = async () => {
    const nextText = prompt("Edit gratitude", entry.text || "");
    if (!nextText || !nextText.trim()) return;

    const user = auth.currentUser;
    if (!user || !entry.id) return;

    try {
      await updateDoc(doc(db, "users", user.uid, "gratitudeLogs", entry.id), {
        text: nextText.trim()
      });
      entry.text = nextText.trim();
      label.textContent = `${rawTime.toLocaleTimeString()} - ${entry.text}`;
      const listIndex = gratitudeEntries.findIndex((item) => item.id === entry.id);
      if (listIndex >= 0) gratitudeEntries[listIndex].text = entry.text;
      updateInsights();
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  const deleteBtn = document.createElement("button");
  deleteBtn.textContent = "üóëÔ∏è";
  deleteBtn.onclick = async () => {
    const user = auth.currentUser;
    if (!user || !entry.id) {
      const fallbackIndex = gratitudeEntries.findIndex((item) => item.id === entry.id);
      if (fallbackIndex >= 0) gratitudeEntries.splice(fallbackIndex, 1);
      updateInsights();
      row.remove();
      return;
    }

    try {
      await deleteDoc(doc(db, "users", user.uid, "gratitudeLogs", entry.id));
      const listIndex = gratitudeEntries.findIndex((item) => item.id === entry.id);
      if (listIndex >= 0) gratitudeEntries.splice(listIndex, 1);
      updateInsights();
      row.remove();
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  actions.append(editBtn, deleteBtn);
  row.append(label, actions);
  gratitudeLogs.appendChild(row);
}

async function loadGratitude(userId) {
  gratitudeLogs.innerHTML = "";
  gratitudeEntries.length = 0;

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "gratitudeLogs"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      gratitudeEntries.push(entry);
      renderGratitude(entry);
    });
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveGratitude(){
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const t=gratitudeInput.value.trim();
  if(!t)return;

  try {
    const ref = await addDoc(collection(db, "users", user.uid, "gratitudeLogs"), {
      text: t,
      time: serverTimestamp()
    });
    const entry = { id: ref.id, text: t, time: new Date() };
    gratitudeEntries.push(entry);
    renderGratitude(entry);
    updateInsights();
    gratitudeInput.value="";
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function exportAllData() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  try {
    const waterSettingsSnap = await getDoc(doc(db, "users", user.uid, "settings", "water"));
    const dailyChallengeSnap = await getDoc(doc(db, "users", user.uid, "settings", "dailyChallenge"));
    const weeklyTargetsSnap = await getDoc(doc(db, "users", user.uid, "settings", "weeklyTargets"));
    const habitQuestSnap = await getDoc(doc(db, "users", user.uid, "settings", "habitQuest"));
    const insightsSnap = await getDoc(doc(db, "users", user.uid, "insights", "current"));
    const [
      moodsSnap,
      tasksSnap,
      waterSnap,
      sleepSnap,
      gratitudeSnap,
      aiSnap,
      challengeHistorySnap,
      rescueEventsSnap
    ] = await Promise.all([
      getDocs(collection(db, "users", user.uid, "moods")),
      getDocs(collection(db, "users", user.uid, "tasks")),
      getDocs(collection(db, "users", user.uid, "waterIntake")),
      getDocs(collection(db, "users", user.uid, "sleepLogs")),
      getDocs(collection(db, "users", user.uid, "gratitudeLogs")),
      getDocs(collection(db, "users", user.uid, "aiChats")),
      getDocs(collection(db, "users", user.uid, "challengeHistory")),
      getDocs(collection(db, "users", user.uid, "rescueEvents"))
    ]);

    const toExport = {
      exportedAt: new Date().toISOString(),
      user: {
        uid: user.uid,
        email: user.email || null,
        name: user.displayName || null
      },
      waterSettings: waterSettingsSnap.exists() ? waterSettingsSnap.data() : null,
      dailyChallengeSettings: dailyChallengeSnap.exists() ? dailyChallengeSnap.data() : null,
      weeklyTargets: weeklyTargetsSnap.exists() ? weeklyTargetsSnap.data() : null,
      habitQuest: habitQuestSnap.exists() ? habitQuestSnap.data() : null,
      insightsCurrent: insightsSnap.exists() ? insightsSnap.data() : null,
      moods: moodsSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      tasks: tasksSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      waterIntake: waterSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      sleepLogs: sleepSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      gratitudeLogs: gratitudeSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      aiChats: aiSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      challengeHistory: challengeHistorySnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      rescueEvents: rescueEventsSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
    };

    const blob = new Blob([JSON.stringify(toExport, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `novafix-export-${new Date().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function normalizeExportTime(value) {
  if (!value) return new Date();

  if (typeof value === "string" || typeof value === "number") {
    const asDate = new Date(value);
    if (!Number.isNaN(asDate.getTime())) return asDate;
  }

  if (typeof value === "object") {
    if (typeof value.seconds === "number") {
      return new Date((value.seconds * 1000) + Math.floor((value.nanoseconds || 0) / 1e6));
    }
    if (typeof value._seconds === "number") {
      return new Date((value._seconds * 1000) + Math.floor((value._nanoseconds || 0) / 1e6));
    }
  }

  const fallback = new Date(value);
  if (!Number.isNaN(fallback.getTime())) return fallback;
  return new Date();
}

function startImportData() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }
  if (importFileInput) importFileInput.click();
}

async function clearUserCollection(userId, collectionName) {
  const snapshot = await getDocs(collection(db, "users", userId, collectionName));
  await Promise.all(snapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
}

async function importDataFileChange(event) {
  const user = auth.currentUser;
  const selectedFile = event?.target?.files?.[0];

  if (!user || !selectedFile) return;

  const confirmed = confirm("Warning: current data will be destroyed and new data will be imported. Continue?");
  if (!confirmed) {
    event.target.value = "";
    return;
  }

  try {
    const rawText = await selectedFile.text();
    const payload = JSON.parse(rawText);

    const targetCollections = ["moods", "tasks", "waterIntake", "sleepLogs", "gratitudeLogs", "aiChats", "challengeHistory", "rescueEvents"];
    await Promise.all(targetCollections.map((name) => clearUserCollection(user.uid, name)));
    await deleteDoc(doc(db, "users", user.uid, "settings", "water")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "dailyChallenge")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "weeklyTargets")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "habitQuest")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "insights", "current")).catch(() => {});

    const moods = Array.isArray(payload.moods) ? payload.moods : [];
    const tasks = Array.isArray(payload.tasks) ? payload.tasks : [];
    const waterIntake = Array.isArray(payload.waterIntake) ? payload.waterIntake : [];
    const sleepLogs = Array.isArray(payload.sleepLogs) ? payload.sleepLogs : [];
    const gratitudeLogs = Array.isArray(payload.gratitudeLogs) ? payload.gratitudeLogs : [];
    const aiChats = Array.isArray(payload.aiChats) ? payload.aiChats : [];
    const challengeHistory = Array.isArray(payload.challengeHistory) ? payload.challengeHistory : [];
    const rescueEventsPayload = Array.isArray(payload.rescueEvents) ? payload.rescueEvents : [];

    await Promise.all(moods.map((entry) => addDoc(collection(db, "users", user.uid, "moods"), {
      mood: entry.mood || "",
      uid: user.uid,
      email: user.email || null,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(tasks.map((entry) => addDoc(collection(db, "users", user.uid, "tasks"), {
      text: entry.text || "",
      completed: !!entry.completed,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(waterIntake.map((entry) => addDoc(collection(db, "users", user.uid, "waterIntake"), {
      glasses: Number(entry.glasses) || 0,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(sleepLogs.map((entry) => addDoc(collection(db, "users", user.uid, "sleepLogs"), {
      hours: Number(entry.hours) || 0,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(gratitudeLogs.map((entry) => addDoc(collection(db, "users", user.uid, "gratitudeLogs"), {
      text: entry.text || "",
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(aiChats.map((entry) => addDoc(collection(db, "users", user.uid, "aiChats"), {
      userMessage: entry.userMessage || "",
      aiResponse: entry.aiResponse || "",
      aiResponseIsHtml: !!entry.aiResponseIsHtml,
      createdAt: normalizeExportTime(entry.createdAt)
    })));

    await Promise.all(challengeHistory.map((entry) => {
      const dateKey = entry.dateKey || (typeof entry.id === "string" ? entry.id : "");
      if (!dateKey) return Promise.resolve();
      return setDoc(doc(db, "users", user.uid, "challengeHistory", dateKey), {
        completed: !!entry.completed,
        challenge: entry.challenge || "",
        dateKey,
        updatedAt: normalizeExportTime(entry.updatedAt || entry.time)
      }, { merge: true });
    }));

    await Promise.all(rescueEventsPayload.map((entry) => addDoc(collection(db, "users", user.uid, "rescueEvents"), {
      level: entry.level || "",
      reason: entry.reason || "",
      time: normalizeExportTime(entry.time || entry.createdAt || entry.updatedAt)
    })));

    if (payload.waterSettings && typeof payload.waterSettings.goal !== "undefined") {
      await setDoc(doc(db, "users", user.uid, "settings", "water"), {
        goal: Number(payload.waterSettings.goal) || 0
      }, { merge: true });
    }

    if (payload.dailyChallengeSettings) {
      await setDoc(doc(db, "users", user.uid, "settings", "dailyChallenge"), {
        challenge: payload.dailyChallengeSettings.challenge || "",
        completed: !!payload.dailyChallengeSettings.completed,
        dateKey: payload.dailyChallengeSettings.dateKey || getTodayKey(),
        updatedAt: normalizeExportTime(payload.dailyChallengeSettings.updatedAt)
      }, { merge: true });
    }

    if (payload.weeklyTargets) {
      await setDoc(doc(db, "users", user.uid, "settings", "weeklyTargets"), {
        waterGoal: Number(payload.weeklyTargets.waterGoal) || 0,
        sleepTarget: Number(payload.weeklyTargets.sleepTarget) || 8,
        taskTarget: Number(payload.weeklyTargets.taskTarget) || 5,
        updatedAt: normalizeExportTime(payload.weeklyTargets.updatedAt)
      }, { merge: true });
    }

    if (payload.habitQuest) {
      await setDoc(doc(db, "users", user.uid, "settings", "habitQuest"), {
        dateKey: payload.habitQuest.dateKey || getTodayKey(),
        xp: Number(payload.habitQuest.xp) || 0,
        level: Number(payload.habitQuest.level) || 1,
        shield: !!payload.habitQuest.shield,
        quests: Array.isArray(payload.habitQuest.quests) ? payload.habitQuest.quests : [],
        updatedAt: normalizeExportTime(payload.habitQuest.updatedAt)
      }, { merge: true });
    }

    if (payload.insightsCurrent) {
      await setDoc(doc(db, "users", user.uid, "insights", "current"), {
        ...payload.insightsCurrent,
        updatedAt: normalizeExportTime(payload.insightsCurrent.updatedAt)
      }, { merge: true });
    }

    await Promise.all([
      loadDailyChallenge(user.uid),
      loadMoods(user.uid),
      loadAiChats(user.uid),
      loadTasks(user.uid),
      loadWeeklyTargets(user.uid),
      loadRescueEvents(user.uid),
      loadHabitQuest(user.uid),
      loadWaterData(user.uid),
      loadSleepData(user.uid),
      loadGratitude(user.uid)
    ]);

    alert("‚úÖ Data import complete.");
  } catch (err) {
    notifyFirestoreError(err);
  } finally {
    event.target.value = "";
  }
}

// Daily Challenge
const dailyChallenges = [
  "Finish 1 small task you‚Äôve been putting off.",
  "Learn 1 new word or fact today.",
  "Clean or organize one small area of your room/desk.",
  "Write down 3 things you‚Äôre grateful for.",
  "Smile at 3 people today.",
  "Avoid social media for 1 hour.",
  "Try a new hobby for 15 minutes.",
  "Drink 1 extra glass of water today.",
  "Take a 5-minute stretch break every 2 hours.",
  "Eat a fruit or vegetable with every meal.",
  "Meditate for 5‚Äì10 minutes."
];

// ---------- Function to pick a random daily challenge ----------
function pickDailyChallenge() {
  const todayKey = getTodayKey();
  const challenge = pickChallengeForDate(todayKey);
  currentChallengeDateKey = todayKey;
  currentChallengeText = challenge;
  dailyChallengeElement.innerText = challenge;
  challengeResultElement.innerText = "";
  dailyChallengeCompleted = false;
  updateInsights();
}

async function saveDailyChallengeState() {
  const user = auth.currentUser;
  if (!user) return;

  const todayKey = getTodayKey();
  try {
    await setDoc(doc(db, "users", user.uid, "settings", "dailyChallenge"), {
      challenge: currentChallengeText,
      completed: dailyChallengeCompleted,
      dateKey: todayKey,
      timeZone: userTimeZone,
      updatedAt: serverTimestamp()
    }, { merge: true });

    if (dailyChallengeCompleted) {
      await setDoc(doc(db, "users", user.uid, "challengeHistory", todayKey), {
        completed: true,
        challenge: currentChallengeText,
        dateKey: todayKey,
        updatedAt: serverTimestamp()
      }, { merge: true });
    }
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadDailyChallenge(userId) {
  const todayKey = getTodayKey();
  challengeDates.length = 0;

  try {
    const [challengeSettingsSnap, historySnap] = await Promise.all([
      getDoc(doc(db, "users", userId, "settings", "dailyChallenge")),
      getDocs(collection(db, "users", userId, "challengeHistory"))
    ]);

    historySnap.docs.forEach((docSnap) => {
      const data = docSnap.data();
      if (!data.completed) return;
      const key = data.dateKey || docSnap.id;
      const parsed = dateKeyToDate(key);
      if (parsed) challengeDates.push(parsed);
    });

    let challenge = pickChallengeForDate(todayKey);
    let completed = false;

    if (challengeSettingsSnap.exists()) {
      const settings = challengeSettingsSnap.data();
      if (settings.dateKey === todayKey) {
        challenge = settings.challenge || challenge;
        completed = !!settings.completed;
      }
    }

    currentChallengeDateKey = todayKey;
    currentChallengeText = challenge;
    dailyChallengeCompleted = completed;
    dailyChallengeElement.innerText = challenge;
    challengeResultElement.innerText = completed ? "‚úÖ Challenge completed! Great job!" : "";

    if (completed) {
      const parsedToday = dateKeyToDate(todayKey);
      if (parsedToday && !challengeDates.some((date) => dateToKey(date) === todayKey)) {
        challengeDates.push(parsedToday);
      }
    }

    await saveDailyChallengeState();
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
    pickDailyChallenge();
  }
}

// Initialize daily challenge on page load
pickDailyChallenge();

// Complete challenge function
async function completeChallenge() {
  if (dailyChallengeCompleted) {
    challengeResultElement.innerText = "‚úÖ Challenge already completed for today.";
    return;
  }

  dailyChallengeCompleted = true;
  const todayKey = getTodayKey();
  const parsedToday = dateKeyToDate(todayKey);
  if (parsedToday && !challengeDates.some((date) => dateToKey(date) === todayKey)) {
    challengeDates.push(parsedToday);
  }

  challengeResultElement.innerText = "‚úÖ Challenge completed! Great job!";
  updateInsights();
  await saveDailyChallengeState();
}

Object.assign(window, {
  handleAuth,
  toggleAuth,
  toggleAccountPanel,
  closeAccountPanel,
  clearAllAccountData,
  runCrashRescueFlow,
  setNextWeekTargets,
  applyRecoverySchedule,
  nextInsightMetric,
  signOutUser,
  aiChat,
  clearAiChats,
  addReminder,
  addTask,
  calculateFinance,
  saveMood,
  setWaterGoal,
  saveWater,
  clearWaterData,
  saveSleep,
  timeTraveller,
  newQuote,
  saveGratitude,
  completeChallenge,
  exportAllData,
  startImportData,
  importDataFileChange,
  handleGoogleAuth,
  sendResetPasswordEmail,
  sendAccountResetPasswordEmail
});

</script>
</body>
</html>

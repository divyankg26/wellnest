
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NovaFix ‚Äì Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
:root{
  --waveA:#2196f3;
  --waveB:#ff9800;
  --primary:#2196f3;
  --accent:#ff9800;
  --glass:rgba(255,255,255,0.18);
  --text:#fff;
}

html,body{
  margin:0;
  height:100%;
  font-family:'Segoe UI',sans-serif;
  color:var(--text);
}

body{
  background:linear-gradient(120deg,var(--waveA),var(--waveB));
  background-size:200% 200%;
  animation:waveMove 8s ease-in-out infinite;
  overflow-x:hidden;
}

@keyframes waveMove{
  0%{background-position:0% 50%}
  50%{background-position:100% 50%}
  100%{background-position:0% 50%}
}

/* SPLASH */
#splash{
  position:fixed;
  inset:0;
  background:#FFFFFF;
  display:flex;
  justify-content:center;
  align-items:center;
  z-index:9999;
  transition:opacity 1s ease, transform 1s ease;
}
#splash.hide{
  opacity:0;
  transform:translateY(-40px);
  pointer-events:none;
}
#splash img{
  width:450px;
  max-width:80%;
  animation:popIn 1.2s ease;
}
@keyframes popIn{
  from{opacity:0;transform:scale(.85)}
  to{opacity:1;transform:scale(1)}
}

/* SIGN-IN / SIGN-UP MODAL */
#signInModal {
  display: none; 
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  justify-content: center;
  align-items: center;
  z-index: 10000;
}
.modal-content {
  background: rgba(255,255,255,0.15);
  backdrop-filter: blur(14px);
  padding: 40px;
  border-radius: 20px;
  text-align: center;
  width: 90%;
  max-width: 400px;
  color: #fff;
  box-shadow: 0 12px 30px rgba(0,0,0,0.3);
}
.modal-content input {
  width: 100%;
  margin: 10px 0;
  padding: 12px;
  border-radius: 12px;
  border: none;
  background: rgba(255,255,255,0.22);
  color: #fff;
  font-size: 16px;
}
.modal-content button {
  width: 100%;
  padding: 12px;
  margin-top: 10px;
  border-radius: 12px;
  border: none;
  cursor: pointer;
  background: linear-gradient(135deg,var(--primary),var(--accent));
  color: #fff;
  font-weight: bold;
  font-size: 16px;
}
.google-btn{
  background: rgba(255,255,255,0.28) !important;
}
.modal-content p {margin-top: 10px; font-size: 14px; cursor: pointer;}

/* HEADER */
header{
  text-align:center;
  padding:30px;
  background:var(--glass);
  backdrop-filter:blur(14px);
  border-radius:0 0 20px 20px;
  box-shadow:0 12px 30px rgba(0,0,0,.3);
  position:relative;
}
header h1{margin:0;color:var(--primary)}
header p{margin:6px 0 0}
#signOutBtn{
  position:absolute;
  right:20px;
  top:30px;
  padding:8px 14px;
  border:none;
  border-radius:12px;
  cursor:pointer;
  background: linear-gradient(135deg,var(--accent),var(--primary));
  color:#fff;
  font-weight:bold;
  display:none;
}

/* DASHBOARD */
.dashboard{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(300px,1fr));
  gap:24px;
  padding:24px;
  display:none;
}

/* CARD */
.card{
  background:var(--glass);
  backdrop-filter:blur(16px);
  border-radius:20px;
  padding:20px;
  box-shadow:0 16px 40px rgba(0,0,0,.3);
  display:flex;
  flex-direction:column;
  border:1px solid rgba(255,255,255,.25);
}
.card h2{margin-top:0;color:var(--primary)}

.input-group{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-top:8px;
}

input,select,textarea,button{
  padding:10px;
  border-radius:12px;
  border:none;
  background:rgba(255,255,255,.22);
  color:var(--text);
  font-family:inherit;
}

button{
  cursor:pointer;
  font-weight:bold;
  background:linear-gradient(135deg,var(--primary),var(--accent));
}

.chat,#moodLogs,#gratitudeLogs,#reminders,#taskList{
  flex-grow:1;
  overflow-y:auto;
  padding:8px;
  border-radius:12px;
  background:rgba(0,0,0,.15);
  margin-top:8px;
}

#taskList button,
#gratitudeLogs button{
  margin-left:12px;
}

.ai-header-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}

.ai-header-row h2{margin:0}

.ai-clear-btn{
  padding:6px 10px;
  border-radius:10px;
  font-size:12px;
}

.chat-message{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:8px;
  margin-bottom:8px;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.12);
}

.chat-text{
  font-size:14px;
  line-height:1.35;
  word-break:break-word;
}

.chat-edit-btn{
  padding:6px 10px;
  border-radius:10px;
  font-size:12px;
  white-space:nowrap;
}

.mood-item{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  margin-bottom:8px;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.12);
}

.mood-item span{
  font-size:14px;
}

.mood-remove{
  padding:6px 10px;
  border-radius:10px;
  border:none;
  font-size:12px;
}

.task-done{
  text-decoration:line-through;
  opacity:.75;
}

.insight-list{margin:6px 0 0;padding-left:18px}
.insight-list li{margin:4px 0}

.insight-row{margin-top:8px}
.insight-row small{display:block;margin-bottom:4px;opacity:.9}
.insight-bar{
  width:100%;
  height:10px;
  border-radius:10px;
  background:rgba(255,255,255,.2);
  overflow:hidden;
}
.insight-fill{
  height:100%;
  background:linear-gradient(135deg,var(--primary),var(--accent));
  width:0%;
}

.export-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.export-note{font-size:13px;opacity:.9;margin-top:8px}

.wellness-badge{
  font-size:34px;
  font-weight:800;
  text-align:center;
  margin:6px 0;
}

.wellness-status{
  text-align:center;
  margin:0;
  font-weight:600;
}

.wellness-actions{
  margin:10px 0 0;
  padding-left:18px;
}

.wellness-actions li{
  margin:5px 0;
}

::-webkit-scrollbar{width:6px}
::-webkit-scrollbar-thumb{background:var(--primary);border-radius:3px}
</style>
</head>
<body>

<audio id="reminderSound" src="https://image2url.com/r2/default/audio/1770462028211-e2a46d69-8e18-430d-971b-e111cf9254b9.mp3" preload="auto"></audio>

<!-- SPLASH -->
<div id="splash">
  <img src="https://gcdnb.pbrd.co/images/T3DLjTXN0F9N.jpg?o=1">
</div>

<!-- SIGN-IN / SIGN-UP MODAL -->
<div id="signInModal">
  <div class="modal-content">
    <h2 id="modalTitle">Welcome to NovaFix üåü</h2>
    <input id="usernameInput" type="text" placeholder="Enter username" style="display:none;">
    <input id="emailInput" type="email" placeholder="Enter email">
    <input id="passwordInput" type="password" placeholder="Enter password">
    <button id="actionButton" onclick="handleAuth()">Sign In</button>
    <button id="googleAuthButton" class="google-btn" onclick="handleGoogleAuth()">Sign In with Google</button>
    <p onclick="toggleAuth()"><span id="toggleText">Don't have an account? Sign Up</span></p>
    <p id="signInError" style="color:red; display:none;">Error message here!</p>
  </div>
</div>

<header>
  <h1>NovaFix</h1>
  <p>Mind ‚Ä¢ Body ‚Ä¢ Money ‚Ä¢ Music ‚Ä¢ Productivity</p>
<button id="signOutBtn" onclick="signOutUser()">Sign Out</button>
</header>

<div class="dashboard">

<!-- AI Companion -->
<div class="card">
<div class="ai-header-row">
<h2>ü§ñ AI Companion</h2>
<button class="ai-clear-btn" onclick="clearAiChats()">Clear</button>
</div>
<div class="chat" id="chat"></div>
<div class="input-group">
<input id="aiInput" placeholder="Talk to AI">
<button onclick="aiChat()">Talk</button>
</div>
</div>

<!-- Reminders -->
<div class="card">
<h2>‚è∞ Reminders</h2>
<div class="input-group">
<input id="reminderText" placeholder="Reminder">
<input type="number" id="reminderMinutes" placeholder="Minutes">
<button onclick="addReminder()">Set</button>
</div>
<ul id="reminders"></ul>
</div>

<!-- Tasks -->
<div class="card">
<h2>üìä Productivity</h2>
<div class="input-group">
<input id="task" placeholder="Task">
<button onclick="addTask()">Add</button>
</div>
<ul id="taskList"></ul>
</div>

<!-- Grocery Finance -->
<div class="card">
<h2>üßæ Grocery Financing</h2>
<input id="gCost" placeholder="Monthly ‚Çπ">
<input id="gMonths" placeholder="Months">
<input id="buffer" placeholder="Buffer %">
<button onclick="calculateFinance()">Plan</button>
<p id="financeResult"></p>
</div>

<!-- Mood Tracker -->
<div class="card">
<h2>üßò Mood Tracker</h2>
<select id="mood">
<option>üòä Happy</option>
<option>üòê Neutral</option>
<option>üòî Low</option>
</select>
<button onclick="saveMood()">Save</button>
<div id="moodLogs"></div>
</div>

<!-- Water -->
<div class="card">
<h2>üíß Water Intake</h2>
<input id="waterGoalInput" placeholder="Daily goal">
<button onclick="setWaterGoal()">Set Goal</button>
<input id="waterInput" placeholder="Glasses">
<button onclick="saveWater()">Track</button>
<p id="waterProgress"></p>
</div>

<!-- Sleep -->
<div class="card">
<h2>üí§ Sleep</h2>
<input id="sleepInput" placeholder="Hours">
<button onclick="saveSleep()">Save</button>
<p id="sleepResult"></p>
</div>

<!-- Wellness Music -->
<div class="card">
<h2>üéµ Wellness Music</h2>
<iframe style="border-radius:14px" src="https://open.spotify.com/embed/playlist/0Gwjm4uWLCSE7ZIiY6dK2X" width="100%" height="190"></iframe>
</div>

<!-- Time Traveller Mirror -->
<div class="card">
<h2>ü™û Time Traveller Mirror</h2>
<input id="futureTask" placeholder="Enter goal">
<button onclick="timeTraveller()">Check</button>
<div id="timeMirror"></div>
</div>

<!-- Motivational Quotes -->
<div class="card">
<h2>üí° Motivational Quotes</h2>
<p id="quoteDisplay"></p>
<button onclick="newQuote()">Inspire Me</button>
</div>

<!-- Gratitude Journal -->
<div class="card">
<h2>üôè Gratitude Journal</h2>
<textarea id="gratitudeInput" rows="3"></textarea>
<button onclick="saveGratitude()">Save</button>
<div id="gratitudeLogs"></div>
</div>

<!-- Daily Challenge -->
<div class="card">
<h2>üèÜ Daily Challenge</h2>
<p id="dailyChallenge"></p>
<button onclick="completeChallenge()">Complete</button>
<p id="challengeResult"></p>
</div>

<!-- Daily Wellness Score -->
<div class="card">
<h2>‚≠ê Daily Wellness Score</h2>
<div id="wellnessScore" class="wellness-badge">0/100</div>
<p id="wellnessStatus" class="wellness-status">Needs Focus</p>
<ul id="wellnessActions" class="wellness-actions">
  <li>Log your first check-in for today.</li>
  <li>Set your water target and drink one glass.</li>
  <li>Add one gratitude note tonight.</li>
</ul>
</div>

<!-- Insights -->
<div class="card">
<h2>üìà Insights & Streaks</h2>
<p id="insightSummary">Loading insights...</p>
<ul class="insight-list">
  <li id="moodStreak">Mood streak: 0 days</li>
  <li id="waterStreak">Water streak: 0 days</li>
  <li id="gratitudeStreak">Gratitude streak: 0 days</li>
  <li id="challengeStreak">Challenge streak: 0 days</li>
</ul>

<div class="insight-row">
  <small id="taskCompletionLabel">Productivity task completion: 0%</small>
  <div class="insight-bar"><div id="taskCompletionBar" class="insight-fill"></div></div>
</div>
<div class="insight-row">
  <small id="sleepAverageLabel">Avg sleep: 0 hrs</small>
  <div class="insight-bar"><div id="sleepAverageBar" class="insight-fill"></div></div>
</div>
<div class="insight-row">
  <small id="waterGoalLabel">Water goal progress: 0%</small>
  <div class="insight-bar"><div id="waterGoalBar" class="insight-fill"></div></div>
</div>
</div>

<!-- Export -->
<div class="card">
<h2>üì¶ Export</h2>
<div class="export-actions">
  <button onclick="exportAllData()">Export My Data</button>
  <button onclick="startImportData()">Import Data</button>
</div>
<p class="export-note">Download your full NovaFix data as JSON for transfering accounts</p>
<input id="importFileInput" type="file" accept="application/json,.json" style="display:none" onchange="importDataFileChange(event)">
</div>

</div>

<script type="module">
  // üî• Firebase Imports
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { initializeFirestore, persistentLocalCache, getFirestore, collection, addDoc, getDocs, serverTimestamp, deleteDoc, doc, updateDoc, setDoc, getDoc } 
from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";
import { 
  getAuth, 
  createUserWithEmailAndPassword, 
  signInWithEmailAndPassword, 
  onAuthStateChanged, 
  signOut,
  updateProfile,
  GoogleAuthProvider,
  signInWithPopup,
  sendEmailVerification
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

// üî• Your Firebase Config
const firebaseConfig = {
  apiKey: "AIzaSyCirCkRGlsODEExB9VLVY08Zw7b84zm_Qc",
  authDomain: "novaafix-86912.firebaseapp.com",
  projectId: "novaafix-86912",
  storageBucket: "novaafix-86912.firebasestorage.app",
  messagingSenderId: "699084708640",
  appId: "1:699084708640:web:401f5d6990d818551e1545",
  measurementId: "G-WHHXFW3N7R"
};

// üî• Initialize Firebase
const app = initializeApp(firebaseConfig);
let analytics = null;
try {
  analytics = getAnalytics(app);
} catch (_) {}
const auth = getAuth(app);
let db;
try {
  db = initializeFirestore(app, {
    localCache: persistentLocalCache()
  });
} catch (_) {
  db = getFirestore(app);
}
const googleProvider = new GoogleAuthProvider();

// ---------- DOM REFERENCES ----------
const emailInput = document.getElementById("emailInput");
const passwordInput = document.getElementById("passwordInput");
const usernameInput = document.getElementById("usernameInput");
const googleAuthButton = document.getElementById("googleAuthButton");
const splash = document.getElementById("splash");
const signInModal = document.getElementById("signInModal");
const dashboard = document.querySelector(".dashboard");
const signOutBtn = document.getElementById("signOutBtn");
const chat = document.getElementById("chat");
const aiInput = document.getElementById("aiInput");
const reminderText = document.getElementById("reminderText");
const reminderMinutes = document.getElementById("reminderMinutes");
const reminders = document.getElementById("reminders");
const task = document.getElementById("task");
const taskList = document.getElementById("taskList");
const gCost = document.getElementById("gCost");
const gMonths = document.getElementById("gMonths");
const buffer = document.getElementById("buffer");
const financeResult = document.getElementById("financeResult");
const mood = document.getElementById("mood");
const moodLogs = document.getElementById("moodLogs");
const waterGoalInput = document.getElementById("waterGoalInput");
const waterInput = document.getElementById("waterInput");
const waterProgress = document.getElementById("waterProgress");
const sleepInput = document.getElementById("sleepInput");
const sleepResult = document.getElementById("sleepResult");
const futureTask = document.getElementById("futureTask");
const timeMirror = document.getElementById("timeMirror");
const quoteDisplay = document.getElementById("quoteDisplay");
const gratitudeInput = document.getElementById("gratitudeInput");
const gratitudeLogs = document.getElementById("gratitudeLogs");
const dailyChallengeElement = document.getElementById("dailyChallenge");
const challengeResultElement = document.getElementById("challengeResult");
const importFileInput = document.getElementById("importFileInput");
const insightSummary = document.getElementById("insightSummary");
const moodStreakEl = document.getElementById("moodStreak");
const waterStreakEl = document.getElementById("waterStreak");
const gratitudeStreakEl = document.getElementById("gratitudeStreak");
const challengeStreakEl = document.getElementById("challengeStreak");
const wellnessScoreEl = document.getElementById("wellnessScore");
const wellnessStatusEl = document.getElementById("wellnessStatus");
const wellnessActionsEl = document.getElementById("wellnessActions");
const taskCompletionLabel = document.getElementById("taskCompletionLabel");
const taskCompletionBar = document.getElementById("taskCompletionBar");
const sleepAverageLabel = document.getElementById("sleepAverageLabel");
const sleepAverageBar = document.getElementById("sleepAverageBar");
const waterGoalLabel = document.getElementById("waterGoalLabel");
const waterGoalBar = document.getElementById("waterGoalBar");

// ---------- SPLASH + AUTH CHECK ----------
document.body.style.overflow = "hidden";
let splashRemoved = false;

function hideSplash() {
  if (splashRemoved || !splash) return;
  splash.classList.add("hide");
  setTimeout(() => {
    if (!splashRemoved) {
      splash.remove();
      splashRemoved = true;
      document.body.style.overflow = "auto";
    }
  }, 1000);
}

try {
  onAuthStateChanged(auth, (user) => {
    hideSplash();

    setTimeout(async () => {
      if (user) {
        const isEmailPasswordUser = user.providerData.some((provider) => provider.providerId === "password");
        if (isEmailPasswordUser && !user.emailVerified) {
          const error = document.getElementById("signInError");
          try {
            await sendEmailVerification(user);
          } catch (_) {}
          await signOut(auth);
          error.style.display = "block";
          error.innerText = "Please verify your email before signing in. A new verification email has been sent.";
          return;
        }

        dashboard.style.display = "grid";
        signOutBtn.style.display = "block";
        signInModal.style.display = "none";
        loadDailyChallenge(user.uid);
        loadMoods(user.uid);
        loadAiUsage(user.uid);
        loadAiChats(user.uid);
        loadTasks(user.uid);
        loadWaterData(user.uid);
        loadSleepData(user.uid);
        loadGratitude(user.uid);
        startDailyChallengeWatcher();
      } else {
        stopDailyChallengeWatcher();
        signInModal.style.display = "flex";
        dashboard.style.display = "none";
        signOutBtn.style.display = "none";
        moodLogs.innerHTML = "";
        chat.innerHTML = "";
        taskList.innerHTML = "";
        gratitudeLogs.innerHTML = "";
        waterProgress.innerText = "";
        sleepResult.innerText = "";
        wellnessScoreEl.innerText = "0/100";
        wellnessStatusEl.innerText = "Needs Focus";
        wellnessActionsEl.innerHTML = "<li>Log your first check-in for today.</li><li>Set your water target and drink one glass.</li><li>Add one gratitude note tonight.</li>";
        challengeResultElement.innerText = "";
        moodHistory.length = 0;
        waterHistory.length = 0;
        sleepHistory.length = 0;
        moodDates.length = 0;
        waterDates.length = 0;
        sleepDates.length = 0;
        taskEntries.length = 0;
        gratitudeEntries.length = 0;
        challengeDates.length = 0;
        dailyChallengeCompleted = false;
        currentChallengeDateKey = "";
        waterGoal = 0;
        aiUsageDateKeyGMT = "";
        aiUsageCount = 0;
        waterGoalInput.value = "";
      }
    }, 1000); // match your splash transition
  });
} catch (_) {
  setTimeout(() => {
    hideSplash();
    signInModal.style.display = "flex";
    dashboard.style.display = "none";
    signOutBtn.style.display = "none";
  }, 1000);
}

setTimeout(hideSplash, 2000);

// ---------- COLOR WAVES ----------
const waves = [
  ["#2196f3","#ff9800"],
  ["#9c27b0","#03a9f4"],
  ["#ff5722","#4caf50"],
  ["#3f51b5","#e91e63"],
  ["#009688","#ffc107"]
];
let w = 0;
function updateWave(){
  document.documentElement.style.setProperty("--waveA", waves[w][0]);
  document.documentElement.style.setProperty("--waveB", waves[w][1]);
  document.documentElement.style.setProperty("--primary", waves[w][0]);
  document.documentElement.style.setProperty("--accent", waves[w][1]);
  w = (w + 1) % waves.length;
}
updateWave();
setInterval(updateWave, 8000);

// ---------- SIGN-IN / SIGN-UP ----------
let authMode="signin";
function toggleAuth(){
  authMode=authMode==="signin"?"signup":"signin";
  const title=document.getElementById("modalTitle");
  const button=document.getElementById("actionButton");
  const toggleText=document.getElementById("toggleText");
  const error=document.getElementById("signInError");
  error.style.display="none";
  if(authMode==="signup"){
    title.innerText="Create a NovaFix Account üåü";
    button.innerText="Sign Up";
    googleAuthButton.innerText = "Sign Up with Google";
    toggleText.innerText="Already have an account? Sign In";
    usernameInput.style.display = "block";
  } else {
    title.innerText="Welcome to NovaFix üåü";
    button.innerText="Sign In";
    googleAuthButton.innerText = "Sign In with Google";
    toggleText.innerText="Don't have an account? Sign Up";
    usernameInput.style.display = "none";
  }
}

async function handleAuth() {
  const username = usernameInput.value.trim();
  const email = emailInput.value.trim();
  const password = passwordInput.value.trim();
  const error = document.getElementById("signInError");

  if (!email || !password) {
    error.style.display = "block";
    error.innerText = "Email and password are required!";
    return;
  }

  if (authMode === "signup" && !username) {
    error.style.display = "block";
    error.innerText = "Username is required for sign up!";
    return;
  }

  try {
    if (authMode === "signup") {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      await updateProfile(userCredential.user, { displayName: username });
      await sendEmailVerification(userCredential.user);
      await signOut(auth);
      error.style.display = "block";
      error.innerText = "Verification email sent. Please verify your email, then sign in.";
      return;
    } else {
      const userCredential = await signInWithEmailAndPassword(auth, email, password);
      if (!userCredential.user.emailVerified) {
        try {
          await sendEmailVerification(userCredential.user);
        } catch (_) {}
        await signOut(auth);
        error.style.display = "block";
        error.innerText = "Please verify your email before signing in. A new verification email has been sent.";
        return;
      }
    }
  } catch (err) {
    error.style.display = "block";
    error.innerText = err.message;
  }
}

function signOutUser() {
  signOut(auth);
}

async function handleGoogleAuth() {
  const error = document.getElementById("signInError");
  error.style.display = "none";

  if (window.location.protocol === "file:") {
    error.style.display = "block";
    error.innerText = "Google auth does not work on file://. Start a local server and open via http://localhost:<port>.";
    return;
  }

  try {
    await signInWithPopup(auth, googleProvider);
  } catch (err) {
    const currentOrigin = window.location.origin || "unknown-origin";
    const currentHost = window.location.hostname || "unknown-host";
    const isUnauthorizedDomain = (err?.code || "").includes("unauthorized-domain");
    error.style.display = "block";
    error.innerText = isUnauthorizedDomain
      ? `Unauthorized domain. Current origin: ${currentOrigin}. Add '${currentHost}' in Firebase Auth > Settings > Authorized domains, then hard refresh.`
      : (err.message || "Google authentication failed.");
  }
}

// ---------- DASHBOARD JS ----------
const moodHistory=[],waterHistory=[],sleepHistory=[];
const moodDates=[];
const waterDates=[];
const sleepDates=[];
const taskEntries=[];
const gratitudeEntries=[];
const aiRecentPrompts=[];
const challengeDates=[];
let dailyChallengeCompleted=false;
let currentChallengeText="";
let currentChallengeDateKey="";
let challengeWatcherInterval=null;
let insightsPersistTimer=null;
const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || "local";
const FIRESTORE_CRASH_MESSAGE = "Something went wrong. Please try again later.";
const AI_DAILY_LIMIT = 20;
let aiUsageDateKeyGMT = "";
let aiUsageCount = 0;
let lastFirestoreErrorAlertAt = 0;

function notifyFirestoreError(err) {
  console.error("Firestore operation failed:", err);
  const now = Date.now();
  if (now - lastFirestoreErrorAlertAt > 4000) {
    alert(FIRESTORE_CRASH_MESSAGE);
    lastFirestoreErrorAlertAt = now;
  }
}

function dateToKey(dateValue) {
  const date = dateValue instanceof Date ? dateValue : new Date(dateValue);
  if (Number.isNaN(date.getTime())) return null;
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

function calcStreak(dateValues) {
  const daySet = new Set(
    dateValues
      .map((value) => dateToKey(value))
      .filter(Boolean)
  );

  let streak = 0;
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  while (true) {
    const dayKey = dateToKey(today);
    if (!daySet.has(dayKey)) break;
    streak++;
    today.setDate(today.getDate() - 1);
  }

  return streak;
}

function setInsightBar(element, percent) {
  const bounded = Math.max(0, Math.min(100, percent));
  element.style.width = `${bounded}%`;
}

function dateKeyToDate(dateKey) {
  if (!dateKey || typeof dateKey !== "string") return null;
  const [year, month, day] = dateKey.split("-").map(Number);
  if (!year || !month || !day) return null;
  const parsed = new Date(year, month - 1, day, 12, 0, 0, 0);
  return Number.isNaN(parsed.getTime()) ? null : parsed;
}

function pickChallengeForDate(dateKey) {
  const sum = [...dateKey].reduce((total, char) => total + char.charCodeAt(0), 0);
  return dailyChallenges[sum % dailyChallenges.length];
}

function queueInsightsPersist(payload) {
  if (insightsPersistTimer) clearTimeout(insightsPersistTimer);
  insightsPersistTimer = setTimeout(async () => {
    const user = auth.currentUser;
    if (!user) return;
    try {
      await setDoc(doc(db, "users", user.uid, "insights", "current"), {
        ...payload,
        updatedAt: serverTimestamp()
      }, { merge: true });
    } catch (err) {
      notifyFirestoreError(err);
    }
  }, 350);
}

function getTodayKey() {
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: userTimeZone,
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  });
  return formatter.format(new Date());
}

function getTodayKeyGMT() {
  return new Date().toISOString().slice(0, 10);
}

async function saveAiUsage(userId) {
  try {
    await setDoc(doc(db, "users", userId, "settings", "aiUsage"), {
      dateKeyGMT: aiUsageDateKeyGMT,
      count: aiUsageCount,
      updatedAt: serverTimestamp()
    }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadAiUsage(userId) {
  aiUsageDateKeyGMT = getTodayKeyGMT();
  aiUsageCount = 0;

  try {
    const snapshot = await getDoc(doc(db, "users", userId, "settings", "aiUsage"));
    if (snapshot.exists()) {
      const data = snapshot.data();
      if (data.dateKeyGMT === aiUsageDateKeyGMT) {
        aiUsageCount = Number(data.count) || 0;
      } else {
        aiUsageCount = 0;
        await saveAiUsage(userId);
      }
    } else {
      await saveAiUsage(userId);
    }
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function ensureAiUsageCurrent(userId) {
  const todayKeyGMT = getTodayKeyGMT();
  if (aiUsageDateKeyGMT !== todayKeyGMT) {
    aiUsageDateKeyGMT = todayKeyGMT;
    aiUsageCount = 0;
    await saveAiUsage(userId);
  }
}

function startDailyChallengeWatcher() {
  if (challengeWatcherInterval) clearInterval(challengeWatcherInterval);
  challengeWatcherInterval = setInterval(async () => {
    const user = auth.currentUser;
    if (!user) return;
    const todayKey = getTodayKey();
    if (todayKey !== currentChallengeDateKey) {
      await loadDailyChallenge(user.uid);
    }
  }, 30000);
}

function stopDailyChallengeWatcher() {
  if (challengeWatcherInterval) {
    clearInterval(challengeWatcherInterval);
    challengeWatcherInterval = null;
  }
}

function updateWellnessScore() {
  const todayKey = getTodayKey();

  const waterToday = waterHistory.reduce((sum, value, index) => {
    const dateKey = dateToKey(waterDates[index]);
    return dateKey === todayKey ? sum + value : sum;
  }, 0);
  const effectiveWaterGoal = waterGoal > 0 ? waterGoal : 8;
  const waterRatio = Math.min(1, waterToday / effectiveWaterGoal);
  const waterPoints = Math.round(waterRatio * 30);

  const sleepToday = sleepHistory.reduce((lastValue, value, index) => {
    const dateKey = dateToKey(sleepDates[index]);
    return dateKey === todayKey ? value : lastValue;
  }, 0);
  const sleepRatio = Math.min(1, sleepToday / 8);
  const sleepPoints = Math.round(sleepRatio * 25);

  const moodToday = moodHistory.reduce((lastMood, value, index) => {
    const dateKey = dateToKey(moodDates[index]);
    return dateKey === todayKey ? value : lastMood;
  }, "");
  const moodFactor = moodToday.includes("üòä") ? 1 : moodToday.includes("üòê") ? 0.65 : moodToday.includes("üòî") ? 0.3 : 0;
  const moodPoints = Math.round(moodFactor * 20);

  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const taskRatio = totalTasks ? doneTasks / totalTasks : 0;
  const taskPoints = Math.round(taskRatio * 15);

  const hasGratitudeToday = gratitudeEntries.some((entry) => dateToKey(entry.time) === todayKey);
  const gratitudePoints = hasGratitudeToday ? 10 : 0;
  const challengePoints = dailyChallengeCompleted ? 10 : 0;

  const totalScore = Math.max(0, Math.min(100, waterPoints + sleepPoints + moodPoints + taskPoints + gratitudePoints + challengePoints));

  wellnessScoreEl.innerText = `${totalScore}/100`;

  let status = "Needs Focus";
  if (totalScore >= 80) status = "Excellent";
  else if (totalScore >= 60) status = "Good";
  wellnessStatusEl.innerText = status;

  const actions = [];
  if (waterRatio < 1) {
    const remaining = Math.max(0, effectiveWaterGoal - waterToday);
    actions.push(`Drink ${remaining} more glass${remaining === 1 ? "" : "es"} to hit your goal.`);
  }
  if (sleepToday < 7) actions.push("Aim for at least 7‚Äì8 hours of sleep tonight.");
  if (!moodToday) actions.push("Log your mood for today.");
  else if (moodToday.includes("üòî")) actions.push("Take a 10-minute breathing or walk break.");
  if (taskRatio < 0.7) actions.push("Complete one pending task to boost productivity.");
  if (!hasGratitudeToday) actions.push("Write one gratitude note before the day ends.");
  if (!dailyChallengeCompleted) actions.push("Complete today‚Äôs daily challenge for an extra score boost.");

  while (actions.length < 3) actions.push("Keep your current streak alive with one small check-in.");
  wellnessActionsEl.innerHTML = actions.slice(0, 3).map((item) => `<li>${item}</li>`).join("");
}

function updateInsights() {
  const moodStreak = calcStreak(moodDates);
  const waterStreak = calcStreak(waterDates);
  const gratitudeStreak = calcStreak(gratitudeEntries.map((entry) => entry.time));
  const challengeStreak = calcStreak(challengeDates);

  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const taskCompletion = totalTasks ? Math.round((doneTasks / totalTasks) * 100) : 0;

  const avgSleep = sleepHistory.length
    ? sleepHistory.reduce((a, b) => a + b, 0) / sleepHistory.length
    : 0;
  const sleepPercent = Math.round(Math.min(100, (avgSleep / 8) * 100));

  const waterSum = waterHistory.reduce((a, b) => a + b, 0);
  const waterPercent = waterGoal > 0 ? Math.round((waterSum / waterGoal) * 100) : 0;

  moodStreakEl.innerText = `Mood streak: ${moodStreak} day${moodStreak === 1 ? "" : "s"}`;
  waterStreakEl.innerText = `Water streak: ${waterStreak} day${waterStreak === 1 ? "" : "s"}`;
  gratitudeStreakEl.innerText = `Gratitude streak: ${gratitudeStreak} day${gratitudeStreak === 1 ? "" : "s"}`;
  challengeStreakEl.innerText = `Challenge streak: ${challengeStreak} day${challengeStreak === 1 ? "" : "s"}`;

  taskCompletionLabel.innerText = `Productivity task completion: ${taskCompletion}% (${doneTasks}/${totalTasks})`;
  sleepAverageLabel.innerText = `Avg sleep: ${avgSleep.toFixed(1)} hrs`;
  waterGoalLabel.innerText = `Water goal progress: ${waterPercent}%`;

  setInsightBar(taskCompletionBar, taskCompletion);
  setInsightBar(sleepAverageBar, sleepPercent);
  setInsightBar(waterGoalBar, waterPercent);

  const strongest = [
    { label: "mood", value: moodStreak },
    { label: "water", value: waterStreak },
    { label: "gratitude", value: gratitudeStreak },
    { label: "challenge", value: challengeStreak }
  ].sort((a, b) => b.value - a.value)[0];

  insightSummary.innerText = strongest.value > 0
    ? `Great momentum in ${strongest.label} tracking. Keep the streak alive today!`
    : "Start logging today to build your first streak and unlock deeper insights.";

  updateWellnessScore();

  const currentScore = Number((wellnessScoreEl?.innerText || "0/100").split("/")[0]) || 0;
  queueInsightsPersist({
    moodStreak,
    waterStreak,
    gratitudeStreak,
    challengeStreak,
    taskCompletion,
    avgSleep: Number(avgSleep.toFixed(1)),
    waterGoalProgress: waterPercent,
    wellnessScore: currentScore,
    wellnessStatus: wellnessStatusEl.innerText || "Needs Focus",
    dailyChallengeCompleted,
    dailyChallenge: currentChallengeText || ""
  });
}

// AI Companion
function escapeHtml(text) {
  return text
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function getUserName(user) {
  if (user?.displayName && user.displayName.trim()) return user.displayName.trim();
  if (user?.email) return user.email.split("@")[0];
  return "there";
}

function rememberPrompt(promptText) {
  if (!promptText) return;
  aiRecentPrompts.push(promptText);
  if (aiRecentPrompts.length > 6) aiRecentPrompts.shift();
}

function getTodayWater() {
  const todayKey = getTodayKey();
  return waterHistory.reduce((sum, value, index) => {
    const dateKey = dateToKey(waterDates[index]);
    return dateKey === todayKey ? sum + value : sum;
  }, 0);
}

function getTodayMood() {
  const todayKey = getTodayKey();
  return moodHistory.reduce((lastMood, value, index) => {
    const dateKey = dateToKey(moodDates[index]);
    return dateKey === todayKey ? value : lastMood;
  }, "");
}

function getTodaySleep() {
  const todayKey = getTodayKey();
  return sleepHistory.reduce((lastSleep, value, index) => {
    const dateKey = dateToKey(sleepDates[index]);
    return dateKey === todayKey ? value : lastSleep;
  }, 0);
}

function getWellnessSnapshot() {
  const waterToday = getTodayWater();
  const todayGoal = waterGoal > 0 ? waterGoal : 8;
  const moodToday = getTodayMood();
  const sleepToday = getTodaySleep();
  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const pendingTasks = taskEntries.filter((entry) => !entry.completed).length;
  const gratitudeToday = gratitudeEntries.some((entry) => dateToKey(entry.time) === getTodayKey());
  const score = Number((wellnessScoreEl?.innerText || "0/100").split("/")[0]) || 0;

  return {
    waterToday,
    todayGoal,
    moodToday,
    sleepToday,
    totalTasks,
    doneTasks,
    pendingTasks,
    gratitudeToday,
    score
  };
}

async function tryAiAction(input) {
  const msg = input.trim();
  const lower = msg.toLowerCase();

  const taskMatch = msg.match(/^(add|create)\s+(a\s+)?task\s*[:\-]?\s*(.+)$/i);
  if (taskMatch && taskMatch[3]) {
    task.value = taskMatch[3].trim();
    await addTask();
    return `‚úÖ Added task: ${taskMatch[3].trim()}`;
  }

  const waterGoalMatch = lower.match(/(?:set|update)\s+(?:my\s+)?water\s+goal\s+(?:to\s+)?(\d+)/i);
  if (waterGoalMatch) {
    waterGoalInput.value = String(Number(waterGoalMatch[1]) || 0);
    await setWaterGoal();
    return `‚úÖ Water goal updated to ${waterGoalInput.value} glasses.`;
  }

  const waterLogMatch = lower.match(/(?:log|add|track)\s+(\d+)\s*(?:glass|glasses)\s*(?:of\s+water)?/i);
  if (waterLogMatch) {
    waterInput.value = String(Number(waterLogMatch[1]) || 0);
    await saveWater();
    return `‚úÖ Logged ${waterInput.value || waterLogMatch[1]} glasses of water.`;
  }

  const sleepMatch = lower.match(/(?:log|save|track)\s+sleep\s+(?:for\s+)?(\d+(?:\.\d+)?)\s*(?:h|hr|hrs|hour|hours)?/i);
  if (sleepMatch) {
    sleepInput.value = sleepMatch[1];
    await saveSleep();
    return `‚úÖ Sleep logged: ${sleepMatch[1]} hours.`;
  }

  const moodMatch = lower.match(/(?:log|set|save)\s+mood\s+(happy|neutral|low)/i);
  if (moodMatch) {
    const map = { happy: "üòä Happy", neutral: "üòê Neutral", low: "üòî Low" };
    mood.value = map[moodMatch[1]] || mood.value;
    await saveMood();
    return `‚úÖ Mood logged: ${mood.value}`;
  }

  const gratitudeMatch = msg.match(/^(?:add|log|save)\s+gratitude\s*[:\-]?\s*(.+)$/i);
  if (gratitudeMatch && gratitudeMatch[1]) {
    gratitudeInput.value = gratitudeMatch[1].trim();
    await saveGratitude();
    return `‚úÖ Gratitude saved.`;
  }

  const reminderMatch = msg.match(/^remind\s+me\s+to\s+(.+)\s+in\s+(\d+)\s*(m|min|mins|minute|minutes)$/i);
  if (reminderMatch) {
    reminderText.value = reminderMatch[1].trim();
    reminderMinutes.value = String(Number(reminderMatch[2]) || 0);
    addReminder();
    return `‚úÖ Reminder set: ${reminderMatch[1].trim()} in ${reminderMatch[2]} min.`;
  }

  return null;
}

async function buildSmartAiResponse(input, user) {
  const actionResult = await tryAiAction(input);
  if (actionResult) {
    return {
      response: `${actionResult}<br>ü§ñ I can also run more actions: <i>add task ..., set water goal 8, log mood happy, log sleep 7, remind me to ... in 20 min</i>.`,
      isHtml: true
    };
  }

  const msg = input.toLowerCase();
  const name = getUserName(user);
  const hour = new Date().getHours();
  const greeting = hour < 12 ? "Good morning" : hour < 18 ? "Good afternoon" : "Good evening";
  const snapshot = getWellnessSnapshot();
  const recentContext = aiRecentPrompts.slice(-3).join(" ‚Ä¢ ");

  const isGreeting = /\b(hi|hello|hey|yo|hola)\b/.test(msg);
  const asksIdentity = /who are you|what are you/.test(msg);
  const asksAnalysis = /analyze|analysis|report|conclude|insight|summary|score/.test(msg);
  const asksPlan = /plan|routine|today|schedule|what should i do/.test(msg);
  const stressSignal = /stress|anxious|anxiety|overwhelm|panic|sad|low|depressed|down/.test(msg);
  const sleepSignal = /sleep|tired|exhausted|fatigue|insomnia/.test(msg);
  const waterSignal = /water|hydrate|hydration|thirsty/.test(msg);
  const productivitySignal = /task|focus|productivity|procrastin|work|study/.test(msg);
  const gratitudeSignal = /gratitude|thankful|grateful/.test(msg);
  const capabilitySignal = /help|what can you do|features|assist|commands/.test(msg);

  if (isGreeting) {
    const pending = snapshot.pendingTasks;
    const waterLeft = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
    return {
      response: `${greeting}, ${name}! üåü Quick check: score ${snapshot.score}/100, ${pending} pending task${pending === 1 ? "" : "s"}, ${waterLeft} glass${waterLeft === 1 ? "" : "es"} left for hydration. Want an execution plan for the next 60 minutes?`,
      isHtml: false
    };
  }

  if (asksIdentity) {
    return {
      response: "I‚Äôm your NovaFix coach ü§ñ I read your live dashboard data, remember recent context, and can execute logging actions directly from chat.",
      isHtml: false
    };
  }

  if (asksAnalysis) {
    const waterPct = Math.round((snapshot.waterToday / snapshot.todayGoal) * 100);
    const taskPct = snapshot.totalTasks ? Math.round((snapshot.doneTasks / snapshot.totalTasks) * 100) : 0;
    const moodText = snapshot.moodToday || "Not logged";

    let actions = [];
    if (snapshot.waterToday < snapshot.todayGoal) actions.push(`Drink ${Math.max(0, snapshot.todayGoal - snapshot.waterToday)} more glass${snapshot.todayGoal - snapshot.waterToday === 1 ? "" : "es"}.`);
    if (snapshot.sleepToday < 7) actions.push("Target 7‚Äì8 hours sleep tonight.");
    if (snapshot.pendingTasks > 0) actions.push("Finish 1 pending task in the next 25 minutes.");
    if (!snapshot.gratitudeToday) actions.push("Add one gratitude line before bed.");
    if (!snapshot.moodToday) actions.push("Log your mood to improve prediction quality.");
    while (actions.length < 3) actions.push("Keep momentum with one small healthy action now.");

    return {
      response: `üìä <b>Deep Wellness Analysis</b><br>‚≠ê Score: <b>${snapshot.score}/100</b><br>üíß Water: ${snapshot.waterToday}/${snapshot.todayGoal} (${Math.max(0, waterPct)}%)<br>üí§ Sleep today: ${snapshot.sleepToday || 0} hrs<br>üßò Mood: ${moodText}<br>üìå Tasks done: ${snapshot.doneTasks}/${snapshot.totalTasks} (${taskPct}%)<br>üôè Gratitude today: ${snapshot.gratitudeToday ? "Yes" : "No"}<br><br><b>Best next moves</b><br>1) ${actions[0]}<br>2) ${actions[1]}<br>3) ${actions[2]}${recentContext ? `<br><br>üß† Recent context: <i>${escapeHtml(recentContext)}</i>` : ""}`,
      isHtml: true
    };
  }

  if (asksPlan) {
    const planItems = [
      snapshot.pendingTasks > 0 ? `00‚Äì25 min: pick 1 pending task and do deep focus.` : "00‚Äì25 min: define one meaningful task.",
      snapshot.waterToday < snapshot.todayGoal ? `25‚Äì30 min: drink ${Math.max(1, snapshot.todayGoal - snapshot.waterToday)} glass(es) and quick reset.` : "25‚Äì30 min: quick reset and stretch.",
      snapshot.sleepToday < 7 ? "30‚Äì50 min: finish key work and set wind-down reminder." : "30‚Äì50 min: complete second priority task.",
      snapshot.gratitudeToday ? "50‚Äì60 min: reflection note + next action." : "50‚Äì60 min: write one gratitude line + next action."
    ];
    return {
      response: `üóÇÔ∏è <b>Your 60-min execution plan</b><br>‚Ä¢ ${planItems[0]}<br>‚Ä¢ ${planItems[1]}<br>‚Ä¢ ${planItems[2]}<br>‚Ä¢ ${planItems[3]}`,
      isHtml: true
    };
  }

  if (stressSignal) {
    return {
      response: `I hear you, ${name}. Let‚Äôs use a fast reset: 6 breathing rounds (4-4-6), drink water, then do one 10-minute micro-task. Reply ‚Äústart reset‚Äù and I‚Äôll guide step-by-step.`,
      isHtml: false
    };
  }

  if (sleepSignal) {
    return {
      response: `Sleep protocol: no caffeine after 2 PM, dim lights 60 min pre-bed, and no scrolling in bed. Latest logged sleep: ${snapshot.sleepToday || (sleepHistory[sleepHistory.length-1] || 0)} hrs.`,
      isHtml: false
    };
  }

  if (waterSignal) {
    const left = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
    return {
      response: `Hydration check üíß You‚Äôre at ${snapshot.waterToday}/${snapshot.todayGoal}. Remaining: ${left} glass${left === 1 ? "" : "es"}. Want me to set a reminder right now?`,
      isHtml: false
    };
  }

  if (productivitySignal) {
    return {
      response: `Focus mode ‚ö° Completed ${snapshot.doneTasks}/${snapshot.totalTasks}. Try: pick one pending task, 25-min timer, then 5-min break. Say ‚Äúadd task ‚Ä¶‚Äù and I‚Äôll add it instantly.`,
      isHtml: false
    };
  }

  if (gratitudeSignal) {
    return {
      response: "Gratitude prompt: ‚ÄòOne small thing that made today easier was‚Ä¶‚Äô Want me to save your line now? Say: add gratitude <your text> üôè",
      isHtml: false
    };
  }

  if (capabilitySignal) {
    return {
      response: "I can analyze wellness, create plans, coach stress/sleep/focus, and execute commands. Try: add task..., set water goal 8, log mood happy, log sleep 7, add gratitude..., remind me to ... in 20 min.",
      isHtml: false
    };
  }

  return {
    response: "I can either coach or take action. If you want actions, use commands like: add task..., log sleep 7, set water goal 8, add gratitude..., remind me to ... in 10 min.",
    isHtml: false
  };
}

function setChatText(textNode, text, isHtml) {
  if (isHtml) textNode.innerHTML = text;
  else textNode.textContent = text;
}

function renderChatMessage(role, messageText, isHtml, chatId, fieldName) {
  const row = document.createElement("div");
  row.className = "chat-message";

  const textNode = document.createElement("div");
  textNode.className = "chat-text";
  textNode.dataset.rawText = messageText;
  setChatText(textNode, `${role === "user" ? "You" : "AI"}: ${messageText}`, isHtml);

  row.append(textNode);

  if (role === "user") {
    const editBtn = document.createElement("button");
    editBtn.className = "chat-edit-btn";
    editBtn.textContent = "Edit";
    editBtn.onclick = () => editChatMessage(chatId, fieldName, textNode, role);
    row.append(editBtn);
  }

  chat.appendChild(row);
  chat.scrollTop = chat.scrollHeight;
}

async function editChatMessage(chatId, fieldName, textNode, role) {
  const currentText = textNode.dataset.rawText || "";
  const updatedText = prompt("Edit message", currentText);
  if (updatedText === null) return;

  const nextText = updatedText.trim();
  if (!nextText) {
    alert("Message cannot be empty.");
    return;
  }

  textNode.dataset.rawText = nextText;
  setChatText(textNode, `${role === "user" ? "You" : "AI"}: ${nextText}`, false);

  const user = auth.currentUser;
  if (!user || !chatId) return;

  try {
    const payload = { [fieldName]: nextText };
    if (fieldName === "aiResponse") payload.aiResponseIsHtml = false;
    await updateDoc(doc(db, "users", user.uid, "aiChats", chatId), payload);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function renderChatPair(entry) {
  renderChatMessage("user", entry.userMessage || "", false, entry.id, "userMessage");
  renderChatMessage("ai", entry.aiResponse || "", !!entry.aiResponseIsHtml, entry.id, "aiResponse");
}

async function loadAiChats(userId) {
  chat.innerHTML = "";
  aiRecentPrompts.length = 0;

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "aiChats"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.createdAt?.toMillis?.() ?? new Date(a.createdAt || 0).getTime();
        const bTime = b.createdAt?.toMillis?.() ?? new Date(b.createdAt || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      if (entry.userMessage) rememberPrompt(entry.userMessage);
      renderChatPair(entry);
    });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function storeAiChat(userId, userMessage, aiResponse, aiResponseIsHtml) {
  try {
    const ref = await addDoc(
      collection(db, "users", userId, "aiChats"),
      {
        userMessage,
        aiResponse,
        aiResponseIsHtml,
        createdAt: serverTimestamp()
      }
    );
    return ref.id;
  } catch (err) {
    notifyFirestoreError(err);
    return null;
  }
}

async function clearAiChats() {
  const user = auth.currentUser;
  if (!user) return;
  if (!confirm("Clear all AI conversations?")) return;

  try {
    const snapshot = await getDocs(collection(db, "users", user.uid, "aiChats"));
    await Promise.all(snapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
    chat.innerHTML = "";
    aiRecentPrompts.length = 0;
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function aiChat(){
  const input = aiInput.value.trim();
  if(!input) return;
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  await ensureAiUsageCurrent(user.uid);
  if (aiUsageCount >= AI_DAILY_LIMIT) {
    renderChatMessage("ai", "Daily AI limit reached", false, null, null);
    aiInput.value = "";
    return;
  }

  const smart = await buildSmartAiResponse(input, user);
  const response = smart.response;
  const responseIsHtml = smart.isHtml;
  rememberPrompt(input);

  const chatId = await storeAiChat(user.uid, input, response, responseIsHtml);
  renderChatPair({
    id: chatId,
    userMessage: input,
    aiResponse: response,
    aiResponseIsHtml: responseIsHtml
  });
  aiUsageCount += 1;
  await saveAiUsage(user.uid);
  aiInput.value="";
}

// Reminders
function addReminder() {
  const t = reminderText.value.trim();
  const m = +reminderMinutes.value;
  if (!t || m <= 0) return;

  const li = document.createElement("li");
  reminders.appendChild(li);
  let s = m * 60;

  const audio = document.getElementById("reminderSound");

  const i = setInterval(() => {
    if (s <= 0) {
      clearInterval(i);
      li.textContent = `${t} ‚Äì Time's up!`;
      if(audio) audio.play(); // üîä Play your custom sound
      return;
    }
    li.textContent = `${t} ‚Äì ${Math.floor(s / 60)}m ${s % 60}s`;
    s--;
  }, 1000);

  reminderText.value = "";
  reminderMinutes.value = "";
}

// Tasks
function renderTask(entry) {
  const li = document.createElement("li");
  const span = document.createElement("span");
  span.textContent = entry.text;
  if (entry.completed) span.classList.add("task-done");

  const toggleBtn = document.createElement("button");
  toggleBtn.textContent = entry.completed ? "‚úÖ" : "‚¨ú";
  toggleBtn.title = "Toggle complete";
  toggleBtn.onclick = async () => {
    entry.completed = !entry.completed;
    span.classList.toggle("task-done", entry.completed);
    toggleBtn.textContent = entry.completed ? "‚úÖ" : "‚¨ú";

    const listIndex = taskEntries.findIndex((taskItem) => taskItem.id === entry.id);
    if (listIndex >= 0) taskEntries[listIndex].completed = entry.completed;
    updateInsights();

    const user = auth.currentUser;
    if (!user || !entry.id) return;
    try {
      await updateDoc(doc(db, "users", user.uid, "tasks", entry.id), { completed: entry.completed });
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  const editBtn = document.createElement("button");
  editBtn.textContent = "‚úèÔ∏è";
  editBtn.onclick = async () => {
    const newText = prompt("Edit task", span.textContent);
    if (!newText || !newText.trim()) return;
    span.textContent = newText.trim();

    const user = auth.currentUser;
    if (!user || !entry.id) return;
    try {
      await updateDoc(doc(db, "users", user.uid, "tasks", entry.id), { text: newText.trim() });
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  const deleteBtn = document.createElement("button");
  deleteBtn.textContent = "üóëÔ∏è";
  deleteBtn.onclick = async () => {
    const user = auth.currentUser;
    if (!user || !entry.id) {
      const fallbackIndex = taskEntries.findIndex((taskItem) => taskItem.id === entry.id);
      if (fallbackIndex >= 0) taskEntries.splice(fallbackIndex, 1);
      updateInsights();
      li.remove();
      return;
    }
    try {
      await deleteDoc(doc(db, "users", user.uid, "tasks", entry.id));
      const listIndex = taskEntries.findIndex((taskItem) => taskItem.id === entry.id);
      if (listIndex >= 0) taskEntries.splice(listIndex, 1);
      updateInsights();
      li.remove();
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  li.append(span, toggleBtn, editBtn, deleteBtn);
  taskList.appendChild(li);
}

async function loadTasks(userId) {
  taskList.innerHTML = "";
  taskEntries.length = 0;
  try {
    const snapshot = await getDocs(collection(db, "users", userId, "tasks"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });
    docs.forEach((entry) => {
      const normalized = {
        ...entry,
        completed: !!entry.completed
      };
      taskEntries.push(normalized);
      renderTask(normalized);
    });
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function addTask(){
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const t=task.value.trim();
  if(!t)return;

  try {
    const ref = await addDoc(collection(db, "users", user.uid, "tasks"), {
      text: t,
      completed: false,
      time: serverTimestamp()
    });
    const newTask = { id: ref.id, text: t, completed: false, time: new Date() };
    taskEntries.push(newTask);
    renderTask(newTask);
    updateInsights();
    task.value="";
  } catch (err) {
    notifyFirestoreError(err);
  }
}

// Finance
function calculateFinance(){
  const cost = parseFloat(gCost.value) || 0;
  const months = parseFloat(gMonths.value) || 1;
  const buf = parseFloat(buffer.value) || 0;

  const total = cost * months * (1 + buf/100);
  const monthly = total / months;

  financeResult.innerText = `Total: ‚Çπ${total.toFixed(0)} | Monthly: ‚Çπ${monthly.toFixed(0)}`;
}

// Mood
function renderMoodLog(entry) {
  const moodRow = document.createElement("div");
  moodRow.className = "mood-item";

  const moodLabel = document.createElement("span");
  const rawTime = entry.time?.toDate?.() ?? new Date(entry.time || Date.now());
  moodLabel.textContent = `${rawTime.toLocaleTimeString()} - ${entry.mood}`;

  const removeBtn = document.createElement("button");
  removeBtn.className = "mood-remove";
  removeBtn.textContent = "Remove";
  removeBtn.onclick = () => deleteMoodLog(entry.id, moodRow, entry.mood);

  moodRow.append(moodLabel, removeBtn);
  moodLogs.appendChild(moodRow);
}

async function deleteMoodLog(moodId, moodElement, moodValue) {
  const user = auth.currentUser;
  if (!user || !moodId) return;

  try {
    await deleteDoc(doc(db, "users", user.uid, "moods", moodId));
    moodElement.remove();
    const moodIndex = moodHistory.findIndex((m) => m === moodValue);
    if (moodIndex >= 0) moodHistory.splice(moodIndex, 1);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadMoods(userId) {
  moodLogs.innerHTML = "";
  moodHistory.length = 0;
  moodDates.length = 0;

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "moods"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      moodHistory.push(entry.mood);
      const moodTime = entry.time?.toDate?.() ?? new Date(entry.time || Date.now());
      moodDates.push(moodTime);
      renderMoodLog(entry);
    });
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveMood() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const moodValue = mood.value;

  try {
    const moodRef = await addDoc(
      collection(db, "users", user.uid, "moods"),
      {
        mood: moodValue,
        uid: user.uid,
        email: user.email || null,
        time: serverTimestamp()
      }
    );

    moodHistory.push(moodValue);
    moodDates.push(new Date());
    renderMoodLog({ id: moodRef.id, mood: moodValue, time: new Date() });
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

// Water
let waterGoal=0;
function updateWaterProgress() {
  const sum = waterHistory.reduce((a, b) => a + b, 0);
  const percent = waterGoal > 0 ? Math.round((sum / waterGoal) * 100) : 0;
  waterProgress.innerText = `${sum}/${waterGoal} (${percent}%)`;
  updateInsights();
}

async function setWaterGoal(){
  const user = auth.currentUser;
  waterGoal = +waterGoalInput.value || 0;
  updateWaterProgress();

  if (waterGoal > 0) {
    alert(`‚úÖ Water goal set to ${waterGoal} glasses.`);
  } else {
    alert("‚ÑπÔ∏è Water goal cleared.");
  }

  if (!user) return;
  try {
    await setDoc(doc(db, "users", user.uid, "settings", "water"), { goal: waterGoal }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadWaterData(userId) {
  waterHistory.length = 0;
  waterDates.length = 0;

  try {
    const waterSettings = await getDoc(doc(db, "users", userId, "settings", "water"));
    waterGoal = waterSettings.exists() ? (waterSettings.data().goal || 0) : 0;
    waterGoalInput.value = waterGoal || "";

    const snapshot = await getDocs(collection(db, "users", userId, "waterIntake"));
    const docs = snapshot.docs
      .map((docSnap) => docSnap.data())
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      if (entry.glasses) {
        waterHistory.push(entry.glasses);
        const waterTime = entry.time?.toDate?.() ?? new Date(entry.time || Date.now());
        waterDates.push(waterTime);
      }
    });

    updateWaterProgress();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveWater() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const v = +waterInput.value;
  if (!v) return; // ignore empty or 0 input

  waterHistory.push(v);

  try {
    await addDoc(collection(db, "users", user.uid, "waterIntake"), {
      glasses: v,
      time: serverTimestamp()
    });
    waterDates.push(new Date());
    updateWaterProgress();
    waterInput.value = "";
  } catch (err) {
    notifyFirestoreError(err);
  }
}

// Sleep
async function loadSleepData(userId) {
  sleepHistory.length = 0;
  sleepDates.length = 0;
  sleepResult.innerText = "";

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "sleepLogs"));
    const docs = snapshot.docs
      .map((docSnap) => docSnap.data())
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      if (entry.hours) {
        sleepHistory.push(entry.hours);
        const sleepTime = entry.time?.toDate?.() ?? new Date(entry.time || Date.now());
        sleepDates.push(sleepTime);
      }
    });

    if (sleepHistory.length) {
      const latest = sleepHistory[sleepHistory.length - 1];
      sleepResult.innerText = `${latest} hrs üí§`;
    }
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveSleep(){
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const hours = +sleepInput.value;
  if (!hours) return;

  sleepHistory.push(hours);
  sleepDates.push(new Date());
  sleepResult.innerText = `${hours} hrs üí§`;
  updateInsights();

  try {
    await addDoc(collection(db, "users", user.uid, "sleepLogs"), {
      hours,
      time: serverTimestamp()
    });
    sleepInput.value = "";
  } catch (err) {
    notifyFirestoreError(err);
  }
}

// Time Mirror
function timeTraveller(){const task=futureTask.value.trim();if(!task)return alert("Enter a task or goal.");timeMirror.innerHTML=`<p>‚ú® Future if you do it: You feel accomplished and energized after completing "${task}". üí™</p><p>üí§ Future if you skip it: You feel regret and a missed opportunity after ignoring "${task}". üòî</p>`;futureTask.value=""}

// Quotes
const quotes=["üå± 'The journey of a thousand miles begins with one step.' ‚Äì Lao Tzu","üí™ 'Your body can stand almost anything. It‚Äôs your mind that you have to convince.'","‚òÄÔ∏è 'Every morning we are born again. What we do today matters most.' ‚Äì Buddha","üåü 'Success is the sum of small efforts repeated day in and day out.' ‚Äì Robert Collier","üßò 'Happiness is not something ready-made. It comes from your own actions.' ‚Äì Dalai Lama","üî• 'Don‚Äôt watch the clock; do what it does. Keep going.' ‚Äì Sam Levenson"];
function newQuote(){quoteDisplay.innerText=quotes[Math.floor(Math.random()*quotes.length)];}
newQuote();

// Gratitude
function renderGratitude(entry) {
  const row = document.createElement("div");
  const rawTime = entry.time?.toDate?.() ?? new Date(entry.time || Date.now());

  const label = document.createElement("span");
  label.textContent = `${rawTime.toLocaleTimeString()} - ${entry.text}`;

  const editBtn = document.createElement("button");
  editBtn.textContent = "‚úèÔ∏è";
  editBtn.onclick = async () => {
    const nextText = prompt("Edit gratitude", entry.text || "");
    if (!nextText || !nextText.trim()) return;

    const user = auth.currentUser;
    if (!user || !entry.id) return;

    try {
      await updateDoc(doc(db, "users", user.uid, "gratitudeLogs", entry.id), {
        text: nextText.trim()
      });
      entry.text = nextText.trim();
      label.textContent = `${rawTime.toLocaleTimeString()} - ${entry.text}`;
      const listIndex = gratitudeEntries.findIndex((item) => item.id === entry.id);
      if (listIndex >= 0) gratitudeEntries[listIndex].text = entry.text;
      updateInsights();
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  const deleteBtn = document.createElement("button");
  deleteBtn.textContent = "üóëÔ∏è";
  deleteBtn.onclick = async () => {
    const user = auth.currentUser;
    if (!user || !entry.id) {
      const fallbackIndex = gratitudeEntries.findIndex((item) => item.id === entry.id);
      if (fallbackIndex >= 0) gratitudeEntries.splice(fallbackIndex, 1);
      updateInsights();
      row.remove();
      return;
    }

    try {
      await deleteDoc(doc(db, "users", user.uid, "gratitudeLogs", entry.id));
      const listIndex = gratitudeEntries.findIndex((item) => item.id === entry.id);
      if (listIndex >= 0) gratitudeEntries.splice(listIndex, 1);
      updateInsights();
      row.remove();
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  row.append(label, editBtn, deleteBtn);
  gratitudeLogs.appendChild(row);
}

async function loadGratitude(userId) {
  gratitudeLogs.innerHTML = "";
  gratitudeEntries.length = 0;

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "gratitudeLogs"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      gratitudeEntries.push(entry);
      renderGratitude(entry);
    });
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveGratitude(){
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const t=gratitudeInput.value.trim();
  if(!t)return;

  try {
    const ref = await addDoc(collection(db, "users", user.uid, "gratitudeLogs"), {
      text: t,
      time: serverTimestamp()
    });
    const entry = { id: ref.id, text: t, time: new Date() };
    gratitudeEntries.push(entry);
    renderGratitude(entry);
    updateInsights();
    gratitudeInput.value="";
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function exportAllData() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  try {
    const waterSettingsSnap = await getDoc(doc(db, "users", user.uid, "settings", "water"));
    const dailyChallengeSnap = await getDoc(doc(db, "users", user.uid, "settings", "dailyChallenge"));
    const insightsSnap = await getDoc(doc(db, "users", user.uid, "insights", "current"));
    const [
      moodsSnap,
      tasksSnap,
      waterSnap,
      sleepSnap,
      gratitudeSnap,
      aiSnap,
      challengeHistorySnap
    ] = await Promise.all([
      getDocs(collection(db, "users", user.uid, "moods")),
      getDocs(collection(db, "users", user.uid, "tasks")),
      getDocs(collection(db, "users", user.uid, "waterIntake")),
      getDocs(collection(db, "users", user.uid, "sleepLogs")),
      getDocs(collection(db, "users", user.uid, "gratitudeLogs")),
      getDocs(collection(db, "users", user.uid, "aiChats")),
      getDocs(collection(db, "users", user.uid, "challengeHistory"))
    ]);

    const toExport = {
      exportedAt: new Date().toISOString(),
      user: {
        uid: user.uid,
        email: user.email || null,
        name: user.displayName || null
      },
      waterSettings: waterSettingsSnap.exists() ? waterSettingsSnap.data() : null,
      dailyChallengeSettings: dailyChallengeSnap.exists() ? dailyChallengeSnap.data() : null,
      insightsCurrent: insightsSnap.exists() ? insightsSnap.data() : null,
      moods: moodsSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      tasks: tasksSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      waterIntake: waterSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      sleepLogs: sleepSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      gratitudeLogs: gratitudeSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      aiChats: aiSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      challengeHistory: challengeHistorySnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
    };

    const blob = new Blob([JSON.stringify(toExport, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `novafix-export-${new Date().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function normalizeExportTime(value) {
  if (!value) return new Date();

  if (typeof value === "string" || typeof value === "number") {
    const asDate = new Date(value);
    if (!Number.isNaN(asDate.getTime())) return asDate;
  }

  if (typeof value === "object") {
    if (typeof value.seconds === "number") {
      return new Date((value.seconds * 1000) + Math.floor((value.nanoseconds || 0) / 1e6));
    }
    if (typeof value._seconds === "number") {
      return new Date((value._seconds * 1000) + Math.floor((value._nanoseconds || 0) / 1e6));
    }
  }

  const fallback = new Date(value);
  if (!Number.isNaN(fallback.getTime())) return fallback;
  return new Date();
}

function startImportData() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }
  if (importFileInput) importFileInput.click();
}

async function clearUserCollection(userId, collectionName) {
  const snapshot = await getDocs(collection(db, "users", userId, collectionName));
  await Promise.all(snapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
}

async function importDataFileChange(event) {
  const user = auth.currentUser;
  const selectedFile = event?.target?.files?.[0];

  if (!user || !selectedFile) return;

  const confirmed = confirm("Warning: current data will be destroyed and new data will be imported. Continue?");
  if (!confirmed) {
    event.target.value = "";
    return;
  }

  try {
    const rawText = await selectedFile.text();
    const payload = JSON.parse(rawText);

    const targetCollections = ["moods", "tasks", "waterIntake", "sleepLogs", "gratitudeLogs", "aiChats", "challengeHistory"];
    await Promise.all(targetCollections.map((name) => clearUserCollection(user.uid, name)));
    await deleteDoc(doc(db, "users", user.uid, "settings", "water")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "dailyChallenge")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "insights", "current")).catch(() => {});

    const moods = Array.isArray(payload.moods) ? payload.moods : [];
    const tasks = Array.isArray(payload.tasks) ? payload.tasks : [];
    const waterIntake = Array.isArray(payload.waterIntake) ? payload.waterIntake : [];
    const sleepLogs = Array.isArray(payload.sleepLogs) ? payload.sleepLogs : [];
    const gratitudeLogs = Array.isArray(payload.gratitudeLogs) ? payload.gratitudeLogs : [];
    const aiChats = Array.isArray(payload.aiChats) ? payload.aiChats : [];
    const challengeHistory = Array.isArray(payload.challengeHistory) ? payload.challengeHistory : [];

    await Promise.all(moods.map((entry) => addDoc(collection(db, "users", user.uid, "moods"), {
      mood: entry.mood || "",
      uid: user.uid,
      email: user.email || null,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(tasks.map((entry) => addDoc(collection(db, "users", user.uid, "tasks"), {
      text: entry.text || "",
      completed: !!entry.completed,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(waterIntake.map((entry) => addDoc(collection(db, "users", user.uid, "waterIntake"), {
      glasses: Number(entry.glasses) || 0,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(sleepLogs.map((entry) => addDoc(collection(db, "users", user.uid, "sleepLogs"), {
      hours: Number(entry.hours) || 0,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(gratitudeLogs.map((entry) => addDoc(collection(db, "users", user.uid, "gratitudeLogs"), {
      text: entry.text || "",
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(aiChats.map((entry) => addDoc(collection(db, "users", user.uid, "aiChats"), {
      userMessage: entry.userMessage || "",
      aiResponse: entry.aiResponse || "",
      aiResponseIsHtml: !!entry.aiResponseIsHtml,
      createdAt: normalizeExportTime(entry.createdAt)
    })));

    await Promise.all(challengeHistory.map((entry) => {
      const dateKey = entry.dateKey || (typeof entry.id === "string" ? entry.id : "");
      if (!dateKey) return Promise.resolve();
      return setDoc(doc(db, "users", user.uid, "challengeHistory", dateKey), {
        completed: !!entry.completed,
        challenge: entry.challenge || "",
        dateKey,
        updatedAt: normalizeExportTime(entry.updatedAt || entry.time)
      }, { merge: true });
    }));

    if (payload.waterSettings && typeof payload.waterSettings.goal !== "undefined") {
      await setDoc(doc(db, "users", user.uid, "settings", "water"), {
        goal: Number(payload.waterSettings.goal) || 0
      }, { merge: true });
    }

    if (payload.dailyChallengeSettings) {
      await setDoc(doc(db, "users", user.uid, "settings", "dailyChallenge"), {
        challenge: payload.dailyChallengeSettings.challenge || "",
        completed: !!payload.dailyChallengeSettings.completed,
        dateKey: payload.dailyChallengeSettings.dateKey || getTodayKey(),
        updatedAt: normalizeExportTime(payload.dailyChallengeSettings.updatedAt)
      }, { merge: true });
    }

    if (payload.insightsCurrent) {
      await setDoc(doc(db, "users", user.uid, "insights", "current"), {
        ...payload.insightsCurrent,
        updatedAt: normalizeExportTime(payload.insightsCurrent.updatedAt)
      }, { merge: true });
    }

    await Promise.all([
      loadDailyChallenge(user.uid),
      loadMoods(user.uid),
      loadAiChats(user.uid),
      loadTasks(user.uid),
      loadWaterData(user.uid),
      loadSleepData(user.uid),
      loadGratitude(user.uid)
    ]);

    alert("‚úÖ Data import complete.");
  } catch (err) {
    notifyFirestoreError(err);
  } finally {
    event.target.value = "";
  }
}

// Daily Challenge
const dailyChallenges = [
  "Finish 1 small task you‚Äôve been putting off.",
  "Learn 1 new word or fact today.",
  "Clean or organize one small area of your room/desk.",
  "Write down 3 things you‚Äôre grateful for.",
  "Smile at 3 people today.",
  "Avoid social media for 1 hour.",
  "Try a new hobby for 15 minutes.",
  "Drink 1 extra glass of water today.",
  "Take a 5-minute stretch break every 2 hours.",
  "Eat a fruit or vegetable with every meal.",
  "Meditate for 5‚Äì10 minutes."
];

// ---------- Function to pick a random daily challenge ----------
function pickDailyChallenge() {
  const todayKey = getTodayKey();
  const challenge = pickChallengeForDate(todayKey);
  currentChallengeDateKey = todayKey;
  currentChallengeText = challenge;
  dailyChallengeElement.innerText = challenge;
  challengeResultElement.innerText = "";
  dailyChallengeCompleted = false;
  updateInsights();
}

async function saveDailyChallengeState() {
  const user = auth.currentUser;
  if (!user) return;

  const todayKey = getTodayKey();
  try {
    await setDoc(doc(db, "users", user.uid, "settings", "dailyChallenge"), {
      challenge: currentChallengeText,
      completed: dailyChallengeCompleted,
      dateKey: todayKey,
      timeZone: userTimeZone,
      updatedAt: serverTimestamp()
    }, { merge: true });

    if (dailyChallengeCompleted) {
      await setDoc(doc(db, "users", user.uid, "challengeHistory", todayKey), {
        completed: true,
        challenge: currentChallengeText,
        dateKey: todayKey,
        updatedAt: serverTimestamp()
      }, { merge: true });
    }
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadDailyChallenge(userId) {
  const todayKey = getTodayKey();
  challengeDates.length = 0;

  try {
    const [challengeSettingsSnap, historySnap] = await Promise.all([
      getDoc(doc(db, "users", userId, "settings", "dailyChallenge")),
      getDocs(collection(db, "users", userId, "challengeHistory"))
    ]);

    historySnap.docs.forEach((docSnap) => {
      const data = docSnap.data();
      if (!data.completed) return;
      const key = data.dateKey || docSnap.id;
      const parsed = dateKeyToDate(key);
      if (parsed) challengeDates.push(parsed);
    });

    let challenge = pickChallengeForDate(todayKey);
    let completed = false;

    if (challengeSettingsSnap.exists()) {
      const settings = challengeSettingsSnap.data();
      if (settings.dateKey === todayKey) {
        challenge = settings.challenge || challenge;
        completed = !!settings.completed;
      }
    }

    currentChallengeDateKey = todayKey;
    currentChallengeText = challenge;
    dailyChallengeCompleted = completed;
    dailyChallengeElement.innerText = challenge;
    challengeResultElement.innerText = completed ? "‚úÖ Challenge completed! Great job!" : "";

    if (completed) {
      const parsedToday = dateKeyToDate(todayKey);
      if (parsedToday && !challengeDates.some((date) => dateToKey(date) === todayKey)) {
        challengeDates.push(parsedToday);
      }
    }

    await saveDailyChallengeState();
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
    pickDailyChallenge();
  }
}

// Initialize daily challenge on page load
pickDailyChallenge();

// Complete challenge function
async function completeChallenge() {
  if (dailyChallengeCompleted) {
    challengeResultElement.innerText = "‚úÖ Challenge already completed for today.";
    return;
  }

  dailyChallengeCompleted = true;
  const todayKey = getTodayKey();
  const parsedToday = dateKeyToDate(todayKey);
  if (parsedToday && !challengeDates.some((date) => dateToKey(date) === todayKey)) {
    challengeDates.push(parsedToday);
  }

  challengeResultElement.innerText = "‚úÖ Challenge completed! Great job!";
  updateInsights();
  await saveDailyChallengeState();
}

Object.assign(window, {
  handleAuth,
  toggleAuth,
  signOutUser,
  aiChat,
  clearAiChats,
  addReminder,
  addTask,
  calculateFinance,
  saveMood,
  setWaterGoal,
  saveWater,
  saveSleep,
  timeTraveller,
  newQuote,
  saveGratitude,
  completeChallenge,
  exportAllData,
  startImportData,
  importDataFileChange,
  handleGoogleAuth
});

</script>
</body>
</html>

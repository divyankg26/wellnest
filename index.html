
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>NovaFix ‚Äì Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
:root{
  --waveA:#2196f3;
  --waveB:#ff9800;
  --primary:#2196f3;
  --accent:#ff9800;
  --glass:rgba(255,255,255,0.18);
  --text:#fff;
}

html,body{
  margin:0;
  height:100%;
  font-family:'Segoe UI',sans-serif;
  color:var(--text);
  line-height:1.35;
}

body{
  background:linear-gradient(120deg,var(--waveA),var(--waveB));
  background-size:260% 260%;
  animation:waveMove 36s ease-in-out infinite alternate;
  overflow-x:hidden;
  -webkit-tap-highlight-color: transparent;
}

@keyframes waveMove{
  0%{background-position:0% 50%}
  50%{background-position:100% 50%}
  100%{background-position:0% 50%}
}

/* SPLASH */
#splash{
  position:fixed;
  inset:0;
  background:#FFFFFF;
  display:flex;
  justify-content:center;
  align-items:center;
  z-index:9999;
  transition:opacity 1s ease, transform 1s ease;
}
#splash.hide{
  opacity:0;
  transform:translateY(-40px);
  pointer-events:none;
}
#splash img{
  width:450px;
  max-width:80%;
  animation:popIn 1.2s ease;
}
@keyframes popIn{
  from{opacity:0;transform:scale(.85)}
  to{opacity:1;transform:scale(1)}
}

/* SIGN-IN / SIGN-UP MODAL */
#signInModal {
  display: none; 
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  justify-content: center;
  align-items: center;
  z-index: 10000;
}
.modal-content {
  background: rgba(255,255,255,0.15);
  backdrop-filter: blur(14px);
  padding: 40px;
  border-radius: 20px;
  text-align: center;
  width: 90%;
  max-width: 400px;
  color: #fff;
  box-shadow: 0 12px 30px rgba(0,0,0,0.3);
}
.modal-content input {
  width: 100%;
  margin: 10px 0;
  padding: 12px;
  border-radius: 12px;
  border: none;
  background: rgba(255,255,255,0.22);
  color: #fff;
  font-size: 16px;
}
.modal-content button {
  width: 100%;
  padding: 12px;
  margin-top: 10px;
  border-radius: 12px;
  border: none;
  cursor: pointer;
  background: linear-gradient(135deg,var(--primary),var(--accent));
  color: #fff;
  font-weight: bold;
  font-size: 16px;
}
.google-btn{
  background: rgba(255,255,255,0.28) !important;
}
.modal-content p {margin-top: 10px; font-size: 14px; cursor: pointer;}


#welcomeGuideModal{
  display:none;
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.72);
  justify-content:center;
  align-items:center;
  z-index:10040;
  padding:16px;
}

.welcome-guide-card{
  width:min(560px, calc(100vw - 24px));
  background:rgba(255,255,255,.16);
  border:1px solid rgba(255,255,255,.26);
  border-radius:18px;
  backdrop-filter:blur(14px);
  box-shadow:0 14px 36px rgba(0,0,0,.35);
  padding:18px 18px 16px;
}

.welcome-guide-top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}

.welcome-guide-title{
  margin:0;
  color:#fff;
  font-size:22px;
}

.welcome-guide-step{
  margin:0;
  font-size:12px;
  opacity:.9;
  background:rgba(255,255,255,.14);
  border:1px solid rgba(255,255,255,.25);
  border-radius:999px;
  padding:5px 10px;
  white-space:nowrap;
}

.welcome-guide-body{
  margin-top:12px;
  padding:14px;
  border-radius:12px;
  background:rgba(255,255,255,.1);
}

.welcome-guide-body h3{
  margin:0 0 8px;
  color:#fff;
  font-size:18px;
}

.welcome-guide-body p{
  margin:0;
  font-size:14px;
  line-height:1.5;
  opacity:.96;
}

.welcome-guide-tip{
  margin-top:10px;
  font-size:13px;
  opacity:.95;
  padding:10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.2);
  background:rgba(255,255,255,.09);
}

.welcome-guide-dots{
  display:flex;
  gap:7px;
  margin-top:12px;
}

.welcome-guide-dot{
  width:9px;
  height:9px;
  border-radius:999px;
  background:rgba(255,255,255,.35);
}

.welcome-guide-dot.active{
  background:linear-gradient(135deg,var(--primary),var(--accent));
  box-shadow:0 0 10px rgba(255,255,255,.4);
}

.welcome-guide-actions{
  margin-top:14px;
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}

.welcome-guide-actions button{
  border:none;
  border-radius:10px;
  padding:10px 14px;
  font-weight:700;
  cursor:pointer;
}

#guideSkipBtn{
  background:rgba(255,255,255,.2);
  color:#fff;
}

#guideNextBtn{
  background:linear-gradient(135deg,var(--primary),var(--accent));
  color:#fff;
}

/* HEADER */
header{
  text-align:center;
  padding:30px;
  background:var(--glass);
  backdrop-filter:blur(14px);
  border-radius:0 0 20px 20px;
  box-shadow:0 12px 30px rgba(0,0,0,.3);
  position:relative;
}
header h1{
  margin:0;
  color:var(--primary);
  letter-spacing:.3px;
  text-shadow:none;
}
header p{margin:8px 0 0;opacity:.94}
#signOutBtn{
  width:100%;
  margin-top:8px;
}

#accountBtn{
  position:absolute;
  right:20px;
  top:30px;
  padding:8px 14px;
  border:none;
  border-radius:12px;
  cursor:pointer;
  background: linear-gradient(135deg,var(--accent),var(--primary));
  color:#fff;
  font-weight:bold;
  display:none;
}

#accountOverlay{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.55);
  display:none;
  z-index:10020;
}

#accountPanel{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:min(420px, calc(100vw - 32px));
  max-width:calc(100vw - 40px);
  max-height:80vh;
  overflow-y:auto;
  background:rgba(0,0,0,.35);
  border:1px solid rgba(255,255,255,.25);
  border-radius:14px;
  padding:18px;
  text-align:left;
  backdrop-filter:blur(12px);
  box-shadow:0 14px 34px rgba(0,0,0,.32);
  display:none;
  z-index:10021;
}

.account-title{
  margin:0 0 4px;
  font-size:20px;
  color:var(--primary);
}

.account-subtitle{
  margin:0 0 12px;
  font-size:13px;
  opacity:.92;
}

.account-row{
  font-size:13px;
  margin:8px 0;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.24);
  background:rgba(255,255,255,.1);
  box-shadow:inset 0 1px 0 rgba(255,255,255,.12);
  line-height:1.4;
  word-break:break-word;
}

.account-row b{
  display:inline-block;
  min-width:90px;
  margin-right:6px;
  opacity:.95;
}

#clearDataBtn,
#accountResetPasswordBtn{
  width:100%;
  margin-top:10px;
}

#signOutBtn{
  margin-top:10px;
}

.account-transfer-box{
  margin-top:12px;
  padding:10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.28);
  background:rgba(255,255,255,.08);
}

.account-transfer-box .export-actions{
  margin-top:0;
  justify-content:center;
  flex-wrap:nowrap;
}

.account-transfer-box .export-actions button{
  width:calc(50% - 4px);
  min-width:0;
  text-align:center;
}

.account-transfer-box .export-note{
  margin-top:8px;
  text-align:center;
  line-height:1.35;
}

@media (max-width: 640px){
  #accountPanel{
    width:min(420px, calc(100vw - 20px));
    max-width:calc(100vw - 20px);
    padding:14px;
  }

  .account-transfer-box .export-actions{
    flex-wrap:wrap;
  }
}

/* DASHBOARD */
.dashboard{
  display:grid;
  grid-template-columns:repeat(auto-fit,minmax(300px,1fr));
  gap:24px;
  padding:24px 24px 190px;
  display:none;
}

/* CARD */
.card{
  background:var(--glass);
  backdrop-filter:blur(16px);
  border-radius:20px;
  padding:20px;
  box-shadow:0 16px 40px rgba(0,0,0,.3);
  display:flex;
  flex-direction:column;
  border:1px solid rgba(255,255,255,.25);
  transform:translateZ(0);
  transition:transform .34s cubic-bezier(.22,.61,.36,1), box-shadow .34s cubic-bezier(.22,.61,.36,1), border-color .34s cubic-bezier(.22,.61,.36,1);
  will-change:transform;
}
.card:hover{
  transform:translateY(-4px) scale(1.012);
  box-shadow:0 22px 46px rgba(0,0,0,.34);
  border-color:rgba(255,255,255,.35);
}
.card h2{
  margin-top:0;
  color:var(--primary);
  letter-spacing:.2px;
  font-size:24px;
  line-height:1.2;
  font-weight:700;
}

.input-group{
  display:flex;
  column-gap:8px;
  row-gap:10px;
  flex-wrap:wrap;
  margin-top:8px;
}

.card :is(input,select,textarea,button) + :is(input,select,textarea,button){
  margin-top:10px;
}

.card .input-group :is(input,select,textarea,button) + :is(input,select,textarea,button){
  margin-top:0;
}

input,select,textarea,button{
  padding:10px;
  border-radius:12px;
  border:none;
  background:rgba(255,255,255,.22);
  color:var(--text);
  font-family:inherit;
  font-size:14px;
  line-height:1.35;
}

input,select,textarea{
  border:1px solid rgba(255,255,255,.16);
  transition:border-color .18s ease, background .18s ease;
}

input::placeholder,
textarea::placeholder{
  color:rgba(255,255,255,.85);
}

input:focus,
select:focus,
textarea:focus{
  background:rgba(255,255,255,.28);
  border-color:rgba(255,255,255,.45);
}

button{
  cursor:pointer;
  font-weight:bold;
  background:linear-gradient(135deg,var(--primary),var(--accent));
  transition:transform .16s ease, filter .16s ease, box-shadow .16s ease;
  letter-spacing:.2px;
}

button:hover:not(:disabled){
  transform:translateY(-1px);
  filter:brightness(1.04);
  box-shadow:0 10px 18px rgba(0,0,0,.2);
}

button:active:not(:disabled){
  transform:translateY(0);
}

@media (min-width: 641px){
  .dashboard button{
    font-size:13px;
    padding:8px 10px;
  }

  .dashboard .chat-edit-btn{
    font-size:12px;
    padding:6px 10px;
  }
}

button:disabled,
input:disabled,
select:disabled,
textarea:disabled{
  opacity:.55;
  filter:grayscale(.35);
  cursor:not-allowed;
}

button:focus-visible,
input:focus-visible,
select:focus-visible,
textarea:focus-visible{
  outline:2px solid rgba(255,255,255,.92);
  outline-offset:2px;
}

.limit-note{
  display:none;
  margin:8px 0 0;
  font-size:12px;
  line-height:1.4;
  color:#ffd3d3;
}

.micro-tip{
  margin:0 0 8px;
  font-size:12px;
  line-height:1.4;
  opacity:.9;
}

.reset-hint{
  margin:6px 0 0;
  font-size:12px;
  line-height:1.4;
  opacity:.9;
}

.soft-note{
  margin:8px 0 0;
  font-size:12px;
  line-height:1.4;
  opacity:.92;
}

.status-loading,
.status-empty{
  margin-top:10px;
  padding:12px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.2);
  background:rgba(255,255,255,.08);
  font-size:13px;
  line-height:1.4;
}

.status-loading{ opacity:.88; }

#uxToast{
  position:fixed;
  left:50%;
  bottom:22px;
  transform:translateX(-50%);
  display:none;
  align-items:center;
  gap:10px;
  max-width:min(560px, calc(100vw - 24px));
  width:max-content;
  padding:10px 12px;
  border-radius:12px;
  background:rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.26);
  backdrop-filter:blur(10px);
  z-index:10050;
  box-shadow:0 12px 30px rgba(0,0,0,.3);
}

#uxToastText{
  font-size:13px;
  line-height:1.35;
}

#uxToastAction{
  border:none;
  border-radius:9px;
  padding:7px 10px;
  font-size:12px;
  font-weight:700;
  background:linear-gradient(135deg,var(--primary),var(--accent));
  color:#fff;
  cursor:pointer;
}

.limit-note.show{
  display:block;
}

.chat,#moodLogs,#gratitudeLogs,#reminders,#taskList,#timeMirror{
  flex:1 1 0;
  min-height:0;
  overflow-y:auto;
  padding:10px;
  border-radius:12px;
  background:rgba(0,0,0,.15);
  margin-top:8px;
  border:1px solid rgba(255,255,255,.14);
}

#moodLogs{
  min-height:130px;
}

#reminders,#taskList,#gratitudeLogs{
  margin-top:16px;
}

#reminders .item-row{
  align-items:flex-start;
  margin-bottom:10px;
}

#reminders .item-text{
  line-height:1.4;
  padding-top:2px;
}

#reminderSetBtn{
  width:100%;
  display:block;
  text-align:center;
}

#taskList .item-row,
#gratitudeLogs .item-row{
  align-items:flex-start;
  margin-bottom:10px;
}

#taskList .item-text,
#gratitudeLogs .item-text{
  line-height:1.4;
  padding-top:2px;
}

.scroll-card{
  height:430px;
  max-height:430px;
  overflow:hidden;
}

#timeMirror{white-space:pre-wrap;}

#taskList button,
#gratitudeLogs button,
#reminders button{
  margin-left:12px;
}

.item-row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

.item-text{
  flex:1;
  min-width:0;
  word-break:break-word;
}

.item-actions{
  display:flex;
  align-items:center;
  gap:8px;
  flex-shrink:0;
}

.ai-header-row{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}

.ai-header-row h2{margin:0}

.ai-clear-btn{
  padding:10px;
  border-radius:12px;
  font-size:14px;
  line-height:1.35;
}

.chat-message{
  display:flex;
  justify-content:space-between;
  align-items:flex-start;
  gap:8px;
  margin-bottom:8px;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.12);
}

.chat-text{
  font-size:14px;
  line-height:1.45;
  word-break:break-word;
}

.chat-edit-btn{
  padding:6px 10px;
  border-radius:10px;
  font-size:12px;
  white-space:nowrap;
}

.mood-item{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
  margin-bottom:8px;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.12);
}

.mood-item span{
  font-size:14px;
  line-height:1.4;
}

.mood-remove{
  padding:6px 10px;
  border-radius:10px;
  border:none;
  font-size:12px;
}

.task-done{
  text-decoration:line-through;
  opacity:.75;
}

.insight-list{margin:6px 0 0;padding-left:18px}
.insight-list li{margin:4px 0}

.insight-row{margin-top:8px}
.insight-row small{display:block;margin-bottom:4px;opacity:.9}
.insight-bar{
  width:100%;
  height:10px;
  border-radius:10px;
  background:rgba(255,255,255,.2);
  overflow:hidden;
}
.insight-fill{
  height:100%;
  background:linear-gradient(135deg,var(--primary),var(--accent));
  width:0%;
}

.insight-switch-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-top:10px;
}

.insight-task-top{
  margin-top:10px;
}

.insight-task-label{
  display:block;
  text-align:center;
  margin:0 0 6px;
  font-weight:700;
}

.insight-metric-title{
  text-align:left;
  margin:0;
  font-weight:700;
}

.insight-metric-label{
  display:block;
  text-align:center;
  margin:0 0 6px;
  opacity:.95;
}

.insight-reset-note{
  display:block;
  text-align:center;
  margin:0 0 6px;
  font-size:12px;
  opacity:.95;
  color:#ff6b6b;
  font-weight:700;
}

.insight-graph-scroll{
  width:100%;
  margin-top:8px;
  overflow-x:auto;
  overflow-y:hidden;
  border-radius:10px;
  background:rgba(0,0,0,.14);
}

.insight-graph-track{
  display:block;
  width:max-content;
  min-width:100%;
}

.insight-graph-scroll::-webkit-scrollbar{
  height:6px;
}

.insight-graph-scroll::-webkit-scrollbar-thumb{
  background:var(--primary);
  border-radius:3px;
}

.insight-line-graph{
  width:auto;
  min-width:0;
  height:180px;
  margin-top:0;
  display:block;
  flex:none;
}

.insight-column{
  fill:url(#insightGraphGradient);
  opacity:1;
}

.insight-axis-line{
  stroke:rgba(255,255,255,.95);
  stroke-width:1.5;
}

.insight-tick-label{
  font-size:10px;
  fill:rgba(255,255,255,.92);
}

.insight-bar-label{
  font-size:10px;
  fill:rgba(255,255,255,.95);
  text-anchor:middle;
}

.insight-bar-value{
  font-size:10px;
  fill:rgba(255,255,255,.95);
  text-anchor:middle;
}

.export-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.export-note{font-size:13px;opacity:.9;margin-top:8px}

.wellness-badge{
  font-size:34px;
  font-weight:800;
  text-align:center;
  margin:6px 0;
}

.wellness-status{
  text-align:center;
  margin:0;
  font-weight:600;
}

.wellness-actions{
  margin:10px 0 0;
  padding-left:18px;
}

.wellness-actions li{
  margin:5px 0;
}

.water-clear-btn{
  display:block;
  margin-top:10px;
}

.crash-banner{
  display:none;
  position:fixed;
  right:18px;
  bottom:18px;
  width:min(360px, calc(100vw - 28px));
  padding:12px;
  border-radius:14px;
  background:rgba(0,0,0,.28);
  border:1px solid rgba(255,255,255,.24);
  backdrop-filter:blur(12px);
  box-shadow:0 12px 30px rgba(0,0,0,.35);
  z-index:10015;
  transform:translateZ(0);
  transition:transform .34s cubic-bezier(.22,.61,.36,1), box-shadow .34s cubic-bezier(.22,.61,.36,1), border-color .34s cubic-bezier(.22,.61,.36,1);
  will-change:transform;
}

.crash-banner:hover{
  transform:translateY(-4px) scale(1.012);
  box-shadow:0 22px 46px rgba(0,0,0,.34);
  border-color:rgba(255,255,255,.35);
}

@media (max-width: 768px){
  .crash-banner{
    left:50%;
    right:auto;
    transform:translateX(-50%);
  }
}

.crash-banner-row{
  display:flex;
  gap:10px;
  align-items:flex-start;
  justify-content:space-between;
  flex-wrap:wrap;
}

.crash-banner-row button{
  padding:8px 10px;
  border-radius:10px;
  font-size:12px;
}

.crash-risk-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}

.crash-risk-value{
  font-size:30px;
  font-weight:800;
  margin:2px 0;
}

.crash-risk-pill{
  font-size:12px;
  padding:6px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.16);
  border:1px solid rgba(255,255,255,.25);
  white-space:nowrap;
}

.crash-meter{
  width:100%;
  height:10px;
  border-radius:10px;
  margin-top:8px;
  background:rgba(255,255,255,.2);
  overflow:hidden;
}

.crash-meter-fill{
  height:100%;
  width:0%;
  background:linear-gradient(135deg,var(--primary),var(--accent));
}

.crash-risk-sub{
  margin:8px 0 0;
  opacity:.92;
  font-size:13px;
}

.crash-plan{
  margin:8px 0 0;
  padding-left:18px;
}

.crash-plan li{margin:4px 0}

.crash-rescue-btn{margin-top:10px}

.weekly-range{
  margin:0;
  opacity:.92;
  font-size:14px;
  line-height:1.4;
}

.weekly-section-title{
  margin:10px 0 6px;
  font-size:14px;
  font-weight:700;
  opacity:.95;
}

.weekly-list{
  margin:0;
  padding-left:18px;
}

.weekly-list li{margin:4px 0}

.weekly-target-box{
  margin-top:10px;
  padding:12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.24);
  background:rgba(255,255,255,.08);
}

.weekly-target-text{
  margin:0;
  font-size:14px;
  line-height:1.4;
  opacity:.92;
}

.weekly-target-btn{margin-top:10px}

.startup-list{
  margin:8px 0 0;
  padding-left:18px;
}

.startup-list li{margin:5px 0}

.startup-list.compact li{margin:4px 0}

.startup-actions-two{
  display:flex;
  flex-wrap:nowrap;
  gap:8px;
}

.startup-actions-two button{
  width:calc(50% - 4px);
  min-width:0;
  text-align:center;
}

.startup-mini{
  margin:8px 0 0;
  font-size:13px;
  opacity:.92;
  line-height:1.4;
}

.startup-pill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.24);
  background:rgba(255,255,255,.12);
  font-size:12px;
  margin:8px 0 0;
}

.startup-leaderboard{
  margin-top:10px;
  border:1px solid rgba(255,255,255,.2);
  border-radius:12px;
  background:rgba(0,0,0,.14);
  padding:10px;
}

.startup-leaderboard-row{
  display:flex;
  justify-content:space-between;
  gap:10px;
  font-size:13px;
  margin-bottom:6px;
}

.startup-leaderboard-row:last-child{margin-bottom:0}

.challenge-streak{
  width:100%;
  margin-top:10px;
}

.challenge-streak-labels,
.challenge-streak-circles{
  display:grid;
  grid-template-columns:repeat(7,minmax(0,1fr));
  gap:6px;
  width:100%;
}

.challenge-streak-labels{
  margin-bottom:6px;
}

.challenge-streak-day{
  text-align:center;
  font-size:11px;
  opacity:.92;
}

.challenge-streak-circle{
  width:26px;
  height:26px;
  border-radius:999px;
  border:2px solid rgba(255,255,255,.45);
  background:rgba(255,255,255,.06);
  position:relative;
  overflow:hidden;
  display:flex;
  align-items:center;
  justify-content:center;
  margin:0 auto;
  font-size:0;
  line-height:1;
  transition:transform .2s ease, background .2s ease, border-color .2s ease;
}

.challenge-streak-circle::before{
  content:"";
  position:absolute;
  left:0;
  right:0;
  top:100%;
  bottom:0;
  background:linear-gradient(180deg,#ffb347 0%, #ff8c00 55%, #ff6a00 100%);
}

.challenge-streak-circle.filled{
  background:rgba(255,140,0,.18);
  border-color:#ff9f43;
}

.challenge-streak-circle.filled::before{
  top:0;
}

.challenge-streak-fire{
  position:relative;
  z-index:1;
  font-size:15px;
  line-height:1;
  filter:drop-shadow(0 0 6px rgba(255,120,0,.5));
}

.challenge-streak-circle.fire-fill{
  animation:challengeCirclePop .65s ease-out;
}

@keyframes challengeFireRise{
  0%{top:100%}
  55%{top:18%}
  100%{top:0}
}

@keyframes challengeCirclePop{
  0%{transform:scale(.86)}
  60%{transform:scale(1.08)}
  100%{transform:scale(1)}
}

.challenge-streak-circle.fire-fill::before{
  animation:challengeFireRise .75s ease-out forwards;
}

.challenge-streak-circle.fire-fill .challenge-streak-fire{
  animation:challengeFireEmoji .75s ease-out;
}

@keyframes challengeFireEmoji{
  0%{opacity:0;transform:translateY(8px) scale(.75)}
  60%{opacity:1;transform:translateY(-1px) scale(1.08)}
  100%{opacity:1;transform:translateY(0) scale(1)}
}

.quest-top{
  display:flex;
  justify-content:center;
  align-items:center;
  gap:10px;
  flex-wrap:wrap;
}

.quest-card{
  position:relative;
  overflow:hidden;
}

.quest-stat{
  font-size:13px;
  opacity:.95;
}

#questStreak{
  padding:6px 10px;
  border-radius:999px;
  background:rgba(255,255,255,.14);
  border:1px solid rgba(255,255,255,.25);
  box-shadow:0 0 0 rgba(255,140,0,0);
  transition:transform .2s ease, box-shadow .25s ease, background .25s ease;
}

#questStreak.streak-pop{
  transform:scale(1.08);
  background:rgba(255,140,0,.22);
  box-shadow:0 0 18px rgba(255,140,0,.55);
}

.quest-streak-fx{
  position:absolute;
  inset:0;
  pointer-events:none;
  overflow:hidden;
}

.quest-flame{
  position:absolute;
  left:50%;
  top:36%;
  font-size:18px;
  opacity:0;
  transform:translate(-50%, -50%) scale(.5);
  animation:flameBurst .9s ease-out forwards;
}

@keyframes flameBurst{
  0%{opacity:0;transform:translate(-50%, -50%) scale(.5)}
  20%{opacity:1}
  100%{opacity:0;transform:translate(calc(-50% + var(--tx)), calc(-50% + var(--ty))) scale(1.1)}
}

.quest-progress{
  width:100%;
  height:10px;
  border-radius:10px;
  background:rgba(255,255,255,.2);
  overflow:hidden;
  margin:14px 0 12px;
}

.quest-progress-fill{
  height:100%;
  width:0%;
  background:linear-gradient(135deg,var(--primary),var(--accent));
}

#questShield{
  margin:6px 0 12px;
}

.quest-list{margin:10px 0 0;padding:0;list-style:none}
.quest-item{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:8px;
  margin-bottom:8px;
  padding:8px 10px;
  border-radius:10px;
  background:rgba(255,255,255,.1);
}
.quest-text{font-size:14px;line-height:1.4;flex:1}
.quest-done{opacity:.7;text-decoration:line-through}

.burnout-risk{
  font-size:30px;
  font-weight:800;
  margin:4px 0;
}

.burnout-sub{margin:0;font-size:13px;opacity:.92}
.burnout-list{margin:8px 0 0;padding-left:18px}
.burnout-list li{margin:4px 0}
.burnout-btn{margin-top:10px}

#gCost,#gMonths,#buffer{
  margin-top:8px;
}

@media (max-width: 640px){
  header{
    padding:20px 12px 18px;
  }

  button:not(#accountBtn){
    font-size:13px;
    padding:7px 10px;
    width:auto !important;
    min-width:0 !important;
    display:inline-flex;
    align-items:center;
    justify-content:center;
  }

  #accountBtn{
    right:12px;
    top:14px;
    padding:7px 10px;
  }

  header h1{
    font-size:26px;
  }

  header p{
    font-size:13px;
  }

  input,select,textarea{
    font-size:14px;
    padding:9px;
  }

  #uxToastText{
    font-size:12px;
  }

  #uxToast{
    width:calc(100vw - 18px);
    max-width:calc(100vw - 18px);
    bottom:calc(10px + env(safe-area-inset-bottom));
    padding:10px;
  }
}

@media (max-width: 420px){
  header h1{font-size:24px}

  header p{font-size:12px}

  .chat-message,
  .mood-item,
  .item-row{
    gap:6px;
    padding:8px;
  }

  #accountPanel{
    width:calc(100vw - 14px);
    max-width:calc(100vw - 14px);
    padding:12px;
  }
}

@media (prefers-reduced-motion: reduce){
  *, *::before, *::after{
    animation:none !important;
    transition:none !important;
  }
}

::-webkit-scrollbar{width:6px}
::-webkit-scrollbar-thumb{background:var(--primary);border-radius:3px}
</style>
</head>
<body>

<audio id="reminderSound" src="https://image2url.com/r2/default/audio/1770462028211-e2a46d69-8e18-430d-971b-e111cf9254b9.mp3" preload="auto"></audio>

<!-- SPLASH -->
<div id="splash">
  <img src="https://gcdnb.pbrd.co/images/T3DLjTXN0F9N.jpg?o=1">
</div>

<!-- SIGN-IN / SIGN-UP MODAL -->
<div id="signInModal">
  <div class="modal-content">
    <h2 id="modalTitle">Welcome to NovaFix üåü</h2>
    <input id="usernameInput" type="text" placeholder="Enter username" style="display:none;">
    <input id="emailInput" type="email" placeholder="Enter email">
    <input id="passwordInput" type="password" placeholder="Enter password">
    <button id="actionButton" onclick="handleAuth()">Sign In</button>
    <button id="resetPasswordButton" class="google-btn" onclick="sendResetPasswordEmail()">Reset Password</button>
    <button id="resendVerificationButton" class="google-btn" onclick="resendVerificationEmailFromModal()">Resend Verification Email</button>
    <button id="googleAuthButton" class="google-btn" onclick="handleGoogleAuth()">Sign In with Google</button>
    <p onclick="toggleAuth()"><span id="toggleText">Don't have an account? Sign Up</span></p>
    <p id="signInError" style="color:red; display:none;">Error message here!</p>
  </div>
</div>

<div id="welcomeGuideModal">
  <div class="welcome-guide-card">
    <div class="welcome-guide-top">
      <h2 class="welcome-guide-title">Welcome to NovaFix ‚ú®</h2>
      <p id="guideStepCounter" class="welcome-guide-step">Step 1/5</p>
    </div>
    <div class="welcome-guide-body">
      <h3 id="guideStepTitle">Your Dashboard</h3>
      <p id="guideStepText">Track habits, mood, hydration, sleep, and productivity from one place.</p>
      <div id="guideStepTip" class="welcome-guide-tip">Tip: Complete logs daily to unlock better insights.</div>
    </div>
    <div id="guideDots" class="welcome-guide-dots"></div>
    <div class="welcome-guide-actions">
      <button id="guideSkipBtn" onclick="skipWelcomeGuide()">Skip Guide</button>
      <button id="guideNextBtn" onclick="nextWelcomeGuideStep()">Next</button>
    </div>
  </div>
</div>

<header>
  <h1>NovaFix</h1>
  <p>Mind ‚Ä¢ Body ‚Ä¢ Money ‚Ä¢ Music ‚Ä¢ Productivity</p>
<button id="accountBtn" onclick="toggleAccountPanel()">Account</button>
</header>

<div id="accountPanel">
  <h3 class="account-title">üë§ Account</h3>
  <p class="account-subtitle">Manage your profile and data controls</p>
  <div class="account-row"><b>Username:</b> <span id="accountName">-</span></div>
  <div class="account-row"><b>Email:</b> <span id="accountEmail">-</span></div>
  <div class="account-row"><b>Verification:</b> <span id="accountVerifyStatus">-</span></div>
  <button id="accountResetPasswordBtn" onclick="sendAccountResetPasswordEmail()">Change Password</button>
  <button id="clearDataBtn" onclick="clearAllAccountData()">Clear All Data</button>
  <button id="signOutBtn" onclick="signOutUser()">Sign Out</button>
  <div class="account-transfer-box">
    <div class="export-actions">
      <button onclick="exportAllData()">Export My Data</button>
      <button onclick="startImportData()">Import Data</button>
    </div>
    <p class="export-note">Download your full NovaFix data as JSON for transfering accounts</p>
    <input id="importFileInput" type="file" accept="application/json,.json" style="display:none" onchange="importDataFileChange(event)">
  </div>
</div>

<div id="accountOverlay" onclick="closeAccountPanel()"></div>

<div id="crashAlertBanner" class="crash-banner">
  <div class="crash-banner-row">
    <div>
      <strong>‚ö†Ô∏è Mood Crash Warning</strong>
      <p id="crashBannerText" class="crash-risk-sub">Your dip risk is elevated right now.</p>
    </div>
    <button onclick="runCrashRescueFlow()">Run 2-Min Rescue</button>
  </div>
</div>

<div class="dashboard">

<!-- AI Companion -->
<div class="card scroll-card">
<div class="ai-header-row">
<h2>ü§ñ AI Companion</h2>
<button class="ai-clear-btn" onclick="clearAiChats()">Clear</button>
</div>
<p class="micro-tip">Tip: Ask short, clear prompts for better advice.</p>
<div class="chat" id="chat"></div>
<div class="input-group">
<input id="aiInput" placeholder="Talk to AI">
<button id="aiTalkBtn" onclick="aiChat()">Talk</button>
</div>
<p id="aiLimitError" class="limit-note"></p>
</div>

<!-- Reminders -->
<div class="card scroll-card">
<h2>‚è∞ Reminders</h2>
<p class="micro-tip">Tip: Keep reminders specific, like ‚ÄúDrink water now‚Äù.</p>
<div class="input-group">
<input id="reminderText" placeholder="Reminder">
<input type="number" id="reminderMinutes" placeholder="Minutes">
<button id="reminderSetBtn" onclick="addReminder()">Set</button>
</div>
<p class="reset-hint">Daily limit resets at 00:00 server time.</p>
<p id="reminderLimitError" class="limit-note"></p>
<ul id="reminders"></ul>
</div>

<!-- Tasks -->
<div class="card scroll-card">
<h2>üìä Productivity</h2>
<p class="micro-tip">Tip: Add tiny tasks first to build momentum.</p>
<div class="input-group">
<input id="task" placeholder="Task">
<button id="taskAddBtn" onclick="addTask()">Add</button>
</div>
<p id="taskLimitError" class="limit-note"></p>
<ul id="taskList"></ul>
</div>

<!-- Grocery Finance -->
<div class="card">
<h2>üßæ Grocery Financing</h2>
<input id="gCost" placeholder="Monthly ‚Çπ">
<input id="gMonths" placeholder="Months">
<input id="buffer" placeholder="Buffer %">
<button onclick="calculateFinance()">Plan</button>
<p id="financeResult"></p>
</div>

<!-- Mood Tracker -->
<div class="card scroll-card">
<h2>üßò Mood Tracker</h2>
<p class="micro-tip">Tip: A quick mood log now improves your crash-risk forecast.</p>
<select id="mood">
<option>üòä Happy</option>
<option>üòê Neutral</option>
<option>üòî Low</option>
</select>
<button id="moodSaveBtn" onclick="saveMood()">Save</button>
<p id="moodLimitError" class="limit-note"></p>
<div id="moodLogs"></div>
</div>

<!-- Water -->
<div class="card">
<h2>üíß Water Intake</h2>
<p class="micro-tip">Tip: Set your daily goal once each morning.</p>
<input id="waterGoalInput" placeholder="Daily goal">
<button onclick="setWaterGoal()">Set Goal</button>
<input id="waterInput" placeholder="Glasses">
<button id="waterTrackBtn" onclick="saveWater()">Track</button>
<p class="reset-hint">Daily limit resets at 00:00 server time.</p>
<p id="waterLimitError" class="limit-note"></p>
<button id="waterClearBtn" class="water-clear-btn" onclick="clearWaterData()">Clear Intake + Goal</button>
<p id="waterProgress"></p>
</div>

<!-- Sleep -->
<div class="card">
<h2>üí§ Sleep</h2>
<p class="micro-tip">Tip: Log sleep after waking for a consistent trend.</p>
<input id="sleepInput" placeholder="Hours">
<button id="sleepSaveBtn" onclick="saveSleep()">Save</button>
<p id="sleepLimitError" class="limit-note"></p>
<p id="sleepResult"></p>
</div>

<!-- Wellness Music -->
<div class="card">
<h2>üéµ Wellness Music</h2>
<iframe style="border-radius:14px" src="https://open.spotify.com/embed/playlist/0Gwjm4uWLCSE7ZIiY6dK2X" width="100%" height="190"></iframe>
</div>

<!-- Time Traveller Mirror -->
<div class="card scroll-card">
<h2>ü™û Time Traveller Mirror</h2>
<input id="futureTask" placeholder="Enter goal">
<button onclick="timeTraveller()">Check</button>
<div id="timeMirror"></div>
</div>

<!-- Motivational Quotes -->
<div class="card">
<h2>üí° Motivational Quotes</h2>
<p id="quoteDisplay"></p>
<button onclick="newQuote()">Inspire Me</button>
</div>

<!-- Gratitude Journal -->
<div class="card scroll-card">
<h2>üôè Gratitude Journal</h2>
<p class="micro-tip">Tip: 1 line is enough ‚Äî consistency beats length.</p>
<textarea id="gratitudeInput" rows="3"></textarea>
<button id="gratitudeSaveBtn" onclick="saveGratitude()">Save</button>
<p id="gratitudeLimitError" class="limit-note"></p>
<div id="gratitudeLogs"></div>
</div>

<!-- Daily Challenge -->
<div class="card">
<h2>üèÜ Daily Challenge</h2>
<p class="micro-tip">Tip: Completing this boosts your overall wellness score.</p>
<p id="dailyChallenge"></p>
<button id="challengeCompleteBtn" onclick="completeChallenge()">Complete</button>
<p id="challengeResult"></p>
</div>

<!-- Daily Wellness Score -->
<div class="card">
<h2>‚≠ê Daily Wellness Score</h2>
<div id="wellnessScore" class="wellness-badge">0/100</div>
<p id="wellnessStatus" class="wellness-status">Needs Focus</p>
<p id="wellnessReassurance" class="soft-note">Log one check-in to start momentum today.</p>
<ul id="wellnessActions" class="wellness-actions">
  <li>Log your first check-in for today.</li>
  <li>Set your water target and drink one glass.</li>
  <li>Add one gratitude note tonight.</li>
</ul>
</div>

<!-- Mood Crash Prevention -->
<div class="card">
<h2>üö® Mood Crash Prevention</h2>
<div class="crash-risk-head">
  <div id="crashRiskValue" class="crash-risk-value">0/100</div>
  <div id="crashRiskLevel" class="crash-risk-pill">Low Risk</div>
</div>
<div class="crash-meter"><div id="crashRiskFill" class="crash-meter-fill"></div></div>
<p id="crashRiskReason" class="crash-risk-sub">Log your first entries to generate risk analysis.</p>
<button class="crash-rescue-btn" onclick="runCrashRescueFlow()">Run 2-Min Rescue</button>
<ul id="crashRescuePlan" class="crash-plan"></ul>
</div>

<!-- Weekly Review + AI Coach -->
<div class="card">
<h2>üß† Weekly Review + AI Coach</h2>
<p id="weeklyRange" class="weekly-range">Last 7 days review</p>

<p class="weekly-section-title">‚úÖ What Improved</p>
<ul id="weeklyImproved" class="weekly-list"></ul>

<p class="weekly-section-title">‚ö†Ô∏è What Dropped</p>
<ul id="weeklyDropped" class="weekly-list"></ul>

<p class="weekly-section-title">üéØ Top 3 Next-Week Actions</p>
<ul id="weeklyActions" class="weekly-list"></ul>

<div class="weekly-target-box">
  <p id="weeklyTargetsDisplay" class="weekly-target-text">Targets: Water -, Sleep -, Tasks -</p>
  <button class="weekly-target-btn" onclick="setNextWeekTargets()">Set Next Week Targets</button>
</div>
</div>

<!-- Adaptive Habit Quest -->
<div class="card quest-card" id="questCard">
<h2>üéÆ Adaptive Habit Quest</h2>
<p class="micro-tip">Tip: Finish all 4 quests before midnight to lock streak progress.</p>
<div class="quest-top">
  <div id="questXp" class="quest-stat">XP 0/100</div>
</div>
<div id="questStreak" class="quest-stat">Streak 0 üî•</div>
<div id="questWeekStreak" class="challenge-streak">
  <div id="questWeekStreakLabels" class="challenge-streak-labels"></div>
  <div id="questWeekStreakCircles" class="challenge-streak-circles"></div>
</div>
<div class="quest-progress"><div id="questProgressFill" class="quest-progress-fill"></div></div>
<p id="questShield" class="burnout-sub">Streak shield: Inactive</p>
<p id="questProgressHint" class="soft-note">Complete all 4 quests to secure today‚Äôs streak.</p>
<ul id="questList" class="quest-list"></ul>
</div>

<!-- Predictive Burnout Radar -->
<div class="card">
<h2>üì° Predictive Burnout Radar</h2>
<div id="burnoutRisk" class="burnout-risk">0/100</div>
<p id="burnoutWindow" class="wellness-status">Low Risk ‚Ä¢ Stable window</p>
<p id="burnoutReason" class="burnout-sub">Forecast appears stable right now.</p>
<ul id="burnoutSchedule" class="burnout-list"></ul>
<button class="burnout-btn" onclick="applyRecoverySchedule()">Apply Recovery Schedule</button>
</div>

<!-- Insights -->
<div class="card" id="insightsCard">
<h2>üìà Insights & Streaks</h2>
<p class="micro-tip">Tip: Trends get sharper when you log daily at similar times.</p>

<div class="insight-task-top">
  <small id="insightTaskTopLabel" class="insight-task-label">Tasks completed 0/0</small>
  <div class="insight-bar"><div id="insightTaskTopBar" class="insight-fill"></div></div>
</div>

<div class="insight-switch-head">
  <p id="insightMetricTitle" class="insight-metric-title">Productivity Trend</p>
  <button id="insightNextBtn" onclick="nextInsightMetric()">Next</button>
</div>
<small id="insightMetricLabel" class="insight-metric-label">0%</small>
<small id="insightWeeklyResetCountdown" class="insight-reset-note"></small>
<div id="insightGraphScroll" class="insight-graph-scroll">
  <div id="insightGraphTrack" class="insight-graph-track">
    <svg id="insightLineGraph" class="insight-line-graph" viewBox="0 0 640 74" preserveAspectRatio="xMinYMid meet">
      <defs>
        <linearGradient id="insightGraphGradient" x1="0" y1="0" x2="1" y2="0">
          <stop offset="0%" stop-color="var(--primary)" />
          <stop offset="100%" stop-color="var(--accent)" />
        </linearGradient>
      </defs>
      <g id="insightAxisLayer"></g>
      <g id="insightBarLayer"></g>
      <g id="insightBarLabelLayer"></g>
    </svg>
  </div>
</div>
</div>

<!-- Personalized Daily Plan -->
<div class="card">
<h2>üóÇÔ∏è Personalized Daily Plan</h2>
<p class="micro-tip">Top 3 priorities generated from your mood, sleep, hydration, and task trends.</p>
<ul id="startupDailyPlanList" class="startup-list"></ul>
<div class="input-group startup-actions-two">
  <button id="startupRefreshPlanBtn" onclick="refreshStartupPlan()">Generate Plan</button>
  <button id="startupApplyPlanBtn" onclick="applyStartupPlanAsTasks()">Apply as Tasks</button>
</div>
<p id="startupPlanMeta" class="startup-mini">Plan updates automatically when your logs change.</p>
</div>

<!-- Weekly Startup Report -->
<div class="card">
<h2>üßæ Weekly Startup Report</h2>
<p class="micro-tip">One-click summary of wins, risks, and next actions for sharing.</p>
<div class="input-group startup-actions-two">
  <button id="startupGenerateReportBtn" onclick="generateStartupWeeklyReport()">Generate Report</button>
  <button onclick="copyStartupWeeklyReport()">Copy Report</button>
</div>
<ul id="startupWeeklyReportText" class="startup-list compact"><li>No report generated yet.</li></ul>
</div>

<!-- Behavior Memory Graph -->
<div class="card">
<h2>üß¨ Behavior Memory Graph</h2>
<p class="micro-tip">Signals the patterns that most improve your next-day stability.</p>
<ul id="startupBehaviorMemory" class="startup-list"></ul>
</div>

<div id="uxToast">
  <span id="uxToastText"></span>
  <button id="uxToastAction" style="display:none;"></button>
</div>

<script type="module">
  // üî• Firebase Imports
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { initializeFirestore, persistentLocalCache, getFirestore, collection, addDoc, getDocs, serverTimestamp, deleteDoc, doc, updateDoc, setDoc, getDoc, runTransaction } 
from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { 
  getAuth,
  createUserWithEmailAndPassword, 
  signInWithEmailAndPassword, 
  onAuthStateChanged, 
  signOut,
  sendEmailVerification,
  sendPasswordResetEmail,
  fetchSignInMethodsForEmail,
  updateProfile,
  GoogleAuthProvider,
  signInWithPopup
} from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

// üî• Your Firebase Config
const firebaseConfig = {
  apiKey: "AIzaSyCirCkRGlsODEExB9VLVY08Zw7b84zm_Qc",
  authDomain: "novaafix-86912.firebaseapp.com",
  projectId: "novaafix-86912",
  storageBucket: "novaafix-86912.firebasestorage.app",
  messagingSenderId: "699084708640",
  appId: "1:699084708640:web:401f5d6990d818551e1545",
  measurementId: "G-WHHXFW3N7R"
};

// üî• Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
let db;
try {
  db = initializeFirestore(app, {
    localCache: persistentLocalCache()
  });
} catch (_) {
  db = getFirestore(app);
}
const googleProvider = new GoogleAuthProvider();
googleProvider.setCustomParameters({
  prompt: "select_account"
});

// ---------- DOM REFERENCES ----------
const emailInput = document.getElementById("emailInput");
const passwordInput = document.getElementById("passwordInput");
const usernameInput = document.getElementById("usernameInput");
const googleAuthButton = document.getElementById("googleAuthButton");
const resendVerificationButton = document.getElementById("resendVerificationButton");
const splash = document.getElementById("splash");
const signInModal = document.getElementById("signInModal");
const dashboard = document.querySelector(".dashboard");
const accountBtn = document.getElementById("accountBtn");
const accountOverlay = document.getElementById("accountOverlay");
const accountPanel = document.getElementById("accountPanel");
const welcomeGuideModal = document.getElementById("welcomeGuideModal");
const guideStepCounter = document.getElementById("guideStepCounter");
const guideStepTitle = document.getElementById("guideStepTitle");
const guideStepText = document.getElementById("guideStepText");
const guideStepTip = document.getElementById("guideStepTip");
const guideDots = document.getElementById("guideDots");
const guideNextBtn = document.getElementById("guideNextBtn");
const crashAlertBanner = document.getElementById("crashAlertBanner");
const crashBannerText = document.getElementById("crashBannerText");
const crashRiskValue = document.getElementById("crashRiskValue");
const crashRiskFill = document.getElementById("crashRiskFill");
const crashRiskLevel = document.getElementById("crashRiskLevel");
const crashRiskReason = document.getElementById("crashRiskReason");
const crashRescuePlan = document.getElementById("crashRescuePlan");
const weeklyRange = document.getElementById("weeklyRange");
const weeklyImproved = document.getElementById("weeklyImproved");
const weeklyDropped = document.getElementById("weeklyDropped");
const weeklyActions = document.getElementById("weeklyActions");
const weeklyTargetsDisplay = document.getElementById("weeklyTargetsDisplay");
const questXpEl = document.getElementById("questXp");
const questStreakEl = document.getElementById("questStreak");
const questWeekStreakLabels = document.getElementById("questWeekStreakLabels");
const questWeekStreakCircles = document.getElementById("questWeekStreakCircles");
const questProgressFill = document.getElementById("questProgressFill");
const questShieldEl = document.getElementById("questShield");
const questProgressHintEl = document.getElementById("questProgressHint");
const questListEl = document.getElementById("questList");
const burnoutRiskEl = document.getElementById("burnoutRisk");
const burnoutWindowEl = document.getElementById("burnoutWindow");
const burnoutReasonEl = document.getElementById("burnoutReason");
const burnoutScheduleEl = document.getElementById("burnoutSchedule");
const accountName = document.getElementById("accountName");
const accountEmail = document.getElementById("accountEmail");
const accountVerifyStatus = document.getElementById("accountVerifyStatus");
const accountUid = document.getElementById("accountUid");
const clearDataBtn = document.getElementById("clearDataBtn");
const signOutBtn = document.getElementById("signOutBtn");
const chat = document.getElementById("chat");
const aiInput = document.getElementById("aiInput");
const aiTalkBtn = document.getElementById("aiTalkBtn");
const aiLimitError = document.getElementById("aiLimitError");
const reminderText = document.getElementById("reminderText");
const reminderMinutes = document.getElementById("reminderMinutes");
const reminderSetBtn = document.getElementById("reminderSetBtn");
const reminderLimitError = document.getElementById("reminderLimitError");
const reminders = document.getElementById("reminders");
const task = document.getElementById("task");
const taskAddBtn = document.getElementById("taskAddBtn");
const taskLimitError = document.getElementById("taskLimitError");
const taskList = document.getElementById("taskList");
const gCost = document.getElementById("gCost");
const gMonths = document.getElementById("gMonths");
const buffer = document.getElementById("buffer");
const financeResult = document.getElementById("financeResult");
const mood = document.getElementById("mood");
const moodSaveBtn = document.getElementById("moodSaveBtn");
const moodLimitError = document.getElementById("moodLimitError");
const moodLogs = document.getElementById("moodLogs");
const waterGoalInput = document.getElementById("waterGoalInput");
const waterInput = document.getElementById("waterInput");
const waterTrackBtn = document.getElementById("waterTrackBtn");
const waterLimitError = document.getElementById("waterLimitError");
const waterProgress = document.getElementById("waterProgress");
const waterClearBtn = document.getElementById("waterClearBtn");
const sleepInput = document.getElementById("sleepInput");
const sleepSaveBtn = document.getElementById("sleepSaveBtn");
const sleepLimitError = document.getElementById("sleepLimitError");
const sleepResult = document.getElementById("sleepResult");
const futureTask = document.getElementById("futureTask");
const timeMirror = document.getElementById("timeMirror");
const quoteDisplay = document.getElementById("quoteDisplay");
const gratitudeInput = document.getElementById("gratitudeInput");
const gratitudeSaveBtn = document.getElementById("gratitudeSaveBtn");
const gratitudeLimitError = document.getElementById("gratitudeLimitError");
const gratitudeLogs = document.getElementById("gratitudeLogs");
const dailyChallengeElement = document.getElementById("dailyChallenge");
const challengeResultElement = document.getElementById("challengeResult");
const challengeCompleteBtn = document.getElementById("challengeCompleteBtn");
const importFileInput = document.getElementById("importFileInput");
const wellnessScoreEl = document.getElementById("wellnessScore");
const wellnessStatusEl = document.getElementById("wellnessStatus");
const wellnessReassuranceEl = document.getElementById("wellnessReassurance");
const wellnessActionsEl = document.getElementById("wellnessActions");
const insightsCard = document.getElementById("insightsCard");
const insightTaskTopLabel = document.getElementById("insightTaskTopLabel");
const insightTaskTopBar = document.getElementById("insightTaskTopBar");
const insightMetricTitle = document.getElementById("insightMetricTitle");
const insightMetricLabel = document.getElementById("insightMetricLabel");
const insightWeeklyResetCountdown = document.getElementById("insightWeeklyResetCountdown");
const insightLineGraph = document.getElementById("insightLineGraph");
const insightAxisLayer = document.getElementById("insightAxisLayer");
const insightBarLayer = document.getElementById("insightBarLayer");
const insightBarLabelLayer = document.getElementById("insightBarLabelLayer");
const insightGraphTrack = document.getElementById("insightGraphTrack");
const insightGraphScroll = document.getElementById("insightGraphScroll");
const uxToast = document.getElementById("uxToast");
const uxToastText = document.getElementById("uxToastText");
const uxToastAction = document.getElementById("uxToastAction");
const startupDailyPlanList = document.getElementById("startupDailyPlanList");
const startupPlanMeta = document.getElementById("startupPlanMeta");
const startupRefreshPlanBtn = document.getElementById("startupRefreshPlanBtn");
const startupWeeklyReportText = document.getElementById("startupWeeklyReportText");
const startupGenerateReportBtn = document.getElementById("startupGenerateReportBtn");
const startupBehaviorMemory = document.getElementById("startupBehaviorMemory");

// ---------- SPLASH + AUTH CHECK ----------
document.body.style.overflow = "hidden";
let splashRemoved = false;

function hideSplash() {
  if (splashRemoved || !splash) return;
  splash.classList.add("hide");
  setTimeout(() => {
    if (!splashRemoved) {
      splash.remove();
      splashRemoved = true;
      document.body.style.overflow = "auto";
    }
  }, 1000);
}

function toggleAccountPanel() {
  if (!accountPanel || !accountOverlay) return;
  const isOpen = accountPanel.style.display === "block";
  accountPanel.style.display = isOpen ? "none" : "block";
  accountOverlay.style.display = isOpen ? "none" : "block";
}

function closeAccountPanel() {
  if (!accountPanel || !accountOverlay) return;
  accountPanel.style.display = "none";
  accountOverlay.style.display = "none";
}

function updateAccountPanel(user) {
  if (!user) {
    if (accountName) accountName.innerText = "-";
    if (accountEmail) accountEmail.innerText = "-";
    if (accountVerifyStatus) accountVerifyStatus.innerText = "-";
    if (accountUid) accountUid.innerText = "-";
    if (clearDataBtn) {
      clearDataBtn.disabled = true;
      clearDataBtn.title = "No data to clear";
    }
    return;
  }

  const fallbackName = (user.email || "").split("@")[0] || "User";
  if (accountName) accountName.innerText = user.displayName || fallbackName;
  if (accountEmail) accountEmail.innerText = user.email || "Not available";
  if (accountVerifyStatus) accountVerifyStatus.innerText = user.emailVerified ? "Verified ‚úÖ" : "Not verified ‚ö†Ô∏è";
  if (accountUid) accountUid.innerText = user.uid || "Not available";
}

document.addEventListener("click", (event) => {
  if (!accountPanel || !accountBtn) return;
  const clickedInside = accountPanel.contains(event.target) || accountBtn.contains(event.target);
  if (!clickedInside) closeAccountPanel();
});

document.addEventListener("keydown", (event) => {
  if (event.key !== "Escape") return;
  closeAccountPanel();
  if (welcomeGuideModal && welcomeGuideModal.style.display === "flex") {
    closeWelcomeGuide();
  }
});

async function clearAllAccountData() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  const warningOne = confirm("‚ö†Ô∏è This will permanently delete your NovaFix app data (tasks, mood, water, sleep, gratitude, reminders, AI chats, and insights). All STREAKS will also be cleared. Daily limits for AI, mood, sleep, water, tasks, reminders, and gratitude will NOT be reset. Continue?");
  if (!warningOne) return;

  const warningTwo = confirm("Final warning: this cannot be undone. Your account will stay signed in, but all app data will be erased. Proceed?");
  if (!warningTwo) return;

  try {
    const previousChallengeText = String(currentChallengeText || "");
    await syncServerClock(user.uid);
    clearAllReminderTimers();

    const aiUsageRef = doc(db, "users", user.uid, "settings", "aiUsage");
    const dailyUsageRef = doc(db, "users", user.uid, "settings", "dailyUsage");
    let preservedAiUsage = null;
    let preservedDailyUsage = null;
    try {
      const aiUsageSnap = await getDoc(aiUsageRef);
      preservedAiUsage = aiUsageSnap.exists() ? aiUsageSnap.data() : null;
    } catch (_) {
      preservedAiUsage = null;
    }
    try {
      const dailyUsageSnap = await getDoc(dailyUsageRef);
      preservedDailyUsage = dailyUsageSnap.exists() ? dailyUsageSnap.data() : null;
    } catch (_) {
      preservedDailyUsage = null;
    }

    const todayKey = getTodayKey();
    let remindersTodayCount = 0;
    try {
      const remindersSnap = await getDocs(collection(db, "users", user.uid, "reminders"));
      remindersTodayCount = countTodayRemindersFromDocs(remindersSnap.docs);
    } catch (_) {
      remindersTodayCount = 0;
    }
    const moodTodayCount = countTodayFromDates(moodDates);
    const taskTodayCount = taskEntries.reduce((total, entry) => (dateToKey(entry.time) === todayKey ? total + 1 : total), 0);
    const sleepTodayCount = countTodayFromDates(sleepDates);
    const waterTodayCount = countTodayFromDates(waterDates);
    const gratitudeTodayCount = gratitudeEntries.reduce((total, entry) => (dateToKey(entry.time) === todayKey ? total + 1 : total), 0);

    const targetCollections = [
      "moods",
      "tasks",
      "waterIntake",
      "sleepLogs",
      "gratitudeLogs",
      "aiChats",
      "reminders",
      "challengeHistory",
      "rescueEvents"
    ];

    await Promise.all(targetCollections.map((name) => clearUserCollection(user.uid, name)));
    await deleteDoc(doc(db, "users", user.uid, "settings", "water")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "dailyChallenge")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "weeklyTargets")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "habitQuest")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "startupPack")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "insights", "current")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "insights", "barGraphs")).catch(() => {});
    persistedBarGraphs = null;

    if (preservedAiUsage && Number.isFinite(Number(preservedAiUsage.count))) {
      await setDoc(aiUsageRef, {
        dateKeyLocal: preservedAiUsage.dateKeyLocal || preservedAiUsage.dateKeyGMT || getTodayKeyGMT(),
        dateKeyGMT: preservedAiUsage.dateKeyGMT || preservedAiUsage.dateKeyLocal || getTodayKeyGMT(),
        count: Number(preservedAiUsage.count) || 0,
        updatedAt: serverTimestamp()
      }, { merge: true });
    }
    const preservedDateKey = preservedDailyUsage?.dateKey || "";
    const preservedMoodCount = preservedDateKey === todayKey ? (Number(preservedDailyUsage?.moodCount) || 0) : 0;
    const preservedTaskCount = preservedDateKey === todayKey ? (Number(preservedDailyUsage?.taskCount) || 0) : 0;
    const preservedSleepCount = preservedDateKey === todayKey ? (Number(preservedDailyUsage?.sleepCount) || 0) : 0;
    const preservedWaterCount = preservedDateKey === todayKey ? (Number(preservedDailyUsage?.waterCount) || 0) : 0;
    const preservedReminderCount = preservedDateKey === todayKey ? (Number(preservedDailyUsage?.reminderCount) || 0) : 0;
    const preservedGratitudeCount = preservedDateKey === todayKey ? (Number(preservedDailyUsage?.gratitudeCount) || 0) : 0;

    await setDoc(dailyUsageRef, {
      dateKey: todayKey,
      moodCount: Math.max(preservedMoodCount, moodTodayCount),
      taskCount: Math.max(preservedTaskCount, taskTodayCount),
      sleepCount: Math.max(preservedSleepCount, sleepTodayCount),
      waterCount: Math.max(preservedWaterCount, waterTodayCount),
      reminderCount: Math.max(preservedReminderCount, remindersTodayCount),
      gratitudeCount: Math.max(preservedGratitudeCount, gratitudeTodayCount),
      updatedAt: serverTimestamp()
    }, { merge: true });

    moodLogs.innerHTML = "";
    chat.innerHTML = "";
    taskList.innerHTML = "";
    reminders.innerHTML = "";
    gratitudeLogs.innerHTML = "";
    waterProgress.innerText = "";
    sleepResult.innerText = "";
    challengeResultElement.innerText = "";
    waterGoalInput.value = "";
    waterInput.value = "";
    sleepInput.value = "";
    task.value = "";
    reminderText.value = "";
    reminderMinutes.value = "";
    gratitudeInput.value = "";

    moodHistory.length = 0;
    waterHistory.length = 0;
    sleepHistory.length = 0;
    moodDates.length = 0;
    waterDates.length = 0;
    sleepDates.length = 0;
    taskEntries.length = 0;
    gratitudeEntries.length = 0;
    challengeDates.length = 0;
    aiRecentPrompts.length = 0;
    habitQuests.length = 0;
    burnoutRecoveryPlan.length = 0;
    dailyChallengeCompleted = false;
    currentChallengeText = "";
    currentChallengeDateKey = "";
    questDateKey = "";
    questXp = 0;
    questShieldAvailable = false;
    waterGoal = 0;

    await Promise.all([
      assignFreshDailyChallenge(user.uid, previousChallengeText),
      loadDailyUsage(user.uid),
      loadMoods(user.uid),
      loadAiUsage(user.uid),
      loadAiChats(user.uid),
      loadTasks(user.uid),
      loadReminders(user.uid),
      loadWaterData(user.uid),
      loadSleepData(user.uid),
      loadGratitude(user.uid),
      loadWeeklyTargets(user.uid),
      loadRescueEvents(user.uid),
      loadHabitQuest(user.uid),
      loadStartupUsageState(user.uid),
      loadStartupFeatureState(user.uid)
    ]);

    updateClearDataButtonState();

    closeAccountPanel();
    alert("‚úÖ All account data cleared. You are still signed in.");
  } catch (err) {
    notifyFirestoreError(err);
  }
}

try {
  onAuthStateChanged(auth, (user) => {
    hideSplash();

    setTimeout(async () => {
      if (user) {
        await user.reload();
        if (!user.emailVerified) {
          const verificationError = document.getElementById("signInError");
          if (verificationError) {
            verificationError.style.display = "block";
            verificationError.style.color = "#ff6b6b";
            verificationError.innerText = "Please verify your email before signing in.";
          }
          await signOut(auth);
          return;
        }

        dashboard.style.display = "grid";
        accountBtn.style.display = "block";
        closeAccountPanel();
        updateAccountPanel(user);
        signInModal.style.display = "none";
        setInitialLoadingStates();
        updateClearDataButtonState();
        await syncServerClock(user.uid);
        await loadPersistedBarGraphs(user.uid);
        loadDailyChallenge(user.uid);
        loadDailyUsage(user.uid);
        loadMoods(user.uid);
        loadAiUsage(user.uid);
        loadAiChats(user.uid);
        loadTasks(user.uid);
        loadReminders(user.uid);
        loadWeeklyTargets(user.uid);
        loadRescueEvents(user.uid);
        loadHabitQuest(user.uid);
        loadStartupUsageState(user.uid);
        loadStartupFeatureState(user.uid);
        loadWaterData(user.uid);
        loadSleepData(user.uid);
        loadGratitude(user.uid);
        startDailyChallengeWatcher();
        scheduleDailyChallengeReset(user.uid);
        scheduleDailyQuestReset(user.uid);
        startWeeklyGraphResetCountdown();
        scheduleWeeklyGraphReset(user.uid);
        scheduleWaterGoalReset(user.uid);
        await maybeShowWelcomeGuide(user.uid);
      } else {
        stopDailyChallengeWatcher();
        clearDailyChallengeResetSchedule();
        clearDailyQuestResetSchedule();
        clearWeeklyGraphResetSchedule();
        stopWeeklyGraphResetCountdown();
        clearWaterGoalResetSchedule();
        closeAccountPanel();
        updateAccountPanel(null);
        signInModal.style.display = "flex";
        dashboard.style.display = "none";
        accountBtn.style.display = "none";
        moodLogs.innerHTML = "";
        chat.innerHTML = "";
        taskList.innerHTML = "";
        reminders.innerHTML = "";
        gratitudeLogs.innerHTML = "";
        clearAllReminderTimers();
        waterProgress.innerText = "";
        sleepResult.innerText = "";
        wellnessScoreEl.innerText = "0/100";
        wellnessStatusEl.innerText = "Needs Focus";
        wellnessActionsEl.innerHTML = "<li>Log your first check-in for today.</li><li>Set your water target and drink one glass.</li><li>Add one gratitude note tonight.</li>";
        if (crashAlertBanner) crashAlertBanner.style.display = "none";
        if (crashRiskValue) crashRiskValue.innerText = "0/100";
        if (crashRiskFill) crashRiskFill.style.width = "0%";
        if (crashRiskLevel) crashRiskLevel.innerText = "Low Risk";
        if (crashRiskReason) crashRiskReason.innerText = "Log your first entries to generate risk analysis.";
        if (crashRescuePlan) crashRescuePlan.innerHTML = "";
        rescueEvents.length = 0;
        habitQuests.length = 0;
        burnoutRecoveryPlan.length = 0;
        questDateKey = "";
        questXp = 0;
        questShieldAvailable = false;
        questStreakCount = 0;
        questLastStreakDateKey = "";
        questWeekStartKey = "";
        weeklyQuestUsedIds = [];
        questCompletedDateKeys = [];
        weeklyTargets = { waterGoal: 0, sleepTarget: 8, taskTarget: 5 };
        startupFeatureState = getDefaultStartupFeatureState();
        startupCurrentPlan = [];
        startupWeeklyReportCache = "";
        startupPlanGeneratedOnce = false;
        startupReportGeneratedOnce = false;
        startupUsageState = getDefaultStartupUsageState();
        refreshStartupFeatures();
        if (weeklyRange) weeklyRange.innerText = "Last 7 days review";
        if (weeklyTargetsDisplay) weeklyTargetsDisplay.innerText = "Targets: Water -, Sleep -, Tasks -";
        if (weeklyImproved) weeklyImproved.innerHTML = "";
        if (weeklyDropped) weeklyDropped.innerHTML = "";
        if (weeklyActions) weeklyActions.innerHTML = "";
        if (questXpEl) questXpEl.innerText = "XP 0/100";
        if (questStreakEl) questStreakEl.innerText = "Streak 0 üî•";
        if (questProgressFill) questProgressFill.style.width = "0%";
        if (questShieldEl) questShieldEl.innerText = "Streak shield: Inactive";
        if (questListEl) questListEl.innerHTML = "";
        closeWelcomeGuide();
        welcomeGuideStepIndex = 0;
        welcomeGuideUserId = "";
        welcomeGuideCheckedThisSession = false;
        if (burnoutRiskEl) burnoutRiskEl.innerText = "0/100";
        if (burnoutWindowEl) burnoutWindowEl.innerText = "Low Risk ‚Ä¢ Stable window";
        if (burnoutReasonEl) burnoutReasonEl.innerText = "Forecast appears stable right now.";
        if (burnoutScheduleEl) burnoutScheduleEl.innerHTML = "";
        challengeResultElement.innerText = "";
        moodHistory.length = 0;
        waterHistory.length = 0;
        sleepHistory.length = 0;
        moodDates.length = 0;
        waterDates.length = 0;
        sleepDates.length = 0;
        taskEntries.length = 0;
        gratitudeEntries.length = 0;
        challengeDates.length = 0;
        dailyChallengeCompleted = false;
        currentChallengeDateKey = "";
        persistedBarGraphs = null;
        waterGoal = 0;
        aiUsageDateKeyGMT = "";
        aiUsageCount = 0;
        aiUsageStateLoaded = false;
        dailyUsageDateKey = "";
        moodDailyUsageCount = 0;
        taskDailyUsageCount = 0;
        sleepDailyUsageCount = 0;
        waterDailyUsageCount = 0;
        reminderDailyUsageCount = 0;
        gratitudeDailyUsageCount = 0;
        dailyUsageLoaded = false;
        waterGoalInput.value = "";
        resetAllLimitUIs();
        updateClearDataButtonState();
      }
    }, 1000); // match your splash transition
  });
} catch (_) {
  setTimeout(() => {
    hideSplash();
    signInModal.style.display = "flex";
    dashboard.style.display = "none";
    accountBtn.style.display = "none";
    closeAccountPanel();
    updateAccountPanel(null);
  }, 1000);
}

setTimeout(hideSplash, 2000);

// ---------- COLOR WAVES ----------
const waves = [
  ["#2196f3","#ff9800"],
  ["#9c27b0","#03a9f4"],
  ["#ff5722","#4caf50"],
  ["#3f51b5","#e91e63"],
  ["#009688","#ffc107"],
  ["#8e24aa","#ff6f91"],
  ["#00c853","#ff9100"],
  ["#1e88e5","#ff7043"],
  ["#6a1b9a","#f06292"],
  ["#00bfa5","#ffca28"],
  ["#43a047","#fb8c00"],
  ["#3949ab","#ec407a"],
  ["#7e57c2","#26c6da"],
  ["#2e7d32","#ff6d00"],
  ["#5e35b1","#ff8a65"],
  ["#26a69a","#ffb300"],
  ["#4a148c","#ff80ab"],
  ["#ab47bc","#26a69a"],
  ["#ef5350","#7cb342"],
  ["#1a237e","#00acc1"],
  ["#8e24aa","#26c6da"],
  ["#00897b","#f4511e"],
  ["#5c6bc0","#ffa726"],
  ["#d81b60","#5e35b1"],
  ["#039be5","#8bc34a"],
  ["#7b1fa2","#ff7043"],
  ["#43a047","#ec407a"],
  ["#3949ab","#26a69a"],
  ["#e53935","#1e88e5"],
  ["#6d4c41","#29b6f6"],
  ["#8e24aa","#42a5f5"],
  ["#ad1457","#26a69a"],
  ["#283593","#ef5350"],
  ["#0277bd","#ab47bc"],
  ["#00695c","#ff7043"],
  ["#4527a0","#66bb6a"],
  ["#00838f","#ff8f00"],
  ["#5d4037","#42a5f5"],
  ["#c2185b","#7e57c2"],
  ["#33691e","#ff6f00"],
  ["#1565c0","#ec407a"],
  ["#00897b","#5c6bc0"],
  ["#6a1b9a","#26c6da"],
  ["#7b1fa2","#66bb6a"],
  ["#303f9f","#ffa726"]
];
let w = 1;
let currentWaveA = waves[0][0];
let currentWaveB = waves[0][1];
let waveAnimationId = null;
const WAVE_HOLD_MS = 14000;
const WAVE_TRANSITION_MS = 18000;

function hexToRgb(hex) {
  const normalized = hex.replace("#", "");
  const value = normalized.length === 3
    ? normalized.split("").map((char) => char + char).join("")
    : normalized;
  const parsed = Number.parseInt(value, 16);
  return {
    r: (parsed >> 16) & 255,
    g: (parsed >> 8) & 255,
    b: parsed & 255
  };
}

function rgbToHex({ r, g, b }) {
  const toHex = (value) => Math.max(0, Math.min(255, Math.round(value))).toString(16).padStart(2, "0");
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
}

function lerp(start, end, progress) {
  return start + (end - start) * progress;
}

function setWaveColors(colorA, colorB) {
  document.documentElement.style.setProperty("--waveA", colorA);
  document.documentElement.style.setProperty("--waveB", colorB);
  document.documentElement.style.setProperty("--primary", colorA);
  document.documentElement.style.setProperty("--accent", colorB);
}

function animateWaveTo(targetA, targetB, durationMs) {
  if (waveAnimationId) cancelAnimationFrame(waveAnimationId);

  const startA = hexToRgb(currentWaveA);
  const startB = hexToRgb(currentWaveB);
  const endA = hexToRgb(targetA);
  const endB = hexToRgb(targetB);
  const startTime = performance.now();

  const tick = (now) => {
    const elapsed = now - startTime;
    const progress = Math.min(1, elapsed / durationMs);
    const eased = progress * progress * progress * (progress * (progress * 6 - 15) + 10);

    const nextA = rgbToHex({
      r: lerp(startA.r, endA.r, eased),
      g: lerp(startA.g, endA.g, eased),
      b: lerp(startA.b, endA.b, eased)
    });

    const nextB = rgbToHex({
      r: lerp(startB.r, endB.r, eased),
      g: lerp(startB.g, endB.g, eased),
      b: lerp(startB.b, endB.b, eased)
    });

    setWaveColors(nextA, nextB);

    if (progress < 1) {
      waveAnimationId = requestAnimationFrame(tick);
      return;
    }

    currentWaveA = targetA;
    currentWaveB = targetB;
    setTimeout(rotateWave, WAVE_HOLD_MS);
  };

  waveAnimationId = requestAnimationFrame(tick);
}

function rotateWave() {
  const [targetA, targetB] = waves[w];
  w = (w + 1) % waves.length;
  animateWaveTo(targetA, targetB, WAVE_TRANSITION_MS);
}

setWaveColors(currentWaveA, currentWaveB);
setTimeout(rotateWave, WAVE_HOLD_MS);

// ---------- SIGN-IN / SIGN-UP ----------
let authMode="signin";
let verificationCooldownTimer = null;
let verificationCooldownRemaining = 0;
const VERIFICATION_AUTO_RESEND_WINDOW_MS = 10 * 60 * 1000;
let welcomeGuideStepIndex = 0;
let welcomeGuideUserId = "";
let welcomeGuideCheckedThisSession = false;
const WELCOME_GUIDE_VERSION = 1;
const WELCOME_GUIDE_STEPS = [
  {
    title: "Dashboard Overview",
    text: "Use the cards to log mood, water, sleep, reminders, tasks, gratitude, and more in one flow.",
    tip: "Tip: Start with Mood, Water, and Sleep every day for the fastest progress gains."
  },
  {
    title: "Daily Limits",
    text: "Each tracker has a daily safety limit and reset timer to keep entries realistic and consistent.",
    tip: "Tip: If a button is disabled, the countdown note shows when it resets."
  },
  {
    title: "Habit Quest",
    text: "You get 4 random quests each day. Complete all 4 to lock the streak day and activate your streak shield.",
    tip: "Tip: Finish all quests before midnight server time to keep your streak momentum."
  },
  {
    title: "Insights & Weekly Review",
    text: "Your logs feed into weekly insight bars and AI coaching so you can spot patterns quickly.",
    tip: "Tip: Use the Insights Next button to switch mood/water/sleep views."
  },
  {
    title: "Account Controls",
    text: "Use the Account button to export/import data, change password, or clear app data when needed.",
    tip: "You‚Äôre all set ‚Äî click Finish and start your first check-in."
  }
];

function getVerificationSentStorageKey(email) {
  return `novafix_verification_sent_${String(email || "").toLowerCase()}`;
}

function getVerificationLastSentMs(email) {
  try {
    const raw = localStorage.getItem(getVerificationSentStorageKey(email));
    const value = Number(raw);
    return Number.isFinite(value) ? value : 0;
  } catch (_) {
    return 0;
  }
}

function markVerificationSentNow(email) {
  try {
    localStorage.setItem(getVerificationSentStorageKey(email), String(Date.now()));
  } catch (_) {}
}

function canAutoResendVerification(email) {
  const lastSentMs = getVerificationLastSentMs(email);
  if (!lastSentMs) return true;
  return (Date.now() - lastSentMs) >= VERIFICATION_AUTO_RESEND_WINDOW_MS;
}

function setResendVerificationButtonState() {
  if (!resendVerificationButton) return;
  if (verificationCooldownRemaining > 0) {
    resendVerificationButton.disabled = true;
    resendVerificationButton.innerText = `Resend Verification (${verificationCooldownRemaining}s)`;
    return;
  }
  resendVerificationButton.disabled = false;
  resendVerificationButton.innerText = "Resend Verification Email";
}

function startVerificationCooldown(seconds = 110) {
  verificationCooldownRemaining = Math.max(0, Number(seconds) || 0);
  setResendVerificationButtonState();
  if (verificationCooldownTimer) clearInterval(verificationCooldownTimer);
  if (verificationCooldownRemaining <= 0) return;

  verificationCooldownTimer = setInterval(() => {
    verificationCooldownRemaining = Math.max(0, verificationCooldownRemaining - 1);
    setResendVerificationButtonState();
    if (verificationCooldownRemaining <= 0) {
      clearInterval(verificationCooldownTimer);
      verificationCooldownTimer = null;
    }
  }, 1000);
}

function getAuthActionUrl() {
  return window.location.protocol === "file:"
    ? "https://novaafix-86912.firebaseapp.com"
    : window.location.origin;
}

async function sendVerificationEmailReliable(user) {
  const actionCodeSettings = {
    url: getAuthActionUrl(),
    handleCodeInApp: false
  };

  try {
    await sendEmailVerification(user, actionCodeSettings);
    return { ok: true, mode: "custom" };
  } catch (err) {
    const code = String(err?.code || "");
    const shouldFallback = code.includes("unauthorized-continue-uri") || code.includes("invalid-continue-uri") || code.includes("unauthorized-domain");
    if (!shouldFallback) {
      return { ok: false, error: err };
    }

    try {
      await sendEmailVerification(user);
      return { ok: true, mode: "default" };
    } catch (fallbackErr) {
      return { ok: false, error: fallbackErr };
    }
  }
}

async function sendPasswordResetReliable(email) {
  const actionCodeSettings = {
    url: getAuthActionUrl(),
    handleCodeInApp: false
  };

  try {
    await sendPasswordResetEmail(auth, email, actionCodeSettings);
    return { ok: true, mode: "custom" };
  } catch (err) {
    const code = String(err?.code || "");
    const shouldFallback = code.includes("unauthorized-continue-uri") || code.includes("invalid-continue-uri") || code.includes("unauthorized-domain");
    if (!shouldFallback) {
      return { ok: false, error: err };
    }

    try {
      await sendPasswordResetEmail(auth, email);
      return { ok: true, mode: "default" };
    } catch (fallbackErr) {
      return { ok: false, error: fallbackErr };
    }
  }
}

function renderWelcomeGuideStep() {
  if (!welcomeGuideModal || !guideStepCounter || !guideStepTitle || !guideStepText || !guideStepTip || !guideDots || !guideNextBtn) return;
  const total = WELCOME_GUIDE_STEPS.length;
  const safeIndex = Math.max(0, Math.min(total - 1, welcomeGuideStepIndex));
  const current = WELCOME_GUIDE_STEPS[safeIndex];
  guideStepCounter.innerText = `Step ${safeIndex + 1}/${total}`;
  guideStepTitle.innerText = current.title;
  guideStepText.innerText = current.text;
  guideStepTip.innerText = current.tip;
  guideNextBtn.innerText = safeIndex === total - 1 ? "Finish" : "Next";

  guideDots.innerHTML = "";
  for (let i = 0; i < total; i += 1) {
    const dot = document.createElement("span");
    dot.className = `welcome-guide-dot${i === safeIndex ? " active" : ""}`;
    guideDots.appendChild(dot);
  }
}

function openWelcomeGuide(userId = "") {
  if (!welcomeGuideModal) return;
  welcomeGuideUserId = String(userId || welcomeGuideUserId || "");
  welcomeGuideStepIndex = 0;
  renderWelcomeGuideStep();
  welcomeGuideModal.style.display = "flex";
}

function closeWelcomeGuide() {
  if (!welcomeGuideModal) return;
  welcomeGuideModal.style.display = "none";
}

async function completeWelcomeGuide() {
  const activeUserId = String(welcomeGuideUserId || auth.currentUser?.uid || "");
  if (activeUserId) {
    try {
      await setDoc(doc(db, "users", activeUserId, "settings", "onboarding"), {
        welcomeGuideCompleted: true,
        welcomeGuideVersion: WELCOME_GUIDE_VERSION,
        welcomeGuideCompletedAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      }, { merge: true });
    } catch (_) {}
  }
  closeWelcomeGuide();
}

async function nextWelcomeGuideStep() {
  const total = WELCOME_GUIDE_STEPS.length;
  if (welcomeGuideStepIndex >= total - 1) {
    await completeWelcomeGuide();
    return;
  }
  welcomeGuideStepIndex += 1;
  renderWelcomeGuideStep();
}

async function skipWelcomeGuide() {
  await completeWelcomeGuide();
}

async function maybeShowWelcomeGuide(userId) {
  const activeUserId = String(userId || "");
  if (!activeUserId || !welcomeGuideModal || welcomeGuideCheckedThisSession) return;
  welcomeGuideCheckedThisSession = true;
  welcomeGuideUserId = activeUserId;

  try {
    const snap = await getDoc(doc(db, "users", activeUserId, "settings", "onboarding"));
    const data = snap.exists() ? (snap.data() || {}) : {};
    if (!data.welcomeGuideCompleted) {
      const [waterSnap, weeklySnap] = await Promise.all([
        getDoc(doc(db, "users", activeUserId, "settings", "water")),
        getDoc(doc(db, "users", activeUserId, "settings", "weeklyTargets"))
      ]);

      if (!waterSnap.exists()) {
        await setDoc(doc(db, "users", activeUserId, "settings", "water"), {
          goal: 8,
          goalDateKey: getTodayKey(),
          lastResetDateKey: getTodayKey(),
          updatedAt: serverTimestamp()
        }, { merge: true });
      }

      if (!weeklySnap.exists()) {
        await setDoc(doc(db, "users", activeUserId, "settings", "weeklyTargets"), {
          waterGoal: 8,
          sleepTarget: 8,
          taskTarget: 5,
          updatedAt: serverTimestamp()
        }, { merge: true });
      }

      openWelcomeGuide(activeUserId);
    }
  } catch (_) {
    openWelcomeGuide(activeUserId);
  }
}

function toggleAuth(){
  authMode=authMode==="signin"?"signup":"signin";
  const title=document.getElementById("modalTitle");
  const button=document.getElementById("actionButton");
  const toggleText=document.getElementById("toggleText");
  const error=document.getElementById("signInError");
  error.style.display="none";
  if(authMode==="signup"){
    title.innerText="Create a NovaFix Account üåü";
    button.innerText="Sign Up";
    googleAuthButton.innerText = "Sign Up with Google";
    toggleText.innerText="Already have an account? Sign In";
    usernameInput.style.display = "block";
  } else {
    title.innerText="Welcome to NovaFix üåü";
    button.innerText="Sign In";
    googleAuthButton.innerText = "Sign In with Google";
    toggleText.innerText="Don't have an account? Sign Up";
    usernameInput.style.display = "none";
  }
  setResendVerificationButtonState();
}

async function resendVerificationEmailFromModal() {
  const email = emailInput.value.trim().toLowerCase();
  const password = passwordInput.value.trim();
  const error = document.getElementById("signInError");
  error.style.display = "none";

  if (verificationCooldownRemaining > 0) return;

  if (!email || !password) {
    error.style.display = "block";
    error.style.color = "#ff6b6b";
    error.innerText = "Enter email and password to resend verification.";
    return;
  }

  try {
    const credential = await signInWithEmailAndPassword(auth, email, password);
    await credential.user.reload();

    if (credential.user.emailVerified) {
      error.style.display = "block";
      error.style.color = "#7CFFB2";
      error.innerText = "This email is already verified. You can sign in now.";
      await signOut(auth);
      return;
    }

    const verifyResult = await sendVerificationEmailReliable(credential.user);
    await signOut(auth);

    if (!verifyResult.ok) {
      throw verifyResult.error;
    }

    markVerificationSentNow(email);
    startVerificationCooldown(110);
    error.style.display = "block";
    error.style.color = "#7CFFB2";
    error.innerText = "Verification email resent. It may take up to 10 minutes; check Inbox/Spam/Promotions.";
  } catch (err) {
    error.style.display = "block";
    error.style.color = "#ff6b6b";
    error.innerText = err?.message || "Could not resend verification email.";
  }
}

async function handleAuth() {
  const username = usernameInput.value.trim();
  const email = emailInput.value.trim().toLowerCase();
  const password = passwordInput.value.trim();
  const error = document.getElementById("signInError");

  if (!email || !password) {
    error.style.display = "block";
    error.innerText = "Email and password are required!";
    return;
  }

  if (authMode === "signup" && !username) {
    error.style.display = "block";
    error.innerText = "Username is required for sign up!";
    return;
  }

  try {
    if (authMode === "signup") {
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      await updateProfile(userCredential.user, { displayName: username });
      const verifyResult = await sendVerificationEmailReliable(userCredential.user);

      await signOut(auth);
      authMode = "signin";
      const title = document.getElementById("modalTitle");
      const button = document.getElementById("actionButton");
      const toggleText = document.getElementById("toggleText");
      title.innerText = "Welcome to NovaFix üåü";
      button.innerText = "Sign In";
      googleAuthButton.innerText = "Sign In with Google";
      toggleText.innerText = "Don't have an account? Sign Up";
      usernameInput.style.display = "none";

      error.style.display = "block";
      error.style.color = verifyResult.ok ? "#7CFFB2" : "#ff6b6b";
      error.innerText = verifyResult.ok
        ? "Account created. Verification email sent. Check Inbox/Spam/Promotions, then sign in."
        : `Account created, but verification email failed: ${verifyResult.error?.message || "Please use Forgot Password flow or try again later."}`;
      if (verifyResult.ok) {
        markVerificationSentNow(email);
        startVerificationCooldown(110);
      }
      return;
    } else {
      const credential = await signInWithEmailAndPassword(auth, email, password);
      await credential.user.reload();
      if (!credential.user.emailVerified) {
        let verifyResult = { ok: true, skipped: true };
        if (canAutoResendVerification(email)) {
          verifyResult = await sendVerificationEmailReliable(credential.user);
          if (verifyResult.ok) markVerificationSentNow(email);
        }
        await signOut(auth);
        error.style.display = "block";
        error.style.color = "#ff6b6b";
        error.innerText = verifyResult.ok
          ? (verifyResult.skipped
            ? "Please verify your email before signing in. A verification email was recently sent ‚Äî check Inbox/Spam/Promotions."
            : "Please verify your email before signing in. Verification email sent.")
          : `Please verify your email before signing in. Could not send verification email: ${verifyResult.error?.message || "try again later."}`;
        if (verifyResult.ok) startVerificationCooldown(110);
        return;
      }
    }
  } catch (err) {
    error.style.display = "block";
    error.style.color = "#ff6b6b";
    error.innerText = err.message;
  }
}

function signOutUser() {
  closeAccountPanel();
  signOut(auth);
}

async function handleGoogleAuth() {
  const error = document.getElementById("signInError");
  error.style.display = "none";

  if (window.location.protocol === "file:") {
    error.style.display = "block";
    error.innerText = "Google auth does not work on file://. Start a local server and open via http://localhost:<port>.";
    return;
  }

  try {
    await signInWithPopup(auth, googleProvider);
  } catch (err) {
    const currentOrigin = window.location.origin || "unknown-origin";
    const currentHost = window.location.hostname || "unknown-host";
    const isUnauthorizedDomain = (err?.code || "").includes("unauthorized-domain");
    error.style.display = "block";
    error.innerText = isUnauthorizedDomain
      ? `Unauthorized domain. Current origin: ${currentOrigin}. Add '${currentHost}' in Firebase Auth > Settings > Authorized domains, then hard refresh.`
      : (err.message || "Google authentication failed.");
  }
}

async function sendResetPasswordEmail() {
  const email = emailInput.value.trim().toLowerCase();
  const error = document.getElementById("signInError");
  error.style.display = "none";

  if (!email) {
    error.style.display = "block";
    error.style.color = "#ff6b6b";
    error.innerText = "Enter your email first, then tap Reset Password.";
    return;
  }

  try {
    const methods = await fetchSignInMethodsForEmail(auth, email);
    if (methods.includes("google.com") && !methods.includes("password")) {
      error.style.display = "block";
      error.style.color = "#ff6b6b";
      error.innerText = "This email uses Google sign-in. Use Google login (no password to reset).";
      return;
    }

    const resetResult = await sendPasswordResetReliable(email);
    if (!resetResult.ok) {
      throw resetResult.error;
    }
    error.style.display = "block";
    error.style.color = "#7CFFB2";
    error.innerText = "Password reset email sent. Check Inbox/Spam/Promotions.";
  } catch (err) {
    error.style.display = "block";
    error.style.color = "#ff6b6b";
    error.innerText = err?.message || "Could not send reset email.";
    console.error("Reset password error:", err?.code || err);
  }
}

async function sendAccountResetPasswordEmail() {
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  const email = (user.email || accountEmail?.innerText || "").trim().toLowerCase();
  if (!email || email === "-") {
    showToast("No email found for this account.");
    return;
  }

  try {
    const methods = await fetchSignInMethodsForEmail(auth, email);
    if (methods.includes("google.com") && !methods.includes("password")) {
      showToast("This account uses Google sign-in, so no password reset is needed.");
      return;
    }

    const resetResult = await sendPasswordResetReliable(email);
    if (!resetResult.ok) {
      throw resetResult.error;
    }
    showToast(`Password reset email sent to ${email}.`);
  } catch (err) {
    console.error("Account reset password error:", err?.code || err);
    showToast(err?.message || "Could not send reset email.");
  }
}

// ---------- DASHBOARD JS ----------
const moodHistory=[],waterHistory=[],sleepHistory=[];
const moodDates=[];
const waterDates=[];
const sleepDates=[];
const taskEntries=[];
const gratitudeEntries=[];
const rescueEvents=[];
const habitQuests=[];
const burnoutRecoveryPlan=[];
const aiRecentPrompts=[];
const aiSessionState = {
  lastIntent: "",
  lastAdvice: [],
  userEmotion: "",
  lastUserMessage: "",
  turnCount: 0,
  userFacts: {
    name: "",
    goal: "",
    likes: [],
    dislikes: []
  },
  lastSnapshot: null,
  conversationSummary: "",
  topicHistory: []
};
const AI_MODE_PRESETS = {
  balanced: { depth: 2, style: "balanced" },
  coach: { depth: 3, style: "coach" },
  strict: { depth: 3, style: "strict" },
  creative: { depth: 3, style: "creative" },
  ultra: { depth: 4, style: "ultra" }
};
let aiReasoningMode = "ultra";
const challengeDates=[];
let dailyChallengeCompleted=false;
let currentChallengeText="";
let currentChallengeDateKey="";
let challengeWatcherInterval=null;
let dailyChallengeResetTimeoutId = null;
let weeklyGraphResetTimeoutId = null;
let weeklyGraphCountdownIntervalId = null;
let insightsPersistTimer=null;
let waterGoalResetTimeoutId = null;
let insightMetricIndex = 0;
let questDateKey = "";
let questXp = 0;
let questShieldAvailable = false;
let questStreakCount = 0;
let questLastStreakDateKey = "";
let questWeekStartKey = "";
let weeklyQuestUsedIds = [];
let questCompletedDateKeys = [];
let dailyQuestResetTimeoutId = null;
let weeklyTargets = {
  waterGoal: 0,
  sleepTarget: 8,
  taskTarget: 5
};
const userTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone || "local";
const FIRESTORE_CRASH_MESSAGE = "Something went wrong. Please try again later.";
const AI_DAILY_LIMIT = 20;
const MOOD_DAILY_LIMIT = 20;
const REMINDER_DAILY_LIMIT = 30;
const TASK_DAILY_LIMIT = 50;
const GRATITUDE_DAILY_LIMIT = 30;
const WATER_DAILY_LIMIT = 40;
const WATER_MAX_GLASSES_PER_ENTRY = 10;
const REMINDER_MAX_MINUTES = 1440;
const REMINDER_MAX_TEXT_LENGTH = 140;
const SLEEP_DAILY_LIMIT = 8;
const STARTUP_PLAN_DAILY_LIMIT = 2;
const STARTUP_REPORT_WEEKLY_LIMIT = 1;
const MAX_REMINDER_ENTRIES = 500;
const MAX_TASK_ENTRIES = 1500;
const MAX_GRATITUDE_ENTRIES = 1200;
const MAX_WATER_ENTRIES = 1500;
const MAX_SLEEP_ENTRIES = 800;
const MAX_MOOD_ENTRIES = 1200;
const SERVER_CLOCK_RESYNC_MS = 5 * 60 * 1000;
let aiUsageDateKeyGMT = "";
let aiUsageCount = 0;
let aiUsageStateLoaded = false;
let dailyUsageDateKey = "";
let moodDailyUsageCount = 0;
let taskDailyUsageCount = 0;
let sleepDailyUsageCount = 0;
let waterDailyUsageCount = 0;
let reminderDailyUsageCount = 0;
let gratitudeDailyUsageCount = 0;
let dailyUsageLoaded = false;
let serverTimeOffsetMs = 0;
let serverTimeSyncedAt = 0;
let limitCountdownInterval = null;
let lastFirestoreErrorAlertAt = 0;
let persistedBarGraphs = null;
const reminderIntervals = new Map();
let uxToastTimer = null;
let uxToastActionHandler = null;
let pendingAiClearOperation = null;
let pendingWaterClearOperation = null;
let aiChatSubmitting = false;
let reminderSubmitting = false;
let taskSubmitting = false;
let moodSubmitting = false;
let waterSubmitting = false;
let sleepSubmitting = false;
let gratitudeSubmitting = false;

function getDefaultStartupFeatureState() {
  return {};
}

let startupFeatureState = getDefaultStartupFeatureState();
let startupCurrentPlan = [];
let startupWeeklyReportCache = "";
let startupPlanGeneratedOnce = false;
let startupReportGeneratedOnce = false;
let startupUsageState = getDefaultStartupUsageState();

function getStartupWeekKey(dateValue = getServerNowDate()) {
  const date = toDateSafe(dateValue) || getServerNowDate();
  const sunday = new Date(date);
  sunday.setUTCHours(0, 0, 0, 0);
  sunday.setUTCDate(sunday.getUTCDate() - sunday.getUTCDay());
  return dateToKey(sunday) || getTodayKey();
}

function getDefaultStartupUsageState() {
  return {
    planDateKey: getTodayKey(),
    planCount: 0,
    reportWeekKey: getStartupWeekKey(),
    reportCount: 0
  };
}

function normalizeStartupUsageState(input) {
  const source = input && typeof input === "object" ? input : {};
  const normalized = {
    planDateKey: String(source.planDateKey || getTodayKey()),
    planCount: Math.max(0, Number(source.planCount) || 0),
    reportWeekKey: String(source.reportWeekKey || getStartupWeekKey()),
    reportCount: Math.max(0, Number(source.reportCount) || 0)
  };

  if (normalized.planDateKey !== getTodayKey()) {
    normalized.planDateKey = getTodayKey();
    normalized.planCount = 0;
  }
  if (normalized.reportWeekKey !== getStartupWeekKey()) {
    normalized.reportWeekKey = getStartupWeekKey();
    normalized.reportCount = 0;
  }

  return normalized;
}

async function saveStartupUsageState(userId) {
  if (!userId) return;
  try {
    await setDoc(doc(db, "users", userId, "settings", "startupUsage"), {
      ...startupUsageState,
      updatedAt: serverTimestamp()
    }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadStartupUsageState(userId) {
  startupUsageState = getDefaultStartupUsageState();
  if (!userId) return;

  let changed = false;
  try {
    const snapshot = await getDoc(doc(db, "users", userId, "settings", "startupUsage"));
    if (snapshot.exists()) {
      const raw = snapshot.data();
      startupUsageState = normalizeStartupUsageState(raw);
      changed = String(raw?.planDateKey || "") !== startupUsageState.planDateKey
        || Number(raw?.planCount) !== startupUsageState.planCount
        || String(raw?.reportWeekKey || "") !== startupUsageState.reportWeekKey
        || Number(raw?.reportCount) !== startupUsageState.reportCount;
    } else {
      changed = true;
    }
  } catch (err) {
    notifyFirestoreError(err);
    return;
  }

  if (changed) await saveStartupUsageState(userId);
  refreshStartupFeatures();
}

async function ensureStartupUsageCurrent(userId) {
  if (!userId) return;
  let changed = false;

  const todayKey = getTodayKey();
  const weekKey = getStartupWeekKey();

  if (startupUsageState.planDateKey !== todayKey) {
    startupUsageState.planDateKey = todayKey;
    startupUsageState.planCount = 0;
    changed = true;
  }

  if (startupUsageState.reportWeekKey !== weekKey) {
    startupUsageState.reportWeekKey = weekKey;
    startupUsageState.reportCount = 0;
    changed = true;
  }

  if (changed) await saveStartupUsageState(userId);
}

const SUCCESS_CHEERS = [
  "Nice work ‚Äî momentum is building.",
  "Great consistency today.",
  "Solid progress ‚Äî keep going.",
  "Good job, you‚Äôre on track.",
  "Small step done, big win later."
];

function getRandomCheer() {
  const index = Math.floor(Math.random() * SUCCESS_CHEERS.length);
  return SUCCESS_CHEERS[index] || "Nice work.";
}

function showToast(message, options = {}) {
  if (!uxToast || !uxToastText || !uxToastAction) return;

  const duration = Math.max(1200, Number(options.duration) || 2600);
  uxToastText.innerText = String(message || "");

  if (uxToastTimer) {
    clearTimeout(uxToastTimer);
    uxToastTimer = null;
  }

  uxToastActionHandler = typeof options.onAction === "function" ? options.onAction : null;
  if (options.actionLabel && uxToastActionHandler) {
    uxToastAction.style.display = "inline-flex";
    uxToastAction.innerText = String(options.actionLabel);
  } else {
    uxToastAction.style.display = "none";
    uxToastAction.innerText = "";
  }

  uxToast.style.display = "flex";
  uxToastTimer = setTimeout(() => {
    uxToast.style.display = "none";
    uxToastTimer = null;
    uxToastActionHandler = null;
  }, duration);
}

if (uxToastAction) {
  uxToastAction.onclick = () => {
    if (typeof uxToastActionHandler === "function") {
      const handler = uxToastActionHandler;
      uxToastActionHandler = null;
      handler();
    }
    if (uxToast) uxToast.style.display = "none";
    if (uxToastTimer) {
      clearTimeout(uxToastTimer);
      uxToastTimer = null;
    }
  };
}

function setEmptyState(containerEl, message) {
  if (!containerEl) return;
  containerEl.innerHTML = `<div class="status-empty">${message}</div>`;
}

function setLoadingState(containerEl, message = "Loading...") {
  if (!containerEl) return;
  containerEl.innerHTML = `<div class="status-loading">${message}</div>`;
}

function clearStatusState(containerEl) {
  if (!containerEl) return;
  const placeholders = containerEl.querySelectorAll(".status-empty, .status-loading");
  placeholders.forEach((node) => node.remove());
}

function scheduleEmptyState(containerEl, itemSelector, message, delayMs = 220) {
  if (!containerEl) return;
  setTimeout(() => {
    if (!containerEl || !containerEl.isConnected) return;
    if (containerEl.querySelector(".status-loading")) return;
    if (containerEl.querySelector(itemSelector)) return;
    setEmptyState(containerEl, message);
  }, Math.max(0, Number(delayMs) || 0));
}

function setInitialLoadingStates() {
  setLoadingState(chat, "Loading your AI conversations...");
  setLoadingState(reminders, "Loading reminders...");
  setLoadingState(taskList, "Loading tasks...");
  setLoadingState(moodLogs, "Loading mood logs...");
  setLoadingState(gratitudeLogs, "Loading gratitude notes...");
  if (questListEl) setLoadingState(questListEl, "Preparing today‚Äôs habit quests...");
}

function hasAnyClearableData() {
  const hasAiChats = !!chat?.querySelector?.(".chat-message");
  const hasReminders = !!reminders?.querySelector?.(".item-row");
  const hasTasks = taskEntries.length > 0 || !!taskList?.querySelector?.(".item-row");
  const hasMoods = moodHistory.length > 0 || !!moodLogs?.querySelector?.(".mood-item");
  const hasWaterLogs = waterHistory.length > 0;
  const hasSleepLogs = sleepHistory.length > 0;
  const hasGratitudeLogs = gratitudeEntries.length > 0 || !!gratitudeLogs?.querySelector?.(".item-row");
  const hasChallengeHistory = challengeDates.length > 0;
  const hasRescueHistory = rescueEvents.length > 0;
  const hasQuestProgress = questXp > 0 || questStreakCount > 0 || !!questShieldAvailable || (questCompletedDateKeys || []).length > 0;
  const hasWaterGoal = (Number(waterGoal) || 0) > 0;

  return !!(
    hasAiChats ||
    hasReminders ||
    hasTasks ||
    hasMoods ||
    hasWaterLogs ||
    hasSleepLogs ||
    hasGratitudeLogs ||
    hasChallengeHistory ||
    hasRescueHistory ||
    hasQuestProgress ||
    hasWaterGoal
  );
}

function updateClearDataButtonState() {
  if (!clearDataBtn) return;
  const hasData = hasAnyClearableData();
  clearDataBtn.disabled = !hasData;
  clearDataBtn.title = hasData ? "" : "No data to clear";
}

function notifyFirestoreError(err) {
  console.error("Firestore operation failed:", err);
  const now = Date.now();
  if (now - lastFirestoreErrorAlertAt > 4000) {
    alert(FIRESTORE_CRASH_MESSAGE);
    lastFirestoreErrorAlertAt = now;
  }
}

function dateToKey(dateValue) {
  const date = dateValue instanceof Date ? dateValue : new Date(dateValue);
  if (Number.isNaN(date.getTime())) return null;
  const year = date.getUTCFullYear();
  const month = String(date.getUTCMonth() + 1).padStart(2, "0");
  const day = String(date.getUTCDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

function formatCountdownClock(milliseconds) {
  const safeMs = Math.max(0, Number(milliseconds) || 0);
  const totalSeconds = Math.floor(safeMs / 1000);
  const hours = Math.floor(totalSeconds / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;
  return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
}

function updateLimitCountdownNote(noteEl) {
  if (!noteEl) return;
  const baseMessage = noteEl.dataset.baseMessage || "";
  if (!baseMessage) return;
  const remaining = getMillisecondsUntilNextMidnight();
  noteEl.innerText = `${baseMessage}. Resets in ${formatCountdownClock(remaining)} (server time). Come back tomorrow.`;
}

function ensureLimitCountdownTicker() {
  if (limitCountdownInterval) return;
  limitCountdownInterval = setInterval(() => {
    const notes = document.querySelectorAll(".limit-note.show[data-live-countdown='1']");
    notes.forEach((noteEl) => updateLimitCountdownNote(noteEl));
  }, 1000);
}

function applyLimitState(noteEl, controls, limited, message) {
  if (noteEl) {
    if (limited) {
      const needsLiveCountdown = /Resets at 00:00 server time\.?$/i.test(message || "");
      if (needsLiveCountdown) {
        noteEl.dataset.liveCountdown = "1";
        noteEl.dataset.baseMessage = String(message || "").replace(/\s*Resets at 00:00 server time\.?$/i, "").trim();
        updateLimitCountdownNote(noteEl);
        ensureLimitCountdownTicker();
      } else {
        noteEl.innerText = message || "";
        delete noteEl.dataset.liveCountdown;
        delete noteEl.dataset.baseMessage;
      }
    } else {
      noteEl.innerText = "";
      delete noteEl.dataset.liveCountdown;
      delete noteEl.dataset.baseMessage;
    }
    noteEl.classList.toggle("show", !!limited);
  }
  (controls || []).forEach((control) => {
    if (!control) return;
    control.disabled = !!limited;
  });
}

function countTodayFromDates(dateValues) {
  const todayKey = getTodayKey();
  return (dateValues || []).reduce((count, value) => {
    return dateToKey(value) === todayKey ? count + 1 : count;
  }, 0);
}

function getMoodDailyCount() {
  const logsCount = countTodayFromDates(moodDates);
  return Math.max(logsCount, moodDailyUsageCount);
}

function getTaskDailyCount() {
  const todayKey = getTodayKey();
  const logsCount = taskEntries.reduce((total, entry) => (dateToKey(entry.time) === todayKey ? total + 1 : total), 0);
  return Math.max(logsCount, taskDailyUsageCount);
}

function getSleepDailyCount() {
  const logsCount = countTodayFromDates(sleepDates);
  return Math.max(logsCount, sleepDailyUsageCount);
}

function getWaterDailyCount() {
  const logsCount = countTodayFromDates(waterDates);
  return Math.max(logsCount, waterDailyUsageCount);
}

function countTodayRemindersFromDocs(reminderDocs) {
  const todayKey = getTodayKey();
  return (reminderDocs || []).reduce((total, docSnap) => {
    const data = typeof docSnap.data === "function" ? docSnap.data() : docSnap;
    const dateValue = toDateSafe(data.createdAt)
      || (Number(data.targetAtMs) ? new Date(Number(data.targetAtMs)) : null)
      || getServerNowDate();
    return dateToKey(dateValue) === todayKey ? total + 1 : total;
  }, 0);
}

function getGratitudeDailyCount() {
  const todayKey = getTodayKey();
  const logsCount = gratitudeEntries.reduce((total, entry) => (dateToKey(entry.time) === todayKey ? total + 1 : total), 0);
  return Math.max(logsCount, gratitudeDailyUsageCount);
}

function setRemoveButtonsDisabled(containerEl, disabled) {
  if (!containerEl) return;
  const buttons = containerEl.querySelectorAll(".remove-entry-btn");
  buttons.forEach((button) => {
    button.disabled = !!disabled;
  });
}

function updateMoodLimitUI() {
  const count = getMoodDailyCount();
  const limited = count >= MOOD_DAILY_LIMIT;
  applyLimitState(moodLimitError, [mood, moodSaveBtn], limited, `You‚Äôve reached today‚Äôs mood log limit (${MOOD_DAILY_LIMIT}/day). Resets at 00:00 server time.`);
  setRemoveButtonsDisabled(moodLogs, limited);
}

function updateTaskLimitUI() {
  const count = getTaskDailyCount();
  const limited = count >= TASK_DAILY_LIMIT;
  applyLimitState(taskLimitError, [task, taskAddBtn], limited, `You‚Äôve reached today‚Äôs task limit (${TASK_DAILY_LIMIT}/day). Resets at 00:00 server time.`);
  setRemoveButtonsDisabled(taskList, limited);
}

function updateGratitudeLimitUI() {
  const count = getGratitudeDailyCount();
  const limited = count >= GRATITUDE_DAILY_LIMIT;
  applyLimitState(gratitudeLimitError, [gratitudeInput, gratitudeSaveBtn], limited, `You‚Äôve reached today‚Äôs gratitude limit (${GRATITUDE_DAILY_LIMIT}/day). Resets at 00:00 server time.`);
  setRemoveButtonsDisabled(gratitudeLogs, limited);
}

function updateWaterLimitUI() {
  const count = getWaterDailyCount();
  const limited = count >= WATER_DAILY_LIMIT;
  applyLimitState(waterLimitError, [waterInput, waterTrackBtn], limited, `You‚Äôve reached today‚Äôs water log limit (${WATER_DAILY_LIMIT}/day). Resets at 00:00 server time.`);
}

function updateSleepLimitUI() {
  const count = getSleepDailyCount();
  const limited = count >= SLEEP_DAILY_LIMIT;
  applyLimitState(sleepLimitError, [sleepInput, sleepSaveBtn], limited, `You‚Äôve reached today‚Äôs sleep log limit (${SLEEP_DAILY_LIMIT}/day). Resets at 00:00 server time.`);
}

function updateAiLimitUI() {
  const dailyLimit = getCurrentAiDailyLimit();
  const limited = aiUsageCount >= dailyLimit;
  applyLimitState(aiLimitError, [aiInput, aiTalkBtn], limited, `Daily AI limit reached (${dailyLimit}/${dailyLimit}). Resets at 00:00 server time.`);

  const editButtons = chat?.querySelectorAll?.(".chat-edit-btn") || [];
  editButtons.forEach((button) => {
    button.disabled = !!limited;
    if (limited) button.title = "AI daily limit reached";
    else button.removeAttribute("title");
  });
}

function getCurrentAiDailyLimit() {
  return AI_DAILY_LIMIT;
}

async function updateReminderLimitUI(userId) {
  if (!userId) {
    applyLimitState(reminderLimitError, [reminderText, reminderMinutes, reminderSetBtn], false, "");
    setRemoveButtonsDisabled(reminders, false);
    return;
  }

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "reminders"));
    const count = Math.max(countTodayRemindersFromDocs(snapshot.docs), reminderDailyUsageCount);

    const limited = count >= REMINDER_DAILY_LIMIT;
    applyLimitState(reminderLimitError, [reminderText, reminderMinutes, reminderSetBtn], limited, `You‚Äôve reached today‚Äôs reminder limit (${REMINDER_DAILY_LIMIT}/day). Resets at 00:00 server time.`);
    setRemoveButtonsDisabled(reminders, limited);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function resetAllLimitUIs() {
  applyLimitState(aiLimitError, [aiInput, aiTalkBtn], false, "");
  applyLimitState(reminderLimitError, [reminderText, reminderMinutes, reminderSetBtn], false, "");
  applyLimitState(taskLimitError, [task, taskAddBtn], false, "");
  applyLimitState(moodLimitError, [mood, moodSaveBtn], false, "");
  applyLimitState(waterLimitError, [waterInput, waterTrackBtn], false, "");
  applyLimitState(sleepLimitError, [sleepInput, sleepSaveBtn], false, "");
  applyLimitState(gratitudeLimitError, [gratitudeInput, gratitudeSaveBtn], false, "");
  setRemoveButtonsDisabled(reminders, false);
  setRemoveButtonsDisabled(taskList, false);
  setRemoveButtonsDisabled(moodLogs, false);
  setRemoveButtonsDisabled(gratitudeLogs, false);
}

function calcStreak(dateValues) {
  const daySet = new Set(
    dateValues
      .map((value) => dateToKey(value))
      .filter(Boolean)
  );

  let streak = 0;
  const today = getServerNowDate();
  today.setUTCHours(0, 0, 0, 0);

  while (true) {
    const dayKey = dateToKey(today);
    if (!daySet.has(dayKey)) break;
    streak++;
    today.setUTCDate(today.getUTCDate() - 1);
  }

  return streak;
}

function setInsightBar(element, percent) {
  const bounded = Math.max(0, Math.min(100, percent));
  element.style.width = `${bounded}%`;
}

function getCurrentWeekDates() {
  const now = getServerNowDate();
  const currentDayIndex = now.getUTCDay();
  const sunday = new Date(now);
  sunday.setUTCDate(now.getUTCDate() - currentDayIndex);
  sunday.setUTCHours(0, 0, 0, 0);

  return Array.from({ length: 7 }, (_, index) => {
    const day = new Date(sunday);
    day.setUTCDate(sunday.getUTCDate() + index);
    return day;
  });
}

function moodToScore(value) {
  const moodValue = String(value || "");
  if (moodValue.includes("üòä")) return 3;
  if (moodValue.includes("üòê")) return 2;
  if (moodValue.includes("üòî")) return 1;
  return 0;
}

function getInsightSeries(metricType) {
  const days = getCurrentWeekDates();
  const labels = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

  if (metricType === "tasks") {
    const values = days.map((day) => {
      const dayKey = dateToKey(day);
      const dayTasks = taskEntries.filter((entry) => dateToKey(entry.time) === dayKey);
      if (!dayTasks.length) return 0;
      const completedCount = dayTasks.filter((entry) => !!entry.completed).length;
      return Math.round((completedCount / dayTasks.length) * 100);
    });
    return { labels, values, maxValue: 100 };
  }

  if (metricType === "sleep") {
    const values = days.map((day) => {
      const dayKey = dateToKey(day);
      let latest = 0;
      sleepHistory.forEach((value, index) => {
        if (dateToKey(sleepDates[index]) === dayKey) latest = Number(value) || latest;
      });
      return Number(latest.toFixed(1));
    });
    return { labels, values, maxValue: 12 };
  }

  if (metricType === "mood") {
    const values = days.map((day) => {
      const dayKey = dateToKey(day);
      let total = 0;
      let count = 0;
      moodHistory.forEach((value, index) => {
        if (dateToKey(moodDates[index]) !== dayKey) return;
        const score = moodToScore(value);
        if (!score) return;
        total += score;
        count += 1;
      });
      return count ? Number((total / count).toFixed(2)) : 0;
    });
    return { labels, values, maxValue: 3 };
  }

  const values = days.map((day) => {
    const dayKey = dateToKey(day);
    let latestValue = 0;
    for (let index = waterHistory.length - 1; index >= 0; index -= 1) {
      if (dateToKey(waterDates[index]) !== dayKey) continue;
      latestValue = Number(waterHistory[index]) || 0;
      break;
    }
    return Number(latestValue.toFixed(1));
  });
  const waterScaleMax = Math.max(8, ...values.map((value) => Number(value) || 0));
  return { labels, values, maxValue: waterScaleMax };
}

function getCurrentWeekRangeKeys() {
  const weekDates = getCurrentWeekDates();
  return {
    weekStartKey: dateToKey(weekDates[0]) || getTodayKey(),
    weekEndKey: dateToKey(weekDates[weekDates.length - 1]) || getTodayKey()
  };
}

function getSeriesWithPersistedFallback(metricName, computedSeries, weekRange) {
  const baseSeries = computedSeries && !Array.isArray(computedSeries)
    ? computedSeries
    : { labels: [], values: [], maxValue: 0 };

  const computedValues = Array.isArray(baseSeries.values) ? baseSeries.values : [];
  const hasComputedSignal = computedValues.some((value) => Math.abs(Number(value) || 0) > 0);
  if (hasComputedSignal) return baseSeries;

  const persisted = persistedBarGraphs;
  if (!persisted || persisted.weekStartKey !== weekRange.weekStartKey || persisted.weekEndKey !== weekRange.weekEndKey) {
    return baseSeries;
  }

  const metricPayload = persisted?.[metricName];
  if (!metricPayload || !Array.isArray(metricPayload.values)) return baseSeries;

  return {
    labels: Array.isArray(persisted.labels) ? persisted.labels : (Array.isArray(baseSeries.labels) ? baseSeries.labels : []),
    values: metricPayload.values,
    maxValue: Number(metricPayload.maxValue) || Number(baseSeries.maxValue) || 0
  };
}

function renderInsightMetricView(payload) {
  if (insightMetricTitle) insightMetricTitle.innerText = payload.title;
  if (insightMetricLabel) insightMetricLabel.innerText = payload.label;
  if (insightAxisLayer && insightBarLayer && insightBarLabelLayer && insightLineGraph) {
    const seriesPayload = payload.series && !Array.isArray(payload.series)
      ? payload.series
      : { labels: [], values: Array.isArray(payload.series) ? payload.series : [], maxValue: 0 };
    const labels = Array.isArray(seriesPayload.labels) && seriesPayload.labels.length ? seriesPayload.labels : ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    const sourceValues = Array.isArray(seriesPayload.values) ? seriesPayload.values : [];
    const values = sourceValues.length ? sourceValues : new Array(labels.length).fill(0);

    const yAxisX = 52;
    const chartRightPadding = 20;
    const chartTop = 16;
    const chartBottom = 150;
    const labelY = 172;
    const valueOffset = 6;
    const chartHeight = Math.max(1, chartBottom - chartTop);
    const providedMax = Math.max(0, Number(seriesPayload.maxValue) || 0);
    const rawMaxValue = Math.max(1, providedMax, ...values.map((value) => Number(value) || 0));
    const yMaxValue = rawMaxValue <= 5 ? 5 : Math.ceil(rawMaxValue / 5) * 5;
    const usableWidth = Math.max(520, 82 * labels.length);
    const graphWidth = Math.max(640, yAxisX + usableWidth + chartRightPadding);
    const viewBoxHeight = 188;
    const barAreaWidth = Math.max(1, graphWidth - yAxisX - chartRightPadding);
    const slotWidth = barAreaWidth / labels.length;
    const barWidth = Math.min(28, Math.max(14, slotWidth * 0.38));

    if (insightGraphTrack) {
      insightGraphTrack.style.width = `${graphWidth}px`;
      insightGraphTrack.style.minWidth = `${graphWidth}px`;
    }
    insightLineGraph.style.width = "100%";
    insightLineGraph.style.minWidth = "100%";
    insightLineGraph.setAttribute("viewBox", `0 0 ${graphWidth} ${viewBoxHeight}`);

    insightAxisLayer.innerHTML = "";
    insightBarLayer.innerHTML = "";
    insightBarLabelLayer.innerHTML = "";

    const yTicks = 5;
    for (let tick = 0; tick <= yTicks; tick += 1) {
      const ratio = tick / yTicks;
      const y = chartBottom - (ratio * chartHeight);
      const tickValue = Math.round(yMaxValue * ratio);

      const tickLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
      tickLabel.setAttribute("x", (yAxisX - 8).toFixed(2));
      tickLabel.setAttribute("y", (y + 3).toFixed(2));
      tickLabel.setAttribute("text-anchor", "end");
      tickLabel.setAttribute("class", "insight-tick-label");
      tickLabel.textContent = String(tickValue);
      insightAxisLayer.appendChild(tickLabel);
    }

    const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    yAxis.setAttribute("x1", yAxisX.toFixed(2));
    yAxis.setAttribute("y1", chartTop.toFixed(2));
    yAxis.setAttribute("x2", yAxisX.toFixed(2));
    yAxis.setAttribute("y2", chartBottom.toFixed(2));
    yAxis.setAttribute("class", "insight-axis-line");
    insightAxisLayer.appendChild(yAxis);

    const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
    xAxis.setAttribute("x1", yAxisX.toFixed(2));
    xAxis.setAttribute("y1", chartBottom.toFixed(2));
    xAxis.setAttribute("x2", (graphWidth - chartRightPadding).toFixed(2));
    xAxis.setAttribute("y2", chartBottom.toFixed(2));
    xAxis.setAttribute("class", "insight-axis-line");
    insightAxisLayer.appendChild(xAxis);

    values.forEach((rawValue, index) => {
      const value = Math.max(0, Number(rawValue) || 0);
      const normalized = Math.max(0, Math.min(1, value / yMaxValue));
      const barHeight = normalized > 0 ? Math.max(3, normalized * chartHeight) : 0;
      const slotStart = yAxisX + (index * slotWidth);
      const x = slotStart + ((slotWidth - barWidth) / 2);
      const y = chartBottom - barHeight;

      const bar = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      bar.setAttribute("x", x.toFixed(2));
      bar.setAttribute("y", y.toFixed(2));
      bar.setAttribute("width", barWidth.toFixed(2));
      bar.setAttribute("height", barHeight.toFixed(2));
      bar.setAttribute("rx", "6");
      bar.setAttribute("ry", "6");
      bar.setAttribute("class", "insight-column");
      insightBarLayer.appendChild(bar);

      const valueLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
      valueLabel.setAttribute("x", (x + (barWidth / 2)).toFixed(2));
      valueLabel.setAttribute("y", (Math.max(chartTop, y - valueOffset)).toFixed(2));
      valueLabel.setAttribute("class", "insight-bar-value");
      valueLabel.textContent = Number.isInteger(value) ? String(value) : value.toFixed(1);
      insightBarLabelLayer.appendChild(valueLabel);

      const dayLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
      dayLabel.setAttribute("x", (x + (barWidth / 2)).toFixed(2));
      dayLabel.setAttribute("y", labelY.toFixed(2));
      dayLabel.setAttribute("class", "insight-bar-label");
      dayLabel.textContent = labels[index] || "";
      insightBarLabelLayer.appendChild(dayLabel);
    });

    if (insightGraphScroll) {
      insightGraphScroll.scrollLeft = 0;
    }
  }
}

function nextInsightMetric() {
  insightMetricIndex = (insightMetricIndex + 1) % 4;
  updateInsights();
  if (insightsCard?.scrollIntoView) {
    insightsCard.scrollIntoView({ behavior: "smooth", block: "start" });
  }
}

function dateKeyToDate(dateKey) {
  if (!dateKey || typeof dateKey !== "string") return null;
  const [year, month, day] = dateKey.split("-").map(Number);
  if (!year || !month || !day) return null;
  const parsed = new Date(year, month - 1, day, 12, 0, 0, 0);
  return Number.isNaN(parsed.getTime()) ? null : parsed;
}

function toDateSafe(value) {
  if (!value) return null;
  if (value instanceof Date) return Number.isNaN(value.getTime()) ? null : value;
  const viaToDate = value?.toDate?.();
  if (viaToDate instanceof Date && !Number.isNaN(viaToDate.getTime())) return viaToDate;
  const parsed = new Date(value);
  return Number.isNaN(parsed.getTime()) ? null : parsed;
}

async function trimCollectionToMaxEntries(userId, collectionName, maxEntries, getEntryTimeMs) {
  if (!userId || !collectionName || !maxEntries) return;

  try {
    const snapshot = await getDocs(collection(db, "users", userId, collectionName));
    const docs = snapshot.docs.map((docSnap) => {
      const payload = { id: docSnap.id, ...docSnap.data() };
      const ms = Number(getEntryTimeMs(payload)) || 0;
      return { ...payload, _ms: ms };
    });

    if (docs.length <= maxEntries) return;

    docs.sort((a, b) => a._ms - b._ms);
    const toDelete = docs.slice(0, docs.length - maxEntries);
    await Promise.all(toDelete.map((entry) => deleteDoc(doc(db, "users", userId, collectionName, entry.id))));
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function isInRange(dateValue, startDate, endDate) {
  const parsed = toDateSafe(dateValue);
  if (!parsed) return false;
  return parsed >= startDate && parsed <= endDate;
}

function getWeekRanges() {
  const now = getServerNowDate();
  const currentEnd = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 23, 59, 59, 999));
  const currentStart = new Date(currentEnd);
  currentStart.setUTCDate(currentStart.getUTCDate() - 6);
  currentStart.setUTCHours(0, 0, 0, 0);

  const previousEnd = new Date(currentStart);
  previousEnd.setMilliseconds(previousEnd.getMilliseconds() - 1);
  const previousStart = new Date(previousEnd);
  previousStart.setUTCDate(previousStart.getUTCDate() - 6);
  previousStart.setUTCHours(0, 0, 0, 0);

  return {
    currentStart,
    currentEnd,
    previousStart,
    previousEnd
  };
}

function computeWeekMetrics(startDate, endDate) {
  let moodSum = 0;
  let moodCount = 0;
  moodHistory.forEach((entry, index) => {
    const moodDate = moodDates[index];
    if (!isInRange(moodDate, startDate, endDate)) return;
    const score = String(entry || "").includes("üòä") ? 3 : String(entry || "").includes("üòê") ? 2 : String(entry || "").includes("üòî") ? 1 : 0;
    if (!score) return;
    moodSum += score;
    moodCount += 1;
  });

  let sleepSum = 0;
  let sleepCount = 0;
  sleepHistory.forEach((entry, index) => {
    const sleepDate = sleepDates[index];
    if (!isInRange(sleepDate, startDate, endDate)) return;
    sleepSum += Number(entry) || 0;
    sleepCount += 1;
  });

  const waterByDay = new Map();
  waterHistory.forEach((entry, index) => {
    const waterDate = waterDates[index];
    if (!isInRange(waterDate, startDate, endDate)) return;
    const dayKey = dateToKey(waterDate);
    if (!dayKey) return;
    waterByDay.set(dayKey, (waterByDay.get(dayKey) || 0) + (Number(entry) || 0));
  });

  const tasksInPeriod = taskEntries.filter((entry) => {
    const taskDate = toDateSafe(entry.time);
    return isInRange(taskDate, startDate, endDate);
  });
  const completedInPeriod = tasksInPeriod.filter((entry) => !!entry.completed).length;

  const rescuesInPeriod = rescueEvents.filter((entry) => isInRange(entry.time, startDate, endDate)).length;

  return {
    moodScore: moodCount ? moodSum / moodCount : 0,
    sleepAvg: sleepCount ? sleepSum / sleepCount : 0,
    waterDailyAvg: waterByDay.size ? [...waterByDay.values()].reduce((a, b) => a + b, 0) / 7 : 0,
    taskCompletion: tasksInPeriod.length ? completedInPeriod / tasksInPeriod.length : 0,
    rescues: rescuesInPeriod,
    taskCount: tasksInPeriod.length
  };
}

function setListItems(listElement, items, fallbackText) {
  if (!listElement) return;
  if (!items.length) {
    listElement.innerHTML = `<li>${fallbackText}</li>`;
    return;
  }
  listElement.innerHTML = items.map((item) => `<li>${item}</li>`).join("");
}

function renderWeeklyTargets() {
  if (!weeklyTargetsDisplay) return;
  weeklyTargetsDisplay.innerText = `Targets: Water ${weeklyTargets.waterGoal || "-"} glasses/day ‚Ä¢ Sleep ${weeklyTargets.sleepTarget || "-"} hrs ‚Ä¢ Tasks ${weeklyTargets.taskTarget || "-"}/day`;
}

function updateWeeklyReview() {
  const user = auth.currentUser;
  if (!user) return;

  const { currentStart, currentEnd, previousStart, previousEnd } = getWeekRanges();
  const current = computeWeekMetrics(currentStart, currentEnd);
  const previous = computeWeekMetrics(previousStart, previousEnd);

  if (weeklyRange) {
    weeklyRange.innerText = `Review window: ${currentStart.toLocaleDateString()} - ${currentEnd.toLocaleDateString()}`;
  }

  const improved = [];
  if (current.sleepAvg > previous.sleepAvg + 0.2) improved.push(`Sleep improved to ${current.sleepAvg.toFixed(1)}h avg.`);
  if (current.waterDailyAvg > previous.waterDailyAvg + 0.4) improved.push(`Hydration improved to ${current.waterDailyAvg.toFixed(1)} glasses/day.`);
  if (current.taskCompletion > previous.taskCompletion + 0.08) improved.push(`Task completion improved to ${Math.round(current.taskCompletion * 100)}%.`);
  if (current.moodScore > previous.moodScore + 0.15) improved.push("Mood trend improved this week.");
  if (current.rescues < previous.rescues) improved.push("Fewer rescue triggers than last week.");

  const dropped = [];
  if (current.sleepAvg < previous.sleepAvg - 0.2) dropped.push(`Sleep dropped to ${current.sleepAvg.toFixed(1)}h avg.`);
  if (current.waterDailyAvg < previous.waterDailyAvg - 0.4) dropped.push(`Hydration dipped to ${current.waterDailyAvg.toFixed(1)} glasses/day.`);
  if (current.taskCompletion < previous.taskCompletion - 0.08) dropped.push(`Task completion dropped to ${Math.round(current.taskCompletion * 100)}%.`);
  if (current.moodScore < previous.moodScore - 0.15) dropped.push("Mood trend dipped this week.");
  if (current.rescues > previous.rescues) dropped.push("Rescue triggers increased this week.");

  const actions = [];
  if (current.sleepAvg < 7) actions.push("Set wind-down reminder 60 minutes before sleep for 5 nights.");
  if (current.waterDailyAvg < Math.max(8, weeklyTargets.waterGoal || 8)) actions.push("Hit hydration target by scheduling 3 fixed water check-ins.");
  if (current.taskCompletion < 0.7) actions.push("Limit daily priority tasks to 3 and finish one before noon.");
  if (current.moodScore < 2) actions.push("Log mood twice daily and run one 2-minute rescue when stress rises.");
  if (current.rescues >= 3) actions.push("Use preventive reset every afternoon before the usual dip window.");
  while (actions.length < 3) actions.push("Keep the current routine and protect your strongest streak.");

  setListItems(weeklyImproved, improved, "No major gains yet ‚Äî consistency this week will unlock visible progress.");
  setListItems(weeklyDropped, dropped, "No clear drops this week ‚Äî maintain the trend.");
  setListItems(weeklyActions, actions.slice(0, 3), "Set one small target and repeat it daily.");
  renderWeeklyTargets();
}

async function loadWeeklyTargets(userId) {
  weeklyTargets = { waterGoal: 0, sleepTarget: 8, taskTarget: 5 };
  try {
    const snap = await getDoc(doc(db, "users", userId, "settings", "weeklyTargets"));
    if (snap.exists()) {
      const data = snap.data();
      weeklyTargets = {
        waterGoal: Number(data.waterGoal) || 0,
        sleepTarget: Number(data.sleepTarget) || 8,
        taskTarget: Number(data.taskTarget) || 5
      };
    }
  } catch (err) {
    notifyFirestoreError(err);
  }
  renderWeeklyTargets();
  updateWeeklyReview();
}

async function loadRescueEvents(userId) {
  rescueEvents.length = 0;
  try {
    const snap = await getDocs(collection(db, "users", userId, "rescueEvents"));
    snap.docs.forEach((docSnap) => {
      const data = docSnap.data();
      const time = toDateSafe(data.time);
      if (!time) return;
      rescueEvents.push({
        id: docSnap.id,
        time,
        level: data.level || ""
      });
    });
  } catch (err) {
    notifyFirestoreError(err);
  }
  updateWeeklyReview();
  updateClearDataButtonState();
}

async function setNextWeekTargets() {
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  const { currentStart, currentEnd } = getWeekRanges();
  const current = computeWeekMetrics(currentStart, currentEnd);
  const waterGoalTarget = Math.max(8, Math.min(16, Math.round(current.waterDailyAvg || 8) + 1));
  const sleepTarget = Math.max(7, Math.min(9, Math.round(((current.sleepAvg || 7) + 0.5) * 2) / 2));
  const taskTarget = Math.max(3, Math.min(10, Math.round((current.taskCount / 7) || 4)));

  weeklyTargets = {
    waterGoal: waterGoalTarget,
    sleepTarget,
    taskTarget
  };

  try {
    await setDoc(doc(db, "users", user.uid, "settings", "weeklyTargets"), {
      ...weeklyTargets,
      updatedAt: serverTimestamp()
    }, { merge: true });

    waterGoal = waterGoalTarget;
    waterGoalInput.value = String(waterGoalTarget);
    await setDoc(doc(db, "users", user.uid, "settings", "water"), {
      goal: waterGoalTarget,
      goalDateKey: getTodayKey()
    }, { merge: true });

    updateWaterProgress();
    updateWeeklyReview();
    showToast(`Targets set: Water ${waterGoalTarget}, Sleep ${sleepTarget}h, Tasks ${taskTarget}/day.`);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

const QUEST_LIBRARY = [
  { id: "sleep60_1", text: "Log at least 6 hours of sleep today.", type: "recovery", requirement: { kind: "sleep", min: 6 } },
  { id: "sleep60_2", text: "Hit a 6-hour sleep minimum tonight.", type: "recovery", requirement: { kind: "sleep", min: 6 } },
  { id: "sleep65_1", text: "Log at least 6.5 hours of sleep today.", type: "recovery", requirement: { kind: "sleep", min: 6.5 } },
  { id: "sleep65_2", text: "Get to 6.5+ hours of rest today.", type: "recovery", requirement: { kind: "sleep", min: 6.5 } },
  { id: "sleep70_1", text: "Log at least 7 hours of sleep today.", type: "recovery", requirement: { kind: "sleep", min: 7 } },
  { id: "sleep70_2", text: "Reach a full 7 hours of sleep today.", type: "recovery", requirement: { kind: "sleep", min: 7 } },
  { id: "sleep75_1", text: "Log at least 7.5 hours of sleep today.", type: "recovery", requirement: { kind: "sleep", min: 7.5 } },
  { id: "sleep75_2", text: "Aim for 7.5+ sleep hours today.", type: "recovery", requirement: { kind: "sleep", min: 7.5 } },
  { id: "sleep80_1", text: "Log at least 8 hours of sleep today.", type: "recovery", requirement: { kind: "sleep", min: 8 } },
  { id: "sleep80_2", text: "Sleep 8 hours today for full recovery.", type: "recovery", requirement: { kind: "sleep", min: 8 } },
  { id: "sleep85_1", text: "Log at least 8.5 hours of sleep today.", type: "recovery", requirement: { kind: "sleep", min: 8.5 } },
  { id: "sleep85_2", text: "Stretch sleep to 8.5 hours today.", type: "recovery", requirement: { kind: "sleep", min: 8.5 } },
  { id: "sleep90_1", text: "Log at least 9 hours of sleep today.", type: "recovery", requirement: { kind: "sleep", min: 9 } },
  { id: "sleep90_2", text: "Reach 9 sleep hours today.", type: "recovery", requirement: { kind: "sleep", min: 9 } },

  { id: "water5_1", text: "Log at least 5 glasses of water today.", type: "hydration", requirement: { kind: "water", min: 5 } },
  { id: "water5_2", text: "Drink and log 5 glasses today.", type: "hydration", requirement: { kind: "water", min: 5 } },
  { id: "water6_1", text: "Log at least 6 glasses of water today.", type: "hydration", requirement: { kind: "water", min: 6 } },
  { id: "water6_2", text: "Hit 6 glasses of water today.", type: "hydration", requirement: { kind: "water", min: 6 } },
  { id: "water7_1", text: "Log at least 7 glasses of water today.", type: "hydration", requirement: { kind: "water", min: 7 } },
  { id: "water7_2", text: "Reach 7 glasses of water today.", type: "hydration", requirement: { kind: "water", min: 7 } },
  { id: "water8_1", text: "Log at least 8 glasses of water today.", type: "hydration", requirement: { kind: "water", min: 8 } },
  { id: "water8_2", text: "Get to 8 glasses of water today.", type: "hydration", requirement: { kind: "water", min: 8 } },
  { id: "water9_1", text: "Log at least 9 glasses of water today.", type: "hydration", requirement: { kind: "water", min: 9 } },
  { id: "water9_2", text: "Push hydration to 9 glasses today.", type: "hydration", requirement: { kind: "water", min: 9 } },
  { id: "water10_1", text: "Log at least 10 glasses of water today.", type: "hydration", requirement: { kind: "water", min: 10 } },
  { id: "water10_2", text: "Complete a 10-glass hydration day.", type: "hydration", requirement: { kind: "water", min: 10 } },

  { id: "mood_1", text: "Log your mood at least once today.", type: "mind", requirement: { kind: "mood" } },
  { id: "mood_2", text: "Check in with your mood today.", type: "mind", requirement: { kind: "mood" } },
  { id: "mood_3", text: "Record one mood entry for today.", type: "mind", requirement: { kind: "mood" } },
  { id: "mood_4", text: "Track your emotional state once today.", type: "mind", requirement: { kind: "mood" } },

  { id: "grat1_1", text: "Write one gratitude note today.", type: "mind", requirement: { kind: "gratitude", min: 1 } },
  { id: "grat1_2", text: "Capture 1 gratitude win today.", type: "mind", requirement: { kind: "gratitude", min: 1 } },
  { id: "grat2_1", text: "Write two gratitude notes today.", type: "mind", requirement: { kind: "gratitude", min: 2 } },
  { id: "grat2_2", text: "List 2 things you are thankful for today.", type: "mind", requirement: { kind: "gratitude", min: 2 } },
  { id: "grat3_1", text: "Write three gratitude notes today.", type: "mind", requirement: { kind: "gratitude", min: 3 } },
  { id: "grat3_2", text: "Log 3 gratitude moments today.", type: "mind", requirement: { kind: "gratitude", min: 3 } },
  { id: "grat4_1", text: "Write four gratitude notes today.", type: "mind", requirement: { kind: "gratitude", min: 4 } },
  { id: "grat4_2", text: "Complete 4 gratitude entries today.", type: "mind", requirement: { kind: "gratitude", min: 4 } },
  { id: "grat5_1", text: "Write five gratitude notes today.", type: "mind", requirement: { kind: "gratitude", min: 5 } },
  { id: "grat5_2", text: "Log 5 gratitude points today.", type: "mind", requirement: { kind: "gratitude", min: 5 } },
  { id: "grat6_1", text: "Write six gratitude notes today.", type: "mind", requirement: { kind: "gratitude", min: 6 } },
  { id: "grat6_2", text: "Hit 6 gratitude entries today.", type: "mind", requirement: { kind: "gratitude", min: 6 } },

  { id: "task1_1", text: "Complete at least 1 task today.", type: "focus", requirement: { kind: "tasksCompleted", min: 1 } },
  { id: "task1_2", text: "Close out 1 task today.", type: "focus", requirement: { kind: "tasksCompleted", min: 1 } },
  { id: "task2_1", text: "Complete at least 2 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 2 } },
  { id: "task2_2", text: "Finish 2 tasks on your list today.", type: "focus", requirement: { kind: "tasksCompleted", min: 2 } },
  { id: "task3_1", text: "Complete at least 3 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 3 } },
  { id: "task3_2", text: "Push through and complete 3 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 3 } },
  { id: "task4_1", text: "Complete at least 4 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 4 } },
  { id: "task4_2", text: "Mark 4 tasks as done today.", type: "focus", requirement: { kind: "tasksCompleted", min: 4 } },
  { id: "task5_1", text: "Complete at least 5 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 5 } },
  { id: "task5_2", text: "Finish 5 tasks for a strong focus day.", type: "focus", requirement: { kind: "tasksCompleted", min: 5 } },
  { id: "task6_1", text: "Complete at least 6 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 6 } },
  { id: "task6_2", text: "Hit 6 completed tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 6 } },
  { id: "task7_1", text: "Complete at least 7 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 7 } },
  { id: "task7_2", text: "Close 7 tasks today for momentum.", type: "focus", requirement: { kind: "tasksCompleted", min: 7 } },
  { id: "task8_1", text: "Complete at least 8 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 8 } },
  { id: "task8_2", text: "Reach 8 finished tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 8 } },
  { id: "task9_1", text: "Complete at least 9 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 9 } },
  { id: "task9_2", text: "Drive to 9 completed tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 9 } },
  { id: "task10_1", text: "Complete at least 10 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 10 } },
  { id: "task10_2", text: "Crush 10 tasks today.", type: "focus", requirement: { kind: "tasksCompleted", min: 10 } },

  { id: "challenge_1", text: "Complete today‚Äôs daily challenge.", type: "consistency", requirement: { kind: "challenge" } },
  { id: "challenge_2", text: "Finish the daily challenge today.", type: "consistency", requirement: { kind: "challenge" } },
  { id: "challenge_3", text: "Secure your day by completing today‚Äôs challenge.", type: "consistency", requirement: { kind: "challenge" } },
  { id: "challenge_4", text: "Check off the daily challenge before day-end.", type: "consistency", requirement: { kind: "challenge" } },

  { id: "rescue1_1", text: "Run one mood crash rescue today.", type: "resilience", requirement: { kind: "rescue", min: 1 } },
  { id: "rescue1_2", text: "Complete 1 rescue action today.", type: "resilience", requirement: { kind: "rescue", min: 1 } },
  { id: "rescue2_1", text: "Run two mood crash rescues today.", type: "resilience", requirement: { kind: "rescue", min: 2 } },
  { id: "rescue2_2", text: "Do 2 rescue interventions today.", type: "resilience", requirement: { kind: "rescue", min: 2 } },
  { id: "rescue3_1", text: "Run three mood crash rescues today.", type: "resilience", requirement: { kind: "rescue", min: 3 } },
  { id: "rescue3_2", text: "Complete 3 rescue attempts today.", type: "resilience", requirement: { kind: "rescue", min: 3 } }
];

function getQuestWeekStartKeySunday(dateValue = getServerNowDate()) {
  const date = toDateSafe(dateValue) || getServerNowDate();
  const sunday = new Date(date);
  sunday.setUTCHours(0, 0, 0, 0);
  sunday.setUTCDate(sunday.getUTCDate() - sunday.getUTCDay());
  return dateToKey(sunday) || getTodayKey();
}

function getQuestWeekDatesSundayStart() {
  const startKey = getQuestWeekStartKeySunday();
  const startDate = dateKeyToDate(startKey) || getServerNowDate();
  startDate.setUTCHours(0, 0, 0, 0);
  return Array.from({ length: 7 }, (_, index) => {
    const date = new Date(startDate);
    date.setUTCDate(startDate.getUTCDate() + index);
    return date;
  });
}

function pickRandomQuests(pool, count) {
  const shuffled = [...pool];
  for (let index = shuffled.length - 1; index > 0; index -= 1) {
    const randomIndex = Math.floor(Math.random() * (index + 1));
    [shuffled[index], shuffled[randomIndex]] = [shuffled[randomIndex], shuffled[index]];
  }
  return shuffled.slice(0, count);
}

function generateAdaptiveQuests(todayKey = getTodayKey()) {
  const weekStartKey = getQuestWeekStartKeySunday();
  if (questWeekStartKey !== weekStartKey) {
    questWeekStartKey = weekStartKey;
    weeklyQuestUsedIds = [];
    questCompletedDateKeys = [];
    questStreakCount = 0;
    questLastStreakDateKey = "";
  }

  const selected = pickRandomQuests(QUEST_LIBRARY, 4).map((item, index) => ({
    id: `${item.id}-${todayKey}-${index + 1}`,
    baseId: item.id,
    text: item.text,
    type: item.type,
    requirement: item.requirement || null,
    completed: false
  }));

  habitQuests.length = 0;
  selected.forEach((quest) => habitQuests.push(quest));
}

function renderQuestWeekStreak(animatedDateKey = "") {
  if (!questWeekStreakLabels || !questWeekStreakCircles) return;

  const weekDates = getQuestWeekDatesSundayStart();
  const labels = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  const completedSet = new Set((questCompletedDateKeys || []).filter(Boolean));

  questWeekStreakLabels.innerHTML = "";
  questWeekStreakCircles.innerHTML = "";

  weekDates.forEach((date, index) => {
    const key = dateToKey(date);

    const label = document.createElement("span");
    label.className = "challenge-streak-day";
    label.innerText = labels[index] || "";
    questWeekStreakLabels.appendChild(label);

    const circle = document.createElement("span");
    circle.className = "challenge-streak-circle";
    if (completedSet.has(key)) {
      circle.classList.add("filled");
      const fire = document.createElement("span");
      fire.className = "challenge-streak-fire";
      fire.innerText = "üî•";
      circle.appendChild(fire);
      if (animatedDateKey && key === animatedDateKey) {
        circle.classList.add("fire-fill");
      }
    }
    questWeekStreakCircles.appendChild(circle);
  });
}

function renderHabitQuestUI(animatedDateKey = "") {
  if (questXpEl) questXpEl.innerText = `XP ${questXp}/100`;
  const allDoneToday = habitQuests.length > 0 && habitQuests.every((entry) => !!entry.completed);
  if (questStreakEl) questStreakEl.innerText = allDoneToday ? `Streak ${questStreakCount} üî•` : "Complete all 4 quests to lock today‚Äôs streak";
  const progressPercent = allDoneToday ? 100 : Math.max(0, Math.min(100, questXp));
  if (questProgressFill) questProgressFill.style.width = `${progressPercent}%`;
  if (questShieldEl) questShieldEl.innerText = `Streak shield: ${questShieldAvailable ? "Active" : "Inactive"}`;
  if (questProgressHintEl) {
    questProgressHintEl.innerText = allDoneToday
      ? "Perfect day complete ‚Äî streak secured."
      : `Progress ${progressPercent}% ‚Ä¢ complete all 4 quests to lock today‚Äôs streak.`;
  }
  renderQuestWeekStreak(animatedDateKey);

  if (!questListEl) return;
  questListEl.innerHTML = "";

  if (!habitQuests.length) {
    questListEl.innerHTML = "<li class=\"quest-item\"><span class=\"quest-text\">No quests yet. Log today‚Äôs stats to generate quests.</span></li>";
    return;
  }

  habitQuests.forEach((quest, index) => {
    const item = document.createElement("li");
    item.className = "quest-item";

    const text = document.createElement("span");
    text.className = `quest-text${quest.completed ? " quest-done" : ""}`;
    text.textContent = quest.text;

    const button = document.createElement("button");
    button.textContent = quest.completed ? "Done" : "Complete";
    button.disabled = !!quest.completed;
    button.onclick = () => completeHabitQuest(index);

    item.append(text, button);
    questListEl.appendChild(item);
  });
}

async function saveHabitQuestState(userId) {
  if (!userId) return;
  try {
    await setDoc(doc(db, "users", userId, "settings", "habitQuest"), {
      dateKey: questDateKey,
      weekStartKey: questWeekStartKey,
      xp: questXp,
      shield: questShieldAvailable,
      streakCount: questStreakCount,
      lastStreakDateKey: questLastStreakDateKey,
      weeklyQuestUsedIds,
      completedDateKeys: questCompletedDateKeys,
      quests: habitQuests,
      updatedAt: serverTimestamp()
    }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function dayDiffFromKeys(fromKey, toKey) {
  if (!fromKey || !toKey) return Infinity;
  const fromDate = new Date(`${fromKey}T00:00:00.000Z`);
  const toDate = new Date(`${toKey}T00:00:00.000Z`);
  if (Number.isNaN(fromDate.getTime()) || Number.isNaN(toDate.getTime())) return Infinity;
  return Math.floor((toDate.getTime() - fromDate.getTime()) / 86400000);
}

function normalizeQuestStreakForToday(todayKey = getTodayKey()) {
  const currentWeekStart = getQuestWeekStartKeySunday();
  if (questWeekStartKey !== currentWeekStart) {
    questWeekStartKey = currentWeekStart;
    questStreakCount = 0;
    questLastStreakDateKey = "";
    weeklyQuestUsedIds = [];
    questCompletedDateKeys = [];
    return;
  }

  if (!questLastStreakDateKey) {
    questStreakCount = 0;
    return;
  }
  const diff = dayDiffFromKeys(questLastStreakDateKey, todayKey);
  if (diff > 1 || diff < 0) questStreakCount = 0;
}

function awardQuestStreakForToday(todayKey = getTodayKey()) {
  if (questLastStreakDateKey === todayKey) return false;
  const diff = dayDiffFromKeys(questLastStreakDateKey, todayKey);
  if (diff === 1) {
    questStreakCount += 1;
  } else {
    questStreakCount = 1;
  }
  questLastStreakDateKey = todayKey;
  return true;
}

function triggerQuestStreakCelebration() {
  if (questStreakEl) {
    questStreakEl.classList.remove("streak-pop");
    void questStreakEl.offsetWidth;
    questStreakEl.classList.add("streak-pop");
    setTimeout(() => questStreakEl.classList.remove("streak-pop"), 700);
  }
}

async function loadHabitQuest(userId) {
  questDateKey = getTodayKey();
  const currentWeekStart = getQuestWeekStartKeySunday();

  try {
    const snap = await getDoc(doc(db, "users", userId, "settings", "habitQuest"));
    if (snap.exists()) {
      const data = snap.data();
      questXp = Number(data.xp) || 0;
      questShieldAvailable = !!data.shield;
      questStreakCount = Math.max(0, Number(data.streakCount) || 0);
      questLastStreakDateKey = String(data.lastStreakDateKey || "");
      questWeekStartKey = String(data.weekStartKey || "");
      weeklyQuestUsedIds = Array.isArray(data.weeklyQuestUsedIds) ? data.weeklyQuestUsedIds.map((id) => String(id || "")).filter(Boolean) : [];
      questCompletedDateKeys = Array.isArray(data.completedDateKeys) ? data.completedDateKeys.map((key) => String(key || "")).filter(Boolean) : [];

      if (questWeekStartKey !== currentWeekStart) {
        questWeekStartKey = currentWeekStart;
        weeklyQuestUsedIds = [];
        questCompletedDateKeys = [];
        questStreakCount = 0;
        questLastStreakDateKey = "";
      }

      normalizeQuestStreakForToday(questDateKey);

      if (data.dateKey === questDateKey && Array.isArray(data.quests) && data.quests.length >= 4) {
        habitQuests.length = 0;
        data.quests.forEach((quest) => {
          const baseId = String(quest.baseId || String(quest.id || "").split("-")[0] || "");
          habitQuests.push({
            id: String(quest.id || ""),
            baseId,
            text: String(quest.text || "Daily quest"),
            type: String(quest.type || "general"),
            requirement: quest.requirement || null,
            completed: !!quest.completed
          });
        });
      } else {
        generateAdaptiveQuests(questDateKey);
        await saveHabitQuestState(userId);
      }
    } else {
      questXp = 0;
      questShieldAvailable = false;
      questStreakCount = 0;
      questLastStreakDateKey = "";
      questWeekStartKey = currentWeekStart;
      weeklyQuestUsedIds = [];
      questCompletedDateKeys = [];
      generateAdaptiveQuests(questDateKey);
      await saveHabitQuestState(userId);
    }
  } catch (err) {
    notifyFirestoreError(err);
  }

  renderHabitQuestUI();
}

function getTodayCompletedTaskCount() {
  const todayKey = getTodayKey();
  return taskEntries.filter((entry) => !!entry.completed && dateToKey(entry.time) === todayKey).length;
}

function getTodayRescueCount() {
  const todayKey = getTodayKey();
  return rescueEvents.filter((entry) => dateToKey(entry.time) === todayKey).length;
}

function getTodayGratitudeCount() {
  const todayKey = getTodayKey();
  return gratitudeEntries.filter((entry) => dateToKey(entry.time) === todayKey).length;
}

function validateHabitQuestCompletion(quest) {
  const requirement = quest?.requirement || null;
  const snapshot = getWellnessSnapshot();

  if (!requirement?.kind) {
    const baseId = String(quest?.id || "").split("-")[0];
    if (baseId === "water" || baseId === "water8") {
      const min = baseId === "water8" ? 8 : snapshot.todayGoal;
      if (snapshot.waterToday < min) return { valid: false, message: `Log at least ${min} glasses first (current: ${snapshot.waterToday}).` };
      return { valid: true };
    }
    if (baseId === "sleep") {
      if (snapshot.sleepToday < 7) return { valid: false, message: `Log at least 7 hours sleep first (current: ${snapshot.sleepToday}).` };
      return { valid: true };
    }
    if (baseId === "mood") {
      if (!snapshot.moodToday) return { valid: false, message: "Log your mood first." };
      return { valid: true };
    }
    if (baseId === "gratitude") {
      const count = getTodayGratitudeCount();
      if (count < 1) return { valid: false, message: `Add a gratitude note first (current: ${count}).` };
      return { valid: true };
    }
    if (baseId === "task" || baseId === "tasks2") {
      const min = baseId === "tasks2" ? 2 : 1;
      const completed = getTodayCompletedTaskCount();
      if (completed < min) return { valid: false, message: `Complete at least ${min} task${min > 1 ? "s" : ""} first (current: ${completed}).` };
      return { valid: true };
    }
    if (baseId === "challenge") {
      if (!dailyChallengeCompleted) return { valid: false, message: "Complete today‚Äôs daily challenge first." };
      return { valid: true };
    }
    if (baseId === "rescue") {
      const rescues = getTodayRescueCount();
      if (rescues < 1) return { valid: false, message: `Run mood crash rescue first (current: ${rescues}).` };
      return { valid: true };
    }
    return { valid: false, message: "This quest cannot be verified yet. Refresh to get a measurable quest." };
  }

  if (requirement.kind === "water") {
    const min = Math.max(1, Number(requirement.min) || 1);
    if (snapshot.waterToday < min) return { valid: false, message: `Log at least ${min} glasses first (current: ${snapshot.waterToday}).` };
    return { valid: true };
  }
  if (requirement.kind === "sleep") {
    const min = Math.max(1, Number(requirement.min) || 7);
    if (snapshot.sleepToday < min) return { valid: false, message: `Log at least ${min} hours sleep first (current: ${snapshot.sleepToday}).` };
    return { valid: true };
  }
  if (requirement.kind === "mood") {
    if (!snapshot.moodToday) return { valid: false, message: "Log your mood first." };
    return { valid: true };
  }
  if (requirement.kind === "gratitude") {
    const min = Math.max(1, Number(requirement.min) || 1);
    const count = getTodayGratitudeCount();
    if (count < min) return { valid: false, message: `Add at least ${min} gratitude note${min > 1 ? "s" : ""} first (current: ${count}).` };
    return { valid: true };
  }
  if (requirement.kind === "tasksCompleted") {
    const min = Math.max(1, Number(requirement.min) || 1);
    const completed = getTodayCompletedTaskCount();
    if (completed < min) return { valid: false, message: `Complete at least ${min} task${min > 1 ? "s" : ""} first (current: ${completed}).` };
    return { valid: true };
  }
  if (requirement.kind === "challenge") {
    if (!dailyChallengeCompleted) return { valid: false, message: "Complete today‚Äôs daily challenge first." };
    return { valid: true };
  }
  if (requirement.kind === "rescue") {
    const min = Math.max(1, Number(requirement.min) || 1);
    const rescues = getTodayRescueCount();
    if (rescues < min) return { valid: false, message: `Run mood crash rescue at least ${min} time${min > 1 ? "s" : ""} first (current: ${rescues}).` };
    return { valid: true };
  }

  return { valid: false, message: "This quest requirement is not trackable yet." };
}

async function completeHabitQuest(index) {
  const user = auth.currentUser;
  if (!user) return;
  const quest = habitQuests[index];
  if (!quest || quest.completed) return;

  const validation = validateHabitQuestCompletion(quest);
  if (!validation.valid) {
    alert(`‚ùå ${validation.message}`);
    return;
  }

  quest.completed = true;
  questXp += 20;

  const allDone = habitQuests.length > 0 && habitQuests.every((entry) => entry.completed);
  if (allDone) {
    const todayKey = getTodayKey();
    if (!questCompletedDateKeys.includes(todayKey)) {
      questCompletedDateKeys.push(todayKey);
    }
    questXp += 20;
    questShieldAvailable = true;
    const streakAdvanced = awardQuestStreakForToday(todayKey);
    if (streakAdvanced) triggerQuestStreakCelebration();
    while (questCompletedDateKeys.length > 7) questCompletedDateKeys.shift();
    renderHabitQuestUI(todayKey);
  } else {
    renderHabitQuestUI();
  }

  while (questXp >= 100) questXp -= 100;

  await saveHabitQuestState(user.uid);
  updateInsights();
}

function ensureHabitQuestCurrent() {
  const todayKey = getTodayKey();
  const currentWeekStart = getQuestWeekStartKeySunday();
  if (questWeekStartKey !== currentWeekStart) {
    questWeekStartKey = currentWeekStart;
    questStreakCount = 0;
    questLastStreakDateKey = "";
    weeklyQuestUsedIds = [];
    questCompletedDateKeys = [];
  }

  if (!questDateKey) {
    questDateKey = todayKey;
    if (!habitQuests.length) generateAdaptiveQuests(todayKey);
    renderHabitQuestUI();
    return;
  }

  if (questDateKey !== todayKey) {
    questDateKey = todayKey;
    normalizeQuestStreakForToday(todayKey);
    generateAdaptiveQuests(todayKey);
    const user = auth.currentUser;
    if (user) saveHabitQuestState(user.uid);
  }

  renderHabitQuestUI();
}

function updateBurnoutRadarUI() {
  const crash = getCrashRiskSnapshot();
  const now = getServerNowDate();
  const hour = now.getUTCHours();
  const dipStart = Math.min(23, hour + 2);
  const dipEnd = Math.min(23, hour + 6);

  const rescueLast3Days = rescueEvents.filter((entry) => {
    const time = toDateSafe(entry.time);
    if (!time) return false;
    const threshold = getServerNowDate();
    threshold.setUTCDate(threshold.getUTCDate() - 3);
    return time >= threshold;
  }).length;

  let forecast = Math.round(crash.risk * 0.75);
  if (rescueLast3Days >= 2) forecast += 12;
  if (sleepHistory.length > 1) {
    const recent = Number(sleepHistory[sleepHistory.length - 1]) || 0;
    const prev = Number(sleepHistory[sleepHistory.length - 2]) || 0;
    if (recent < prev - 1) forecast += 8;
  }
  forecast = Math.max(0, Math.min(100, forecast));

  const level = forecast >= 75 ? "High Risk" : forecast >= 50 ? "Moderate Risk" : "Low Risk";
  const reason =
    forecast >= 75 ? "Burnout pressure is building fast from current stress signals." :
    forecast >= 50 ? "Early fatigue markers detected; proactive recovery is recommended." :
    "Recovery trajectory is stable. Keep consistency.";

  burnoutRecoveryPlan.length = 0;
  burnoutRecoveryPlan.push(
    `At ${String(dipStart).padStart(2, "0")}:00 do a 2-minute breathing reset.`,
    `At ${String(Math.min(23, dipStart + 1)).padStart(2, "0")}:00 drink water + 5-minute stretch.`,
    `At ${String(dipEnd).padStart(2, "0")}:00 reduce workload to one small closure task.`
  );
  if (forecast >= 60) burnoutRecoveryPlan.push("Avoid back-to-back high-focus sessions without a break today.");

  if (burnoutRiskEl) burnoutRiskEl.innerText = `${forecast}/100`;
  if (burnoutWindowEl) burnoutWindowEl.innerText = `${level} ‚Ä¢ Dip window ${String(dipStart).padStart(2, "0")}:00-${String(dipEnd).padStart(2, "0")}:00`;
  if (burnoutReasonEl) burnoutReasonEl.innerText = reason;
  if (burnoutScheduleEl) burnoutScheduleEl.innerHTML = burnoutRecoveryPlan.map((item) => `<li>${item}</li>`).join("");
}

async function applyRecoverySchedule() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  if (!burnoutRecoveryPlan.length) updateBurnoutRadarUI();

  try {
    const remindersToSet = [20, 60, 120];
    for (let index = 0; index < remindersToSet.length; index += 1) {
      const minutes = remindersToSet[index];
      const text = `Recovery step ${index + 1}: ${burnoutRecoveryPlan[index] || "Take a reset break."}`;
      const targetAtMs = getServerNowDate().getTime() + minutes * 60000;
      const ref = await addDoc(collection(db, "users", user.uid, "reminders"), {
        text,
        minutes,
        targetAtMs,
        createdAt: serverTimestamp()
      });
      renderReminder({ id: ref.id, text, minutes, targetAtMs });
    }
    alert("‚úÖ Recovery schedule applied with reminders.");
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function pickChallengeForDate(dateKey) {
  const sum = [...dateKey].reduce((total, char) => total + char.charCodeAt(0), 0);
  return dailyChallenges[sum % dailyChallenges.length];
}

function queueInsightsPersist(payload) {
  if (insightsPersistTimer) clearTimeout(insightsPersistTimer);
  insightsPersistTimer = setTimeout(async () => {
    const user = auth.currentUser;
    if (!user) return;
    try {
      if (payload?.barGraphs) {
        persistedBarGraphs = payload.barGraphs;
      }

      await setDoc(doc(db, "users", user.uid, "insights", "current"), {
        ...payload,
        updatedAt: serverTimestamp()
      }, { merge: true });

      if (payload?.barGraphs) {
        await setDoc(doc(db, "users", user.uid, "insights", "barGraphs"), {
          ...payload.barGraphs,
          updatedAt: serverTimestamp()
        }, { merge: true });
      }
    } catch (err) {
      notifyFirestoreError(err);
    }
  }, 350);
}

async function loadPersistedBarGraphs(userId) {
  if (!userId) return;

  try {
    const barGraphsSnap = await getDoc(doc(db, "users", userId, "insights", "barGraphs"));
    if (barGraphsSnap.exists()) {
      persistedBarGraphs = barGraphsSnap.data() || null;
      return;
    }

    const currentSnap = await getDoc(doc(db, "users", userId, "insights", "current"));
    const currentData = currentSnap.exists() ? currentSnap.data() : null;
    persistedBarGraphs = currentData?.barGraphs || null;
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function getTodayKey() {
  const now = getServerNowDate();
  const year = now.getUTCFullYear();
  const month = String(now.getUTCMonth() + 1).padStart(2, "0");
  const day = String(now.getUTCDate()).padStart(2, "0");
  return `${year}-${month}-${day}`;
}

function getTodayKeyGMT() {
  return getTodayKey();
}

function getServerNowDate() {
  return new Date(Date.now() + serverTimeOffsetMs);
}

async function syncServerClock(userId) {
  if (!userId) return;

  try {
    const clockRef = doc(db, "users", userId, "settings", "timeSync");
    const clientNow = Date.now();
    await setDoc(clockRef, {
      clientNow,
      serverNow: serverTimestamp(),
      updatedAt: serverTimestamp()
    }, { merge: true });

    const snapshot = await getDoc(clockRef);
    if (!snapshot.exists()) return;
    const data = snapshot.data();
    const serverNowDate = toDateSafe(data.serverNow);
    const clientNowAtWrite = Number(data.clientNow) || clientNow;
    if (!serverNowDate) return;

    serverTimeOffsetMs = serverNowDate.getTime() - clientNowAtWrite;
    serverTimeSyncedAt = Date.now();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function ensureServerClockCurrent(userId) {
  if (!serverTimeSyncedAt || (Date.now() - serverTimeSyncedAt) > SERVER_CLOCK_RESYNC_MS) {
    await syncServerClock(userId);
  }
}

async function saveAiUsage(userId) {
  try {
    await setDoc(doc(db, "users", userId, "settings", "aiUsage"), {
      dateKeyLocal: aiUsageDateKeyGMT,
      dateKeyGMT: aiUsageDateKeyGMT,
      count: aiUsageCount,
      updatedAt: serverTimestamp()
    }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveDailyUsage(userId) {
  try {
    await setDoc(doc(db, "users", userId, "settings", "dailyUsage"), {
      dateKey: dailyUsageDateKey,
      moodCount: Number(moodDailyUsageCount) || 0,
      taskCount: Number(taskDailyUsageCount) || 0,
      sleepCount: Number(sleepDailyUsageCount) || 0,
      waterCount: Number(waterDailyUsageCount) || 0,
      reminderCount: Number(reminderDailyUsageCount) || 0,
      gratitudeCount: Number(gratitudeDailyUsageCount) || 0,
      updatedAt: serverTimestamp()
    }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadDailyUsage(userId) {
  dailyUsageLoaded = false;
  dailyUsageDateKey = getTodayKey();
  moodDailyUsageCount = 0;
  taskDailyUsageCount = 0;
  sleepDailyUsageCount = 0;
  waterDailyUsageCount = 0;
  reminderDailyUsageCount = 0;
  gratitudeDailyUsageCount = 0;

  try {
    const snapshot = await getDoc(doc(db, "users", userId, "settings", "dailyUsage"));
    if (snapshot.exists()) {
      const data = snapshot.data();
      if (data.dateKey === dailyUsageDateKey) {
        moodDailyUsageCount = Number(data.moodCount) || 0;
        taskDailyUsageCount = Number(data.taskCount) || 0;
        sleepDailyUsageCount = Number(data.sleepCount) || 0;
        waterDailyUsageCount = Number(data.waterCount) || 0;
        reminderDailyUsageCount = Number(data.reminderCount) || 0;
        gratitudeDailyUsageCount = Number(data.gratitudeCount) || 0;
      } else {
        await saveDailyUsage(userId);
      }
    } else {
      await saveDailyUsage(userId);
    }
  } catch (err) {
    notifyFirestoreError(err);
  } finally {
    dailyUsageLoaded = true;
    updateMoodLimitUI();
    updateTaskLimitUI();
    updateSleepLimitUI();
    updateWaterLimitUI();
    updateGratitudeLimitUI();
    await updateReminderLimitUI(userId);
  }
}

async function ensureDailyUsageCurrent(userId, options = {}) {
  await ensureServerClockCurrent(userId);

  if (!dailyUsageLoaded) {
    await loadDailyUsage(userId);
  }

  const todayKey = getTodayKey();
  if (dailyUsageDateKey !== todayKey) {
    dailyUsageDateKey = todayKey;
    moodDailyUsageCount = 0;
    taskDailyUsageCount = 0;
    sleepDailyUsageCount = 0;
    waterDailyUsageCount = 0;
    reminderDailyUsageCount = 0;
    gratitudeDailyUsageCount = 0;
    await saveDailyUsage(userId);
  }

  updateMoodLimitUI();
  updateTaskLimitUI();
  updateSleepLimitUI();
  updateWaterLimitUI();
  updateGratitudeLimitUI();
  if (!options.skipReminderRefresh) {
    await updateReminderLimitUI(userId);
  }
}

async function loadAiUsage(userId) {
  aiUsageStateLoaded = false;
  aiUsageDateKeyGMT = getTodayKeyGMT();
  aiUsageCount = 0;

  try {
    const snapshot = await getDoc(doc(db, "users", userId, "settings", "aiUsage"));
    if (snapshot.exists()) {
      const data = snapshot.data();
      const storedDayKey = data.dateKeyLocal || data.dateKeyGMT || "";
      if (storedDayKey === aiUsageDateKeyGMT) {
        aiUsageCount = Number(data.count) || 0;
      } else {
        aiUsageCount = 0;
        await saveAiUsage(userId);
      }
    } else {
      await saveAiUsage(userId);
    }
  } catch (err) {
    notifyFirestoreError(err);
  } finally {
    aiUsageStateLoaded = true;
    updateAiLimitUI();
  }
}

async function ensureAiUsageCurrent(userId) {
  await ensureServerClockCurrent(userId);

  if (!aiUsageStateLoaded) {
    await loadAiUsage(userId);
  }

  const todayKeyGMT = getTodayKeyGMT();
  if (aiUsageDateKeyGMT !== todayKeyGMT) {
    aiUsageDateKeyGMT = todayKeyGMT;
    aiUsageCount = 0;
    await saveAiUsage(userId);
  }
  updateAiLimitUI();
}

function getDailyUsageCountersFromRaw(rawData = {}, todayKey = getTodayKey()) {
  const sameDay = String(rawData?.dateKey || "") === todayKey;
  return {
    dateKey: todayKey,
    moodCount: sameDay ? Math.max(0, Number(rawData?.moodCount) || 0) : 0,
    taskCount: sameDay ? Math.max(0, Number(rawData?.taskCount) || 0) : 0,
    sleepCount: sameDay ? Math.max(0, Number(rawData?.sleepCount) || 0) : 0,
    waterCount: sameDay ? Math.max(0, Number(rawData?.waterCount) || 0) : 0,
    reminderCount: sameDay ? Math.max(0, Number(rawData?.reminderCount) || 0) : 0,
    gratitudeCount: sameDay ? Math.max(0, Number(rawData?.gratitudeCount) || 0) : 0
  };
}

function syncDailyUsageLocalsFromCounters(counters) {
  dailyUsageDateKey = String(counters?.dateKey || getTodayKey());
  moodDailyUsageCount = Math.max(0, Number(counters?.moodCount) || 0);
  taskDailyUsageCount = Math.max(0, Number(counters?.taskCount) || 0);
  sleepDailyUsageCount = Math.max(0, Number(counters?.sleepCount) || 0);
  waterDailyUsageCount = Math.max(0, Number(counters?.waterCount) || 0);
  reminderDailyUsageCount = Math.max(0, Number(counters?.reminderCount) || 0);
  gratitudeDailyUsageCount = Math.max(0, Number(counters?.gratitudeCount) || 0);
  dailyUsageLoaded = true;
}

async function reserveDailyQuota(userId, quotaField, limit) {
  if (!userId || !quotaField || !Number.isFinite(limit)) {
    return { ok: false, count: 0 };
  }

  const todayKey = getTodayKey();
  const usageRef = doc(db, "users", userId, "settings", "dailyUsage");

  try {
    const result = await runTransaction(db, async (transaction) => {
      const snapshot = await transaction.get(usageRef);
      const counters = getDailyUsageCountersFromRaw(snapshot.exists() ? snapshot.data() : {}, todayKey);
      const current = Math.max(0, Number(counters[quotaField]) || 0);
      if (current >= limit) {
        return { ok: false, counters, count: current };
      }

      counters[quotaField] = current + 1;
      transaction.set(usageRef, {
        ...counters,
        updatedAt: serverTimestamp()
      }, { merge: true });

      return { ok: true, counters, count: counters[quotaField] };
    });

    if (result?.counters) syncDailyUsageLocalsFromCounters(result.counters);
    return result || { ok: false, count: 0 };
  } catch (err) {
    notifyFirestoreError(err);
    return { ok: false, count: 0, error: err };
  }
}

async function rollbackDailyQuota(userId, quotaField) {
  if (!userId || !quotaField) return;

  const todayKey = getTodayKey();
  const usageRef = doc(db, "users", userId, "settings", "dailyUsage");

  try {
    const result = await runTransaction(db, async (transaction) => {
      const snapshot = await transaction.get(usageRef);
      if (!snapshot.exists()) return null;

      const counters = getDailyUsageCountersFromRaw(snapshot.data(), todayKey);
      const current = Math.max(0, Number(counters[quotaField]) || 0);
      if (current <= 0) return counters;

      counters[quotaField] = current - 1;
      transaction.set(usageRef, {
        ...counters,
        updatedAt: serverTimestamp()
      }, { merge: true });

      return counters;
    });

    if (result) syncDailyUsageLocalsFromCounters(result);
  } catch (_) {}
}

async function reserveAiQuota(userId, limit) {
  if (!userId || !Number.isFinite(limit)) return { ok: false, count: 0 };

  const todayKey = getTodayKeyGMT();
  const usageRef = doc(db, "users", userId, "settings", "aiUsage");

  try {
    const result = await runTransaction(db, async (transaction) => {
      const snapshot = await transaction.get(usageRef);
      const data = snapshot.exists() ? (snapshot.data() || {}) : {};
      const storedDayKey = String(data.dateKeyLocal || data.dateKeyGMT || "");
      let count = storedDayKey === todayKey ? Math.max(0, Number(data.count) || 0) : 0;

      if (count >= limit) {
        return { ok: false, count };
      }

      count += 1;
      transaction.set(usageRef, {
        dateKeyLocal: todayKey,
        dateKeyGMT: todayKey,
        count,
        updatedAt: serverTimestamp()
      }, { merge: true });

      return { ok: true, count };
    });

    if (result) {
      aiUsageDateKeyGMT = todayKey;
      aiUsageCount = Math.max(0, Number(result.count) || 0);
      aiUsageStateLoaded = true;
      updateAiLimitUI();
    }

    return result || { ok: false, count: 0 };
  } catch (err) {
    notifyFirestoreError(err);
    return { ok: false, count: 0, error: err };
  }
}

async function rollbackAiQuota(userId) {
  if (!userId) return;

  const todayKey = getTodayKeyGMT();
  const usageRef = doc(db, "users", userId, "settings", "aiUsage");

  try {
    const result = await runTransaction(db, async (transaction) => {
      const snapshot = await transaction.get(usageRef);
      if (!snapshot.exists()) return null;

      const data = snapshot.data() || {};
      const storedDayKey = String(data.dateKeyLocal || data.dateKeyGMT || "");
      let count = storedDayKey === todayKey ? Math.max(0, Number(data.count) || 0) : 0;
      if (count <= 0) return { count: 0 };

      count -= 1;
      transaction.set(usageRef, {
        dateKeyLocal: todayKey,
        dateKeyGMT: todayKey,
        count,
        updatedAt: serverTimestamp()
      }, { merge: true });

      return { count };
    });

    if (result) {
      aiUsageDateKeyGMT = todayKey;
      aiUsageCount = Math.max(0, Number(result.count) || 0);
      aiUsageStateLoaded = true;
      updateAiLimitUI();
    }
  } catch (_) {}
}

function startDailyChallengeWatcher() {
  if (challengeWatcherInterval) clearInterval(challengeWatcherInterval);
  challengeWatcherInterval = setInterval(async () => {
    const user = auth.currentUser;
    if (!user) return;
    const todayKey = getTodayKey();
    if (todayKey !== currentChallengeDateKey) {
      await loadDailyChallenge(user.uid);
    }
  }, 30000);
}

function stopDailyChallengeWatcher() {
  if (challengeWatcherInterval) {
    clearInterval(challengeWatcherInterval);
    challengeWatcherInterval = null;
  }
}

function clearDailyQuestResetSchedule() {
  if (dailyQuestResetTimeoutId) {
    clearTimeout(dailyQuestResetTimeoutId);
    dailyQuestResetTimeoutId = null;
  }
}

function scheduleDailyQuestReset(userId) {
  clearDailyQuestResetSchedule();

  const runReset = async () => {
    const activeUser = auth.currentUser;
    if (!activeUser || activeUser.uid !== userId) {
      scheduleDailyQuestReset(userId);
      return;
    }

    await loadHabitQuest(userId);
    scheduleDailyQuestReset(userId);
  };

  dailyQuestResetTimeoutId = setTimeout(runReset, getMillisecondsUntilNextMidnight());
}

function clearDailyChallengeResetSchedule() {
  if (dailyChallengeResetTimeoutId) {
    clearTimeout(dailyChallengeResetTimeoutId);
    dailyChallengeResetTimeoutId = null;
  }
}

function scheduleDailyChallengeReset(userId) {
  clearDailyChallengeResetSchedule();

  const runReset = async () => {
    const activeUser = auth.currentUser;
    if (!activeUser || activeUser.uid !== userId) {
      scheduleDailyChallengeReset(userId);
      return;
    }

    await loadDailyChallenge(userId);
    scheduleDailyChallengeReset(userId);
  };

  dailyChallengeResetTimeoutId = setTimeout(runReset, getMillisecondsUntilNextMidnight());
}

function clearWaterGoalResetSchedule() {
  if (waterGoalResetTimeoutId) {
    clearTimeout(waterGoalResetTimeoutId);
    waterGoalResetTimeoutId = null;
  }
}

function getMillisecondsUntilNextMidnight() {
  const now = getServerNowDate();
  const nextMidnight = new Date(now);
  nextMidnight.setUTCHours(24, 0, 0, 0);
  return Math.max(1, nextMidnight.getTime() - now.getTime());
}

function getMillisecondsUntilNextSundayMidnight() {
  const now = getServerNowDate();
  const nextSunday = new Date(now);
  nextSunday.setUTCHours(0, 0, 0, 0);
  const day = nextSunday.getUTCDay();
  const daysUntilSunday = day === 0 ? 7 : (7 - day);
  nextSunday.setUTCDate(nextSunday.getUTCDate() + daysUntilSunday);
  return Math.max(1, nextSunday.getTime() - now.getTime());
}

function formatWeeklyResetCountdown(milliseconds) {
  const safeMs = Math.max(0, Number(milliseconds) || 0);
  const totalSeconds = Math.floor(safeMs / 1000);
  const days = Math.floor(totalSeconds / 86400);
  const hours = Math.floor((totalSeconds % 86400) / 3600);
  const minutes = Math.floor((totalSeconds % 3600) / 60);
  const seconds = totalSeconds % 60;
  if (safeMs >= 86400000) {
    return `${days}d ${String(hours).padStart(2, "0")}h ${String(minutes).padStart(2, "0")}m`;
  }
  const totalHours = Math.floor(totalSeconds / 3600);
  return `${String(totalHours).padStart(2, "0")}h ${String(minutes).padStart(2, "0")}m ${String(seconds).padStart(2, "0")}s`;
}

function updateWeeklyGraphResetCountdownNote() {
  if (!insightWeeklyResetCountdown) return;
  const remaining = getMillisecondsUntilNextSundayMidnight();
  insightWeeklyResetCountdown.innerText = `Weekly bar graph reset in ${formatWeeklyResetCountdown(remaining)} (server time)`;
}

function startWeeklyGraphResetCountdown() {
  stopWeeklyGraphResetCountdown();
  updateWeeklyGraphResetCountdownNote();
  weeklyGraphCountdownIntervalId = setInterval(updateWeeklyGraphResetCountdownNote, 1000);
}

function stopWeeklyGraphResetCountdown() {
  if (weeklyGraphCountdownIntervalId) {
    clearInterval(weeklyGraphCountdownIntervalId);
    weeklyGraphCountdownIntervalId = null;
  }
  if (insightWeeklyResetCountdown) {
    insightWeeklyResetCountdown.innerText = "";
  }
}

function clearWeeklyGraphResetSchedule() {
  if (weeklyGraphResetTimeoutId) {
    clearTimeout(weeklyGraphResetTimeoutId);
    weeklyGraphResetTimeoutId = null;
  }
}

async function resetWeeklyBarGraphData(userId) {
  const weekRange = getCurrentWeekRangeKeys();
  const labels = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  const zeroBarGraphs = {
    weekStartKey: weekRange.weekStartKey,
    weekEndKey: weekRange.weekEndKey,
    labels,
    tasks: { values: [0, 0, 0, 0, 0, 0, 0], maxValue: 100 },
    sleep: { values: [0, 0, 0, 0, 0, 0, 0], maxValue: 12 },
    water: { values: [0, 0, 0, 0, 0, 0, 0], maxValue: 8 },
    mood: { values: [0, 0, 0, 0, 0, 0, 0], maxValue: 3 }
  };

  persistedBarGraphs = zeroBarGraphs;

  try {
    await Promise.all([
      setDoc(doc(db, "users", userId, "insights", "barGraphs"), {
        ...zeroBarGraphs,
        updatedAt: serverTimestamp()
      }, { merge: true }),
      setDoc(doc(db, "users", userId, "insights", "current"), {
        barGraphs: zeroBarGraphs,
        updatedAt: serverTimestamp()
      }, { merge: true })
    ]);
  } catch (err) {
    notifyFirestoreError(err);
  }

  updateInsights();
}

function scheduleWeeklyGraphReset(userId) {
  clearWeeklyGraphResetSchedule();

  const runReset = async () => {
    const activeUser = auth.currentUser;
    if (!activeUser || activeUser.uid !== userId) {
      scheduleWeeklyGraphReset(userId);
      return;
    }

    await resetWeeklyBarGraphData(userId);
    scheduleWeeklyGraphReset(userId);
  };

  weeklyGraphResetTimeoutId = setTimeout(runReset, getMillisecondsUntilNextSundayMidnight());
}

async function resetWaterDayData(userId, dateKey = getTodayKey()) {
  try {
    const intakeSnapshot = await getDocs(collection(db, "users", userId, "waterIntake"));
    await Promise.all(intakeSnapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
    await setDoc(doc(db, "users", userId, "settings", "water"), {
      goal: 0,
      goalDateKey: dateKey,
      lastResetDateKey: dateKey
    }, { merge: true });

    const activeUser = auth.currentUser;
    if (activeUser && activeUser.uid === userId) {
      waterHistory.length = 0;
      waterDates.length = 0;
      waterGoal = 0;
      waterGoalInput.value = "";
      waterInput.value = "";
      updateWaterProgress();
      updateWaterLimitUI();
      updateWaterClearButtonState();
    }
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function scheduleWaterGoalReset(userId) {
  clearWaterGoalResetSchedule();

  const runReset = async () => {
    const activeUser = auth.currentUser;
    if (!activeUser || activeUser.uid !== userId) {
      scheduleWaterGoalReset(userId);
      return;
    }

    await resetWaterDayData(userId, getTodayKey());

    scheduleWaterGoalReset(userId);
  };

  waterGoalResetTimeoutId = setTimeout(runReset, getMillisecondsUntilNextMidnight());
}

function updateWellnessScore() {
  const todayKey = getTodayKey();

  const waterToday = waterHistory.reduce((sum, value, index) => {
    const dateKey = dateToKey(waterDates[index]);
    return dateKey === todayKey ? sum + value : sum;
  }, 0);
  const effectiveWaterGoal = waterGoal > 0 ? waterGoal : 8;
  const waterRatio = Math.min(1, waterToday / effectiveWaterGoal);
  const waterPoints = Math.round(waterRatio * 30);

  const sleepToday = sleepHistory.reduce((lastValue, value, index) => {
    const dateKey = dateToKey(sleepDates[index]);
    return dateKey === todayKey ? value : lastValue;
  }, 0);
  const sleepRatio = Math.min(1, sleepToday / 8);
  const sleepPoints = Math.round(sleepRatio * 25);

  const moodToday = moodHistory.reduce((lastMood, value, index) => {
    const dateKey = dateToKey(moodDates[index]);
    return dateKey === todayKey ? value : lastMood;
  }, "");
  const moodFactor = moodToday.includes("üòä") ? 1 : moodToday.includes("üòê") ? 0.65 : moodToday.includes("üòî") ? 0.3 : 0;
  const moodPoints = Math.round(moodFactor * 20);

  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const taskRatio = totalTasks ? doneTasks / totalTasks : 0;
  const taskPoints = Math.round(taskRatio * 15);

  const hasGratitudeToday = gratitudeEntries.some((entry) => dateToKey(entry.time) === todayKey);
  const gratitudePoints = hasGratitudeToday ? 10 : 0;
  const challengePoints = dailyChallengeCompleted ? 10 : 0;

  const totalScore = Math.max(0, Math.min(100, waterPoints + sleepPoints + moodPoints + taskPoints + gratitudePoints + challengePoints));

  wellnessScoreEl.innerText = `${totalScore}/100`;

  let status = "Needs Focus";
  if (totalScore >= 80) status = "Excellent";
  else if (totalScore >= 60) status = "Good";
  wellnessStatusEl.innerText = status;
  if (wellnessReassuranceEl) {
    wellnessReassuranceEl.innerText =
      totalScore >= 80 ? "You‚Äôre on track today ‚Äî protect this rhythm." :
      totalScore >= 60 ? "You‚Äôre moving well ‚Äî one more check-in can lift this further." :
      "A small action now can shift your whole day upward.";
  }

  const actions = [];
  if (waterRatio < 1) {
    const remaining = Math.max(0, effectiveWaterGoal - waterToday);
    actions.push(`Drink ${remaining} more glass${remaining === 1 ? "" : "es"} to hit your goal.`);
  }
  if (sleepToday < 7) actions.push("Aim for at least 7‚Äì8 hours of sleep tonight.");
  if (!moodToday) actions.push("Log your mood for today.");
  else if (moodToday.includes("üòî")) actions.push("Take a 10-minute breathing or walk break.");
  if (taskRatio < 0.7) actions.push("Complete one pending task to boost productivity.");
  if (!hasGratitudeToday) actions.push("Write one gratitude note before the day ends.");
  if (!dailyChallengeCompleted) actions.push("Complete today‚Äôs daily challenge for an extra score boost.");

  while (actions.length < 3) actions.push("Keep your current streak alive with one small check-in.");
  wellnessActionsEl.innerHTML = actions.slice(0, 3).map((item) => `<li>${item}</li>`).join("");
}

function getCrashRiskSnapshot() {
  const todayKey = getTodayKey();

  const waterToday = waterHistory.reduce((sum, value, index) => {
    const dateKey = dateToKey(waterDates[index]);
    return dateKey === todayKey ? sum + value : sum;
  }, 0);
  const effectiveWaterGoal = waterGoal > 0 ? waterGoal : 8;
  const waterRatio = Math.min(1, waterToday / effectiveWaterGoal);

  const sleepToday = sleepHistory.reduce((lastValue, value, index) => {
    const dateKey = dateToKey(sleepDates[index]);
    return dateKey === todayKey ? value : lastValue;
  }, 0);

  const moodToday = moodHistory.reduce((lastMood, value, index) => {
    const dateKey = dateToKey(moodDates[index]);
    return dateKey === todayKey ? value : lastMood;
  }, "");

  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const pendingRatio = totalTasks ? Math.max(0, (totalTasks - doneTasks) / totalTasks) : 0;
  const gratitudeToday = gratitudeEntries.some((entry) => dateToKey(entry.time) === todayKey);

  let risk = 0;
  const reasons = [];

  if (!sleepToday) {
    risk += 22;
    reasons.push("No sleep entry logged today");
  } else if (sleepToday < 6) {
    risk += 30;
    reasons.push("Very low sleep");
  } else if (sleepToday < 7) {
    risk += 16;
    reasons.push("Sleep slightly below recovery zone");
  }

  const hydrationRisk = Math.round((1 - waterRatio) * 25);
  risk += hydrationRisk;
  if (hydrationRisk >= 10) reasons.push("Hydration below target");

  if (!moodToday) {
    risk += 14;
    reasons.push("Mood not logged yet");
  } else if (moodToday.includes("üòî")) {
    risk += 24;
    reasons.push("Low mood detected");
  } else if (moodToday.includes("üòê")) {
    risk += 10;
  }

  const taskRisk = Math.round(pendingRatio * 20);
  risk += taskRisk;
  if (taskRisk >= 10) reasons.push("Too many pending tasks");

  if (!gratitudeToday) risk += 6;
  if (!dailyChallengeCompleted) risk += 4;

  const wellnessScore = Number((wellnessScoreEl?.innerText || "0/100").split("/")[0]) || 0;
  if (wellnessScore < 50) {
    risk += 10;
    reasons.push("Wellness score currently low");
  }

  risk = Math.max(0, Math.min(100, risk));
  const level = risk >= 70 ? "High Risk" : risk >= 45 ? "Medium Risk" : "Low Risk";

  return {
    risk,
    level,
    reasons,
    waterToday,
    sleepToday,
    wellnessScore
  };
}

function updateCrashPreventionUI() {
  if (!crashRiskValue || !crashRiskLevel || !crashRiskReason || !crashAlertBanner || !crashBannerText) return;

  const snapshot = getCrashRiskSnapshot();
  crashRiskValue.innerText = `${snapshot.risk}/100`;
  crashRiskLevel.innerText = snapshot.level;
  if (crashRiskFill) crashRiskFill.style.width = `${snapshot.risk}%`;
  crashRiskReason.innerText = snapshot.reasons[0] || "Keep your streaks active to maintain resilience.";

  const shortReason = snapshot.reasons.slice(0, 2).join(" ‚Ä¢ ") || "Stay consistent with your health basics.";
  if (snapshot.risk >= 65) {
    crashAlertBanner.style.display = "block";
    crashBannerText.innerText = `${snapshot.level}: ${shortReason}`;
  } else {
    crashAlertBanner.style.display = "none";
    crashBannerText.innerText = "Your dip risk is elevated right now.";
  }
}

async function runCrashRescueFlow(options = {}) {
  const showAlert = options.showAlert !== false;
  const user = auth.currentUser;
  if (!user) {
    if (showAlert) alert("Please sign in first.");
    return { ok: false, message: "Please sign in first." };
  }

  const snapshot = getCrashRiskSnapshot();
  const steps = [
    "Do 6 breathing rounds (inhale 4s ‚Ä¢ hold 4s ‚Ä¢ exhale 6s).",
    "Drink 1 glass of water now.",
    "Start one 10-minute micro-task.",
    "Check in after 20 minutes and log your mood again."
  ];

  if (crashRescuePlan) {
    crashRescuePlan.innerHTML = steps.map((step) => `<li>${step}</li>`).join("");
  }

  try {
    const reminderLabel = `Rescue check-in (${snapshot.level})`;
    const targetAtMs = getServerNowDate().getTime() + (20 * 60 * 1000);
    const ref = await addDoc(collection(db, "users", user.uid, "reminders"), {
      text: reminderLabel,
      minutes: 20,
      targetAtMs,
      createdAt: serverTimestamp()
    });
    renderReminder({ id: ref.id, text: reminderLabel, minutes: 20, targetAtMs });

    const rescueRef = await addDoc(collection(db, "users", user.uid, "rescueEvents"), {
      level: snapshot.level,
      reason: (snapshot.reasons && snapshot.reasons[0]) || "",
      time: serverTimestamp()
    });
    rescueEvents.push({ id: rescueRef.id, time: getServerNowDate(), level: snapshot.level });

    updateCrashPreventionUI();
    updateWeeklyReview();
    if (showAlert) {
      alert("‚úÖ Rescue protocol started. A 20-minute recovery reminder is now set.");
    }
    return {
      ok: true,
      level: snapshot.level,
      reason: (snapshot.reasons && snapshot.reasons[0]) || "General resilience support"
    };
  } catch (err) {
    notifyFirestoreError(err);
    return { ok: false, message: "Could not start rescue right now." };
  }
}

function updateInsights() {
  ensureHabitQuestCurrent();
  const moodStreak = calcStreak(moodDates);
  const waterStreak = calcStreak(waterDates);
  const gratitudeStreak = calcStreak(gratitudeEntries.map((entry) => entry.time));
  const challengeStreak = calcStreak(challengeDates);

  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const taskCompletion = totalTasks ? Math.round((doneTasks / totalTasks) * 100) : 0;

  const avgSleep = sleepHistory.length
    ? sleepHistory.reduce((a, b) => a + b, 0) / sleepHistory.length
    : 0;
  const sleepPercent = Math.round(Math.min(100, (avgSleep / 8) * 100));

  const waterSum = waterHistory.reduce((a, b) => a + b, 0);
  const waterPercent = waterGoal > 0 ? Math.round((waterSum / waterGoal) * 100) : 0;

  if (insightTaskTopLabel) {
    insightTaskTopLabel.innerText = `Tasks completed ${doneTasks}/${totalTasks}`;
  }
  if (insightTaskTopBar) {
    setInsightBar(insightTaskTopBar, taskCompletion);
  }

  const weekRange = getCurrentWeekRangeKeys();
  const taskSeries = getSeriesWithPersistedFallback("tasks", getInsightSeries("tasks"), weekRange);
  const sleepSeries = getSeriesWithPersistedFallback("sleep", getInsightSeries("sleep"), weekRange);
  const waterSeries = getSeriesWithPersistedFallback("water", getInsightSeries("water"), weekRange);
  const moodSeries = getSeriesWithPersistedFallback("mood", getInsightSeries("mood"), weekRange);
  const moodToday = getTodayMood();
  const moodLabel = moodToday.includes("üòä") ? "Happy" : moodToday.includes("üòê") ? "Neutral" : moodToday.includes("üòî") ? "Low" : "Not logged";
  const moodPercent = moodToday.includes("üòä") ? 100 : moodToday.includes("üòê") ? 66 : moodToday.includes("üòî") ? 33 : 0;

  const metricViews = [
    {
      title: "Productivity Trend",
      label: `Completion trend ‚Ä¢ ${taskCompletion}% current`,
      percent: taskCompletion,
      series: taskSeries
    },
    {
      title: "Sleep Trend",
      label: `Sleep trend ‚Ä¢ ${avgSleep.toFixed(1)} hrs avg`,
      percent: sleepPercent,
      series: sleepSeries
    },
    {
      title: "Water Intake Trend",
      label: `Hydration trend ‚Ä¢ goal progress ${waterPercent}%`,
      percent: waterPercent,
      series: waterSeries
    },
    {
      title: "Mood Trend",
      label: `Mood direction ‚Ä¢ ${moodLabel}`,
      percent: moodPercent,
      series: moodSeries
    }
  ];

  if (insightMetricIndex < 0 || insightMetricIndex >= metricViews.length) insightMetricIndex = 0;
  renderInsightMetricView(metricViews[insightMetricIndex]);

  updateWellnessScore();
  updateCrashPreventionUI();
  updateBurnoutRadarUI();
  updateWeeklyReview();

  const weekStartKey = weekRange.weekStartKey;
  const weekEndKey = weekRange.weekEndKey;
  const currentScore = Number((wellnessScoreEl?.innerText || "0/100").split("/")[0]) || 0;
  queueInsightsPersist({
    moodStreak,
    waterStreak,
    gratitudeStreak,
    challengeStreak,
    taskCompletion,
    avgSleep: Number(avgSleep.toFixed(1)),
    waterGoalProgress: waterPercent,
    wellnessScore: currentScore,
    wellnessStatus: wellnessStatusEl.innerText || "Needs Focus",
    dailyChallengeCompleted,
    dailyChallenge: currentChallengeText || "",
    barGraphs: {
      weekStartKey,
      weekEndKey,
      labels: Array.isArray(taskSeries?.labels) ? taskSeries.labels : [],
      tasks: {
        values: Array.isArray(taskSeries?.values) ? taskSeries.values : [],
        maxValue: Number(taskSeries?.maxValue) || 100
      },
      sleep: {
        values: Array.isArray(sleepSeries?.values) ? sleepSeries.values : [],
        maxValue: Number(sleepSeries?.maxValue) || 12
      },
      water: {
        values: Array.isArray(waterSeries?.values) ? waterSeries.values : [],
        maxValue: Number(waterSeries?.maxValue) || 8
      },
      mood: {
        values: Array.isArray(moodSeries?.values) ? moodSeries.values : [],
        maxValue: Number(moodSeries?.maxValue) || 3
      }
    }
  });

  refreshStartupFeatures();
  updateClearDataButtonState();
}

function normalizeStartupFeatureState(input) {
  return getDefaultStartupFeatureState();
}

async function saveStartupFeatureState(userId) {
  if (!userId) return;
  try {
    await setDoc(doc(db, "users", userId, "settings", "startupPack"), {
      ...startupFeatureState,
      updatedAt: serverTimestamp()
    }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadStartupFeatureState(userId) {
  startupFeatureState = getDefaultStartupFeatureState();
  if (!userId) {
    refreshStartupFeatures();
    return;
  }

  try {
    const snapshot = await getDoc(doc(db, "users", userId, "settings", "startupPack"));
    if (snapshot.exists()) {
      startupFeatureState = normalizeStartupFeatureState(snapshot.data());
    }
  } catch (err) {
    notifyFirestoreError(err);
  }

  refreshStartupFeatures();
}

function buildStartupPlanItems() {
  const snapshot = getWellnessSnapshot();
  const trends = buildTrendSignals();
  const board = buildPriorityBoard(snapshot, trends);
  return board.slice(0, 3).map((entry) => entry.action);
}

function renderStartupPlan() {
  if (!startupDailyPlanList) return;
  if (!startupCurrentPlan.length) startupCurrentPlan = buildStartupPlanItems();
  startupDailyPlanList.innerHTML = startupCurrentPlan.map((item) => `<li>${escapeHtml(item)}</li>`).join("");
  if (startupPlanMeta) {
    const trends = buildTrendSignals();
    const signal = [
      trends.taskDelta < 0 ? "Task trend dipped" : "Task trend stable",
      trends.sleepDelta < 0 ? "Sleep needs protection" : "Sleep trend steady"
    ].join(" ‚Ä¢ ");
    startupPlanMeta.innerText = `Signal: ${signal}.`;
  }
}

function buildStartupWeeklyReport() {
  const snapshot = getWellnessSnapshot();
  const trends = buildTrendSignals();
  const plan = buildStartupPlanItems();
  return [
    `Date: ${getTodayKey()}`,
    `Wellness Score: ${snapshot.score}/100`,
    `Water: ${snapshot.waterToday}/${snapshot.todayGoal}`,
    `Sleep: ${snapshot.sleepToday || 0}h`,
    `Tasks: ${snapshot.doneTasks}/${snapshot.totalTasks}`,
    `Trend Deltas: Tasks ${trends.taskDelta.toFixed(2)}, Sleep ${trends.sleepDelta.toFixed(2)}, Water ${trends.waterDelta.toFixed(2)}, Mood ${trends.moodDelta.toFixed(2)}`,
    `Action 1: ${plan[0] || "Keep consistency with one key task."}`,
    `Action 2: ${plan[1] || "Protect sleep and hydration today."}`,
    `Action 3: ${plan[2] || "Close the day with gratitude + plan."}`
  ];
}

function renderStartupBehaviorMemory() {
  if (!startupBehaviorMemory) return;
  const trends = buildTrendSignals();
  const todayKey = getTodayKey();
  const todayDate = dateKeyToDate(todayKey) || getServerNowDate();
  const dayKeys = [];
  for (let offset = 13; offset >= 0; offset -= 1) {
    const day = new Date(todayDate);
    day.setUTCDate(todayDate.getUTCDate() - offset);
    const key = dateToKey(day);
    if (key) dayKeys.push(key);
  }

  const moodByDay = new Map();
  moodHistory.forEach((entry, index) => {
    const key = dateToKey(moodDates[index]);
    if (!key || !dayKeys.includes(key)) return;
    const score = String(entry || "").includes("üòä") ? 3 : String(entry || "").includes("üòê") ? 2 : String(entry || "").includes("üòî") ? 1 : 0;
    if (score) moodByDay.set(key, score);
  });

  const waterByDay = new Map();
  waterHistory.forEach((entry, index) => {
    const key = dateToKey(waterDates[index]);
    if (!key || !dayKeys.includes(key)) return;
    waterByDay.set(key, (waterByDay.get(key) || 0) + (Number(entry) || 0));
  });

  const sleepByDay = new Map();
  sleepHistory.forEach((entry, index) => {
    const key = dateToKey(sleepDates[index]);
    if (!key || !dayKeys.includes(key)) return;
    sleepByDay.set(key, Number(entry) || 0);
  });

  const tasksDoneByDay = new Map();
  taskEntries.forEach((entry) => {
    if (!entry?.completed) return;
    const key = dateToKey(entry.completedAt || entry.time);
    if (!key || !dayKeys.includes(key)) return;
    tasksDoneByDay.set(key, (tasksDoneByDay.get(key) || 0) + 1);
  });

  const memories = [];
  const activeDays = dayKeys.filter((key) => moodByDay.has(key) || waterByDay.has(key) || sleepByDay.has(key) || tasksDoneByDay.has(key));
  memories.push(`Analyzed ${activeDays.length} active day${activeDays.length === 1 ? "" : "s"} from your recent logs.`);

  const sleepMoodPairs = dayKeys
    .filter((key) => sleepByDay.has(key) && moodByDay.has(key))
    .map((key) => ({ sleep: Number(sleepByDay.get(key)) || 0, mood: Number(moodByDay.get(key)) || 0 }));
  if (sleepMoodPairs.length) {
    const highSleepMood = safeAvg(sleepMoodPairs.filter((pair) => pair.sleep >= 7).map((pair) => pair.mood));
    const lowSleepMood = safeAvg(sleepMoodPairs.filter((pair) => pair.sleep < 7).map((pair) => pair.mood));
    if (highSleepMood > 0 || lowSleepMood > 0) {
      if (highSleepMood > lowSleepMood && lowSleepMood > 0) {
        memories.push(`Mood score is higher on 7h+ sleep days (${highSleepMood.toFixed(2)} vs ${lowSleepMood.toFixed(2)}).`);
      } else if (highSleepMood > 0) {
        memories.push(`7h+ sleep days correlate with stronger mood stability (avg mood score ${highSleepMood.toFixed(2)}).`);
      } else {
        memories.push(`Current sleep-mood baseline: avg mood score ${lowSleepMood.toFixed(2)} on sub-7h sleep days.`);
      }
    }
  }

  const hydrationTarget = waterGoal > 0 ? waterGoal : 8;
  const waterTaskPairs = dayKeys
    .filter((key) => waterByDay.has(key) || tasksDoneByDay.has(key))
    .map((key) => ({
      water: Number(waterByDay.get(key)) || 0,
      tasks: Number(tasksDoneByDay.get(key)) || 0
    }));
  if (waterTaskPairs.length) {
    const highHydrationTaskAvg = safeAvg(waterTaskPairs.filter((pair) => pair.water >= hydrationTarget).map((pair) => pair.tasks));
    const lowHydrationTaskAvg = safeAvg(waterTaskPairs.filter((pair) => pair.water < hydrationTarget).map((pair) => pair.tasks));
    if (highHydrationTaskAvg > 0 || lowHydrationTaskAvg > 0) {
      memories.push(`Task completion on hydration-target days: ${highHydrationTaskAvg.toFixed(1)} vs ${lowHydrationTaskAvg.toFixed(1)} on lower-hydration days.`);
    }
  }

  let bestKey = "";
  let bestScore = -1;
  dayKeys.forEach((key) => {
    const moodScore = (Number(moodByDay.get(key)) || 0) * 20;
    const sleepScore = Math.min(8, Number(sleepByDay.get(key)) || 0) * 8;
    const waterScore = Math.min(1, (Number(waterByDay.get(key)) || 0) / hydrationTarget) * 20;
    const taskScore = Math.min(4, Number(tasksDoneByDay.get(key)) || 0) * 6;
    const score = moodScore + sleepScore + waterScore + taskScore;
    if (score > bestScore) {
      bestScore = score;
      bestKey = key;
    }
  });
  if (bestKey) {
    memories.push(`Best pattern day (${bestKey}): sleep ${Number(sleepByDay.get(bestKey)) || 0}h, water ${Number(waterByDay.get(bestKey)) || 0}, tasks ${Number(tasksDoneByDay.get(bestKey)) || 0}.`);
  }

  if (trends.taskDelta > 0) memories.push("Recent task trend is rising ‚Äî keep the same work blocks.");
  if (trends.sleepDelta < 0) memories.push("Sleep trend dipped recently ‚Äî protect bedtime consistency this week.");
  if (trends.waterDelta < 0) memories.push("Hydration trend is softening ‚Äî schedule fixed water checkpoints.");
  if (trends.moodDelta < 0) memories.push("Mood trend dipped ‚Äî add an early recovery break in the first half of the day.");

  if (!activeDays.length) {
    memories.length = 0;
    memories.push("No recent logs detected yet ‚Äî first memory will unlock after your next check-in.");
  }

  startupBehaviorMemory.innerHTML = memories.slice(0, 5).map((item) => `<li>${escapeHtml(item)}</li>`).join("");
}

function refreshStartupFeatures() {
  renderStartupPlan();
  renderStartupBehaviorMemory();
  if (startupRefreshPlanBtn) {
    startupRefreshPlanBtn.innerText = startupPlanGeneratedOnce ? "Regenerate Plan" : "Generate Plan";
    const planLimited = startupUsageState.planCount >= STARTUP_PLAN_DAILY_LIMIT;
    startupRefreshPlanBtn.disabled = planLimited;
    startupRefreshPlanBtn.title = planLimited ? "Daily planner limit reached. Come back tomorrow." : "";
  }
  if (startupGenerateReportBtn) {
    startupGenerateReportBtn.innerText = startupReportGeneratedOnce ? "Regenerate Report" : "Generate Report";
    const reportLimited = startupUsageState.reportCount >= STARTUP_REPORT_WEEKLY_LIMIT;
    startupGenerateReportBtn.disabled = reportLimited;
    startupGenerateReportBtn.title = reportLimited ? "Weekly startup report limit reached. Come back next week." : "";
  }
  if (startupWeeklyReportText && !startupWeeklyReportCache) {
    startupWeeklyReportText.innerHTML = "<li>No report generated yet.</li>";
  }
}

async function refreshStartupPlan() {
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  await ensureStartupUsageCurrent(user.uid);
  if (startupUsageState.planCount >= STARTUP_PLAN_DAILY_LIMIT) {
    showToast(`Daily planner limit reached (${STARTUP_PLAN_DAILY_LIMIT}/day). Come back tomorrow.`);
    refreshStartupFeatures();
    return;
  }

  startupPlanGeneratedOnce = true;
  startupCurrentPlan = buildStartupPlanItems();
  startupUsageState.planCount += 1;
  await saveStartupUsageState(user.uid);
  renderStartupPlan();
  refreshStartupFeatures();
}

async function applyStartupPlanAsTasks() {
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  if (!startupCurrentPlan.length) {
    await ensureStartupUsageCurrent(user.uid);
    if (startupUsageState.planCount >= STARTUP_PLAN_DAILY_LIMIT) {
      showToast(`Daily planner limit reached (${STARTUP_PLAN_DAILY_LIMIT}/day). Come back tomorrow.`);
      refreshStartupFeatures();
      return;
    }
    startupPlanGeneratedOnce = true;
    startupCurrentPlan = buildStartupPlanItems();
    startupUsageState.planCount += 1;
    await saveStartupUsageState(user.uid);
    refreshStartupFeatures();
  }

  for (let index = 0; index < startupCurrentPlan.length; index += 1) {
    const raw = startupCurrentPlan[index].trim();
    task.value = raw.length > 90 ? `${raw.slice(0, 87)}...` : raw;
    await addTask();
  }
  showToast("Startup plan added to tasks.");
}

async function generateStartupWeeklyReport() {
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  await ensureStartupUsageCurrent(user.uid);
  if (startupUsageState.reportCount >= STARTUP_REPORT_WEEKLY_LIMIT) {
    showToast(`Weekly startup report limit reached (${STARTUP_REPORT_WEEKLY_LIMIT}/week). Come back next week.`);
    refreshStartupFeatures();
    return;
  }

  startupReportGeneratedOnce = true;
  startupWeeklyReportCache = buildStartupWeeklyReport();
  startupUsageState.reportCount += 1;
  await saveStartupUsageState(user.uid);
  if (startupWeeklyReportText) {
    startupWeeklyReportText.innerHTML = startupWeeklyReportCache
      .map((line) => `<li>${escapeHtml(line)}</li>`)
      .join("");
  }
  if (startupGenerateReportBtn) startupGenerateReportBtn.innerText = "Regenerate Report";
  refreshStartupFeatures();
  showToast("Weekly report generated.");
}

async function copyStartupWeeklyReport() {
  if (!startupWeeklyReportCache) {
    showToast("Generate weekly report first.");
    return;
  }
  try {
    const reportText = ["NovaFix Weekly Report", ...startupWeeklyReportCache].map((line) => `- ${line}`).join("\n");
    await navigator.clipboard.writeText(reportText);
    showToast("Weekly report copied.");
  } catch (_) {
    showToast("Could not copy report right now.");
  }
}

// AI Companion
function escapeHtml(text) {
  return text
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function getUserName(user) {
  if (user?.displayName && user.displayName.trim()) return user.displayName.trim();
  if (user?.email) return user.email.split("@")[0];
  return "there";
}

function rememberPrompt(promptText) {
  if (!promptText) return;
  aiRecentPrompts.push(promptText);
  if (aiRecentPrompts.length > 6) aiRecentPrompts.shift();
}

function pushTopicHistory(topic) {
  if (!topic) return;
  aiSessionState.topicHistory.push(topic);
  if (aiSessionState.topicHistory.length > 12) aiSessionState.topicHistory.shift();
}

function tokenizeText(text) {
  return String(text || "")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .split(/\s+/)
    .filter(Boolean);
}

function jaccardSimilarity(a, b) {
  const aSet = new Set(tokenizeText(a));
  const bSet = new Set(tokenizeText(b));
  if (!aSet.size || !bSet.size) return 0;
  let intersection = 0;
  aSet.forEach((token) => {
    if (bSet.has(token)) intersection += 1;
  });
  const union = new Set([...aSet, ...bSet]).size;
  return union ? intersection / union : 0;
}

function rememberUserFact(type, value) {
  if (!value) return;

  if (type === "name") {
    aiSessionState.userFacts.name = value.trim();
    return;
  }

  if (type === "goal") {
    aiSessionState.userFacts.goal = value.trim();
    return;
  }

  if (type === "likes") {
    const normalized = value.trim().toLowerCase();
    if (!normalized) return;
    if (!aiSessionState.userFacts.likes.includes(normalized)) {
      aiSessionState.userFacts.likes.push(normalized);
      if (aiSessionState.userFacts.likes.length > 8) aiSessionState.userFacts.likes.shift();
    }
    return;
  }

  if (type === "dislikes") {
    const normalized = value.trim().toLowerCase();
    if (!normalized) return;
    if (!aiSessionState.userFacts.dislikes.includes(normalized)) {
      aiSessionState.userFacts.dislikes.push(normalized);
      if (aiSessionState.userFacts.dislikes.length > 8) aiSessionState.userFacts.dislikes.shift();
    }
  }
}

function learnFromUserInput(input) {
  const text = String(input || "").trim();
  if (!text) return;

  const nameMatch = text.match(/(?:my name is|i am|i'm)\s+([a-z][a-z\s'-]{1,24})/i);
  if (nameMatch?.[1]) {
    rememberUserFact("name", nameMatch[1]);
  }

  const goalMatch = text.match(/(?:my goal is|i want to|i need to|i plan to)\s+(.+)/i);
  if (goalMatch?.[1] && goalMatch[1].length < 120) {
    rememberUserFact("goal", goalMatch[1]);
  }

  const likeMatch = text.match(/(?:i like|i love)\s+(.+)/i);
  if (likeMatch?.[1] && likeMatch[1].length < 80) {
    rememberUserFact("likes", likeMatch[1]);
  }

  const dislikeMatch = text.match(/(?:i dislike|i hate|i don't like)\s+(.+)/i);
  if (dislikeMatch?.[1] && dislikeMatch[1].length < 80) {
    rememberUserFact("dislikes", dislikeMatch[1]);
  }
}

function buildUserContextLabel(defaultName) {
  const memoryName = aiSessionState.userFacts.name;
  if (memoryName) return memoryName;
  return defaultName;
}

function calculateExpressionFromText(text) {
  const match = text.match(/(?:calculate|solve|what is|what's)\s*([\d+\-*/().%\s]+)/i);
  if (!match || !match[1]) return null;
  const expression = match[1].trim();
  if (!/^[\d+\-*/().%\s]+$/.test(expression)) return null;

  try {
    const result = Function(`"use strict"; return (${expression});`)();
    if (typeof result !== "number" || !Number.isFinite(result)) return null;
    return { expression, result };
  } catch (_) {
    return null;
  }
}

function detectEmotionFromText(text) {
  if (/\b(stress|anxious|anxiety|overwhelm|panic|sad|depressed|down|tired|burnout)\b/.test(text)) return "low";
  if (/\b(good|great|awesome|amazing|happy|motivated|energized|fine)\b/.test(text)) return "positive";
  return "neutral";
}

function classifyIntent(input) {
  const msg = String(input || "").toLowerCase();
  const intents = [
    { key: "greeting", score: /\b(hi|hello|hey|yo|hola)\b/.test(msg) ? 0.95 : 0 },
    { key: "smalltalk-health", score: /\b(how are you|how are u|how's it going|how you doing|how r you)\b/.test(msg) ? 0.98 : 0 },
    { key: "smalltalk-activity", score: /\b(what are you doing|what are u doing|wyd|what you doing)\b/.test(msg) ? 0.97 : 0 },
    { key: "identity", score: /who are you|what are you|your name|are you ai|are you real/.test(msg) ? 0.94 : 0 },
    { key: "analysis", score: /analyze|analysis|report|conclude|insight|summary|score/.test(msg) ? 0.93 : 0 },
    { key: "plan", score: /plan|routine|today|schedule|what should i do/.test(msg) ? 0.92 : 0 },
    { key: "decision", score: /decide|choose|which should i|best option|priority|first/.test(msg) ? 0.925 : 0 },
    { key: "why", score: /why|reason|because|explain|what caused/.test(msg) ? 0.915 : 0 },
    { key: "optimize", score: /optimize|improve faster|maximize|best strategy|upgrade/.test(msg) ? 0.905 : 0 },
    { key: "stress", score: /stress|anxious|anxiety|overwhelm|panic|sad|depressed|down/.test(msg) ? 0.91 : 0 },
    { key: "sleep", score: /sleep|tired|exhausted|fatigue|insomnia/.test(msg) ? 0.9 : 0 },
    { key: "water", score: /water|hydrate|hydration|thirsty/.test(msg) ? 0.89 : 0 },
    { key: "productivity", score: /task|focus|productivity|procrastin|work|study/.test(msg) ? 0.88 : 0 },
    { key: "gratitude", score: /gratitude|thankful|grateful/.test(msg) ? 0.87 : 0 },
    { key: "capabilities", score: /help|what can you do|features|assist|commands/.test(msg) ? 0.86 : 0 },
    { key: "followup", score: /\b(and then|then what|what next|next step|continue|go deeper)\b/.test(msg) ? 0.85 : 0 },
    { key: "joke", score: /\b(joke|make me laugh|funny)\b/.test(msg) ? 0.84 : 0 },
    { key: "thanks", score: /\b(thanks|thank you|thx|ty)\b/.test(msg) ? 0.83 : 0 },
    { key: "bye", score: /\b(bye|goodbye|see you|cya|gn|good night)\b/.test(msg) ? 0.82 : 0 }
  ];

  const sorted = intents.sort((a, b) => b.score - a.score);
  const best = sorted[0];
  if (!best || best.score < 0.5) return { key: "fallback", confidence: 0 };
  return { key: best.key, confidence: best.score };
}

function buildAdaptiveTone(userEmotion, turnCount) {
  if (userEmotion === "low") return "supportive";
  if (turnCount > 8) return "compact";
  return "energetic";
}

function getAiModePreset() {
  return AI_MODE_PRESETS[aiReasoningMode] || AI_MODE_PRESETS.balanced;
}

function setAiMode(nextMode) {
  const normalized = String(nextMode || "").toLowerCase().trim();
  if (!AI_MODE_PRESETS[normalized]) return false;
  aiReasoningMode = normalized;
  return true;
}

function parseModeFromInput(input) {
  const match = String(input || "").toLowerCase().match(/(?:mode|style)\s*(?:to)?\s*(ultra|balanced|coach|strict|creative)/);
  return match?.[1] || null;
}

function getMemorySummary() {
  const { name, goal, likes, dislikes } = aiSessionState.userFacts;
  const lines = [];
  if (name) lines.push(`Name: ${name}`);
  if (goal) lines.push(`Goal: ${goal}`);
  if (likes.length) lines.push(`Likes: ${likes.slice(-3).join(", ")}`);
  if (dislikes.length) lines.push(`Dislikes: ${dislikes.slice(-3).join(", ")}`);
  if (!lines.length) return "No remembered user facts yet.";
  return lines.join(" | ");
}

function parseCompareRequest(input) {
  const text = String(input || "").trim();
  const versusMatch = text.match(/(.+?)\s+(?:vs|versus|or)\s+(.+)/i);
  if (!versusMatch) return null;
  const left = versusMatch[1].replace(/^(compare|difference between|choose between)\s+/i, "").trim();
  const right = versusMatch[2].trim();
  if (!left || !right) return null;
  if (left.length > 60 || right.length > 60) return null;
  return { left, right };
}

function buildComparisonResponse(left, right, snapshot) {
  const remainingWater = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
  return {
    summary: `If your priority is fast execution today, choose the option with lower setup friction right now.`,
    prosLeft: [
      `${left} may be easier to start immediately.`,
      `${left} can create quicker momentum if you‚Äôre low on energy.`,
      `${left} likely has lower cognitive overhead.`
    ],
    prosRight: [
      `${right} may provide stronger long-term upside.`,
      `${right} can improve skill depth if sustained consistently.`,
      `${right} might align better if your energy is high right now.`
    ],
    decisionRule: `Decision rule: pick the option you can start in <10 minutes, then hydrate ${remainingWater > 0 ? `(${remainingWater} glass(es) left today)` : "and maintain hydration"}.`
  };
}

function buildModeAwarePrefix(tone) {
  const preset = getAiModePreset();
  if (preset.style === "strict") return "Direct answer: ";
  if (preset.style === "coach") return "Coach mode: ";
  if (preset.style === "creative") return "Creative mode: ";
  if (preset.style === "ultra") return "Focused mode: ";
  if (tone === "supportive") return "I‚Äôm with you. ";
  if (tone === "compact") return "Quick answer: ";
  return "Let‚Äôs go: ";
}

function buildUltraFallback(snapshot, name) {
  const plan = buildDeepPlan(snapshot);
  const goalLine = aiSessionState.userFacts.goal
    ? `<br>üéØ Goal alignment: <i>${escapeHtml(aiSessionState.userFacts.goal)}</i>`
    : "";
  return `üß† <b>Strategic Response</b><br>Hey ${escapeHtml(name)}, here is your best move stack now:<br>1) ${plan[0]}<br>2) ${plan[1]}<br>3) ${plan[2]}<br>4) ${plan[3]}${goalLine}<br><br>Reply with <i>execute step 1</i>, <i>mode strict</i>, or ask a direct comparison like <i>A vs B</i>.`;
}

function buildKnowledgeAnswer(input) {
  const text = String(input || "");
  const knowledge = [
    {
      topic: "sleep",
      triggers: ["sleep", "insomnia", "tired", "fatigue", "bed"],
      answer: "For better sleep: keep a fixed sleep window, reduce bright light 60 minutes before bed, avoid caffeine after afternoon, and use a short wind-down ritual (breathing + low-stimulation activity)."
    },
    {
      topic: "focus",
      triggers: ["focus", "procrastination", "deep work", "study", "work"],
      answer: "Use the 25-5 cycle: define one outcome, remove distractions, sprint 25 minutes, then 5-minute reset. Repeat 2-3 rounds before checking messages."
    },
    {
      topic: "stress",
      triggers: ["stress", "anxiety", "panic", "overwhelmed"],
      answer: "When stressed, reduce physiological load first: long exhale breathing, hydration, and one very small actionable step. Momentum usually lowers anxiety faster than overthinking."
    },
    {
      topic: "hydration",
      triggers: ["water", "hydration", "dehydrated", "thirsty"],
      answer: "Hydration works best with timing: one glass after waking, one with each meal, and one before evening wind-down. Small consistent doses beat large late intake."
    },
    {
      topic: "habits",
      triggers: ["habit", "consistency", "discipline", "routine"],
      answer: "Build habits with tiny minimums: define a trigger, make the action small, and track daily completion. Consistency compounds faster than intensity."
    }
  ];

  const scored = knowledge
    .map((entry) => {
      const triggerScore = entry.triggers.reduce((score, trigger) => score + (text.toLowerCase().includes(trigger) ? 1 : 0), 0);
      const similarity = jaccardSimilarity(text, `${entry.topic} ${entry.triggers.join(" ")}`);
      return { ...entry, score: triggerScore + similarity };
    })
    .sort((a, b) => b.score - a.score);

  if (!scored[0] || scored[0].score < 0.5) return null;
  pushTopicHistory(scored[0].topic);
  return scored[0].answer;
}

function buildActionCoaching(snapshot) {
  const actions = [];
  if (snapshot.pendingTasks > 0) actions.push("Pick 1 pending task and do a focused 25-minute sprint.");
  if (snapshot.waterToday < snapshot.todayGoal) {
    const left = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
    actions.push(`Drink ${left} more glass${left === 1 ? "" : "es"} of water.`);
  }
  if (snapshot.sleepToday < 7) actions.push("Plan an earlier wind-down to target 7‚Äì8 hours sleep.");
  if (!snapshot.gratitudeToday) actions.push("Write one gratitude line before bed.");
  if (!snapshot.moodToday) actions.push("Log your mood to improve your daily insights.");
  while (actions.length < 3) actions.push("Keep momentum with one small healthy action right now.");
  return actions.slice(0, 3);
}

function buildDeepPlan(snapshot) {
  const waterLeft = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
  return [
    snapshot.pendingTasks > 0
      ? "Block 1 (0-25 min): close one pending task with single-task focus."
      : "Block 1 (0-25 min): define and start one meaningful task.",
    waterLeft > 0
      ? `Block 2 (25-35 min): drink ${Math.max(1, waterLeft)} glass(es) and reset posture/breathing.`
      : "Block 2 (25-35 min): movement + posture reset.",
    snapshot.sleepToday < 7
      ? "Block 3 (35-50 min): finish priority work and set a wind-down reminder."
      : "Block 3 (35-50 min): second deep-focus sprint.",
    snapshot.gratitudeToday
      ? "Block 4 (50-60 min): quick reflection and tomorrow‚Äôs first action."
      : "Block 4 (50-60 min): write one gratitude line and set tomorrow‚Äôs first action."
  ];
}

function safeAvg(numbers) {
  const source = Array.isArray(numbers) ? numbers.filter((value) => Number.isFinite(Number(value))) : [];
  if (!source.length) return 0;
  return source.reduce((sum, value) => sum + Number(value), 0) / source.length;
}

function buildTrendSignals() {
  const todayKey = getTodayKey();
  const last7Keys = [];
  const anchor = dateKeyToDate(todayKey) || getServerNowDate();
  anchor.setUTCHours(0, 0, 0, 0);
  for (let index = 6; index >= 0; index -= 1) {
    const date = new Date(anchor);
    date.setUTCDate(anchor.getUTCDate() - index);
    const key = dateToKey(date);
    if (key) last7Keys.push(key);
  }

  const moodByDay = new Map();
  moodHistory.forEach((entry, index) => {
    const key = dateToKey(moodDates[index]);
    if (!key || !last7Keys.includes(key)) return;
    const score = String(entry || "").includes("üòä") ? 3 : String(entry || "").includes("üòê") ? 2 : String(entry || "").includes("üòî") ? 1 : 0;
    if (!score) return;
    moodByDay.set(key, score);
  });

  const waterByDay = new Map();
  waterHistory.forEach((entry, index) => {
    const key = dateToKey(waterDates[index]);
    if (!key || !last7Keys.includes(key)) return;
    waterByDay.set(key, (waterByDay.get(key) || 0) + (Number(entry) || 0));
  });

  const sleepByDay = new Map();
  sleepHistory.forEach((entry, index) => {
    const key = dateToKey(sleepDates[index]);
    if (!key || !last7Keys.includes(key)) return;
    sleepByDay.set(key, Number(entry) || 0);
  });

  const tasksByDay = new Map();
  taskEntries.forEach((entry) => {
    if (!entry?.completed) return;
    const key = dateToKey(entry.completedAt || entry.time);
    if (!key || !last7Keys.includes(key)) return;
    tasksByDay.set(key, (tasksByDay.get(key) || 0) + 1);
  });

  const firstHalf = last7Keys.slice(0, 3);
  const secondHalf = last7Keys.slice(-3);
  const avgFor = (map, keys) => safeAvg(keys.map((key) => Number(map.get(key)) || 0));

  const moodDelta = avgFor(moodByDay, secondHalf) - avgFor(moodByDay, firstHalf);
  const waterDelta = avgFor(waterByDay, secondHalf) - avgFor(waterByDay, firstHalf);
  const sleepDelta = avgFor(sleepByDay, secondHalf) - avgFor(sleepByDay, firstHalf);
  const taskDelta = avgFor(tasksByDay, secondHalf) - avgFor(tasksByDay, firstHalf);

  return {
    moodDelta,
    waterDelta,
    sleepDelta,
    taskDelta,
    moodAvg: avgFor(moodByDay, last7Keys),
    waterAvg: avgFor(waterByDay, last7Keys),
    sleepAvg: avgFor(sleepByDay, last7Keys),
    taskAvg: avgFor(tasksByDay, last7Keys)
  };
}

function buildPriorityBoard(snapshot, trends) {
  const waterLeft = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
  const candidates = [
    {
      id: "task",
      action: snapshot.pendingTasks > 0 ? "Finish one pending task in a 25-minute sprint." : "Create one meaningful task and start it now.",
      impact: snapshot.pendingTasks > 0 ? 82 : 62,
      urgency: snapshot.pendingTasks > 2 ? 22 : 10,
      trendBoost: trends.taskDelta < 0 ? 10 : 0
    },
    {
      id: "water",
      action: waterLeft > 0 ? `Drink ${waterLeft} glass${waterLeft === 1 ? "" : "es"} to hit hydration target.` : "Hydration is on track ‚Äî maintain steady intake.",
      impact: waterLeft > 0 ? 74 : 44,
      urgency: waterLeft >= 3 ? 18 : waterLeft > 0 ? 10 : 0,
      trendBoost: trends.waterDelta < 0 ? 12 : 0
    },
    {
      id: "sleep",
      action: snapshot.sleepToday < 7 ? "Protect tonight‚Äôs sleep window (7-8h) and set wind-down alarm." : "Keep sleep quality stable with a fixed bedtime.",
      impact: snapshot.sleepToday < 7 ? 79 : 46,
      urgency: snapshot.sleepToday < 6 ? 22 : snapshot.sleepToday < 7 ? 12 : 0,
      trendBoost: trends.sleepDelta < 0 ? 11 : 0
    },
    {
      id: "mood",
      action: !snapshot.moodToday ? "Log your mood now to improve your guidance accuracy." : "Run a 2-minute reset to keep emotional stability high.",
      impact: !snapshot.moodToday ? 63 : 50,
      urgency: !snapshot.moodToday ? 15 : 6,
      trendBoost: trends.moodDelta < 0 ? 14 : 0
    },
    {
      id: "gratitude",
      action: !snapshot.gratitudeToday ? "Write one gratitude line to lock a positive close." : "Maintain gratitude consistency before day-end.",
      impact: !snapshot.gratitudeToday ? 55 : 38,
      urgency: !snapshot.gratitudeToday ? 8 : 3,
      trendBoost: 0
    }
  ];

  return candidates
    .map((entry) => ({ ...entry, score: entry.impact + entry.urgency + entry.trendBoost }))
    .sort((a, b) => b.score - a.score);
}

function buildWhySummary(snapshot, trends) {
  const drivers = [];
  if (snapshot.pendingTasks > 2) drivers.push("task load is currently high");
  if (snapshot.sleepToday < 7) drivers.push("sleep is below recovery zone");
  if (snapshot.waterToday < snapshot.todayGoal) drivers.push("hydration is below target");
  if (!snapshot.moodToday) drivers.push("mood signal is missing for today");
  if (trends.taskDelta < 0) drivers.push("recent task completion trend is softening");
  if (trends.sleepDelta < 0) drivers.push("sleep trend dipped in the last few days");
  if (trends.waterDelta < 0) drivers.push("hydration trend is dropping");
  if (!drivers.length) drivers.push("your current inputs are relatively stable");
  return drivers.slice(0, 4);
}

function getTodayWater() {
  const todayKey = getTodayKey();
  return waterHistory.reduce((sum, value, index) => {
    const dateKey = dateToKey(waterDates[index]);
    return dateKey === todayKey ? sum + value : sum;
  }, 0);
}

function getTodayMood() {
  const todayKey = getTodayKey();
  return moodHistory.reduce((lastMood, value, index) => {
    const dateKey = dateToKey(moodDates[index]);
    return dateKey === todayKey ? value : lastMood;
  }, "");
}

function getTodaySleep() {
  const todayKey = getTodayKey();
  return sleepHistory.reduce((lastSleep, value, index) => {
    const dateKey = dateToKey(sleepDates[index]);
    return dateKey === todayKey ? value : lastSleep;
  }, 0);
}

function getWellnessSnapshot() {
  const waterToday = getTodayWater();
  const todayGoal = waterGoal > 0 ? waterGoal : 8;
  const moodToday = getTodayMood();
  const sleepToday = getTodaySleep();
  const totalTasks = taskEntries.length;
  const doneTasks = taskEntries.filter((entry) => !!entry.completed).length;
  const pendingTasks = taskEntries.filter((entry) => !entry.completed).length;
  const gratitudeToday = gratitudeEntries.some((entry) => dateToKey(entry.time) === getTodayKey());
  const score = Number((wellnessScoreEl?.innerText || "0/100").split("/")[0]) || 0;

  return {
    waterToday,
    todayGoal,
    moodToday,
    sleepToday,
    totalTasks,
    doneTasks,
    pendingTasks,
    gratitudeToday,
    score
  };
}

async function tryAiAction(input, user) {
  const msg = input.trim();
  const lower = msg.toLowerCase();

  const requestedMode = parseModeFromInput(msg);
  if (requestedMode) {
    const changed = setAiMode(requestedMode);
    if (changed) {
      return `‚úÖ Response style updated.`;
    }
    return "‚ÑπÔ∏è Unknown mode. Use: balanced, coach, strict, creative.";
  }

  const rememberMatch = msg.match(/^remember\s+(?:that\s+)?(.+)/i);
  if (rememberMatch?.[1]) {
    learnFromUserInput(rememberMatch[1]);
    return `‚úÖ Saved memory: ${escapeHtml(rememberMatch[1].trim())}`;
  }

  if (/^(?:what do you remember|recall memory|memory|show memory)$/i.test(msg)) {
    return `üß† Memory: ${escapeHtml(getMemorySummary())}`;
  }

  if (/^(start\s+reset|reset\s+me|calm\s+me)$/i.test(msg)) {
    return "‚úÖ 60-second reset: inhale 4s ‚Üí hold 4s ‚Üí exhale 6s for 6 rounds, drink a glass of water, then do one 10-minute micro-task.";
  }

  if (/^(?:run|start|do|begin|trigger)\s+(?:the\s+)?(?:mood\s+)?(?:crash\s+)?rescue$/i.test(msg)) {
    const rescueResult = await runCrashRescueFlow({ showAlert: false });
    if (!rescueResult?.ok) {
      return `‚ÑπÔ∏è ${rescueResult?.message || "Could not start rescue right now."}`;
    }
    return `üõü Mood crash rescue started (${rescueResult.level}). A 20-minute recovery reminder is now set. Focus now: ${rescueResult.reason}.`;
  }

  const taskMatch = msg.match(/^(add|create)\s+(a\s+)?task\s*[:\-]?\s*(.+)$/i);
  if (taskMatch && taskMatch[3]) {
    task.value = taskMatch[3].trim();
    await addTask();
    return `‚úÖ Added task: ${taskMatch[3].trim()}`;
  }

  const waterGoalMatch = lower.match(/(?:set|update)\s+(?:my\s+)?water\s+goal\s+(?:to\s+)?(\d+)/i);
  if (waterGoalMatch) {
    waterGoalInput.value = String(Number(waterGoalMatch[1]) || 0);
    await setWaterGoal();
    return `‚úÖ Water goal updated to ${waterGoalInput.value} glasses.`;
  }

  const waterLogMatch = lower.match(/(?:log|add|track)\s+(\d+)\s*(?:glass|glasses)\s*(?:of\s+water)?/i);
  if (waterLogMatch) {
    waterInput.value = String(Number(waterLogMatch[1]) || 0);
    await saveWater();
    return `‚úÖ Logged ${waterInput.value || waterLogMatch[1]} glasses of water.`;
  }

  const sleepMatch = lower.match(/(?:log|save|track)\s+sleep\s+(?:for\s+)?(\d+(?:\.\d+)?)\s*(?:h|hr|hrs|hour|hours)?/i);
  if (sleepMatch) {
    sleepInput.value = sleepMatch[1];
    await saveSleep();
    return `‚úÖ Sleep logged: ${sleepMatch[1]} hours.`;
  }

  const moodMatch = lower.match(/(?:log|set|save)\s+mood\s+(happy|neutral|nuetral|low|sad)/i);
  if (moodMatch) {
    const map = { happy: "üòä Happy", neutral: "üòê Neutral", nuetral: "üòê Neutral", low: "üòî Low", sad: "üòî Low" };
    mood.value = map[moodMatch[1]] || mood.value;
    await saveMood();
    return `‚úÖ Mood logged: ${mood.value}`;
  }

  const gratitudeMatch = msg.match(/^(?:add|log|save)\s+gratitude\s*[:\-]?\s*(.+)$/i);
  if (gratitudeMatch && gratitudeMatch[1]) {
    gratitudeInput.value = gratitudeMatch[1].trim();
    await saveGratitude();
    return `‚úÖ Gratitude saved.`;
  }

  const reminderMatch = msg.match(/^remind\s+me\s+to\s+(.+)\s+in\s+(\d+)\s*(m|min|mins|minute|minutes)$/i);
  if (reminderMatch) {
    reminderText.value = reminderMatch[1].trim();
    reminderMinutes.value = String(Number(reminderMatch[2]) || 0);
    addReminder();
    return `‚úÖ Reminder set: ${reminderMatch[1].trim()} in ${reminderMatch[2]} min.`;
  }

  const reminderDeleteMatch = msg.match(/^(?:delete|remove|cancel|clear)\s+(?:the\s+)?reminder\b(.*)$/i);
  if (reminderDeleteMatch && user?.uid) {
    const rawQuery = (reminderDeleteMatch[1] || "")
      .replace(/^\s*(?:for|about|named|:)\s*/i, "")
      .trim();

    const result = await deleteReminderFromAi(user.uid, rawQuery);
    if (result.ok) {
      const label = result.entry?.text || "selected reminder";
      return `‚úÖ Deleted reminder: ${label}`;
    }
    return `‚ÑπÔ∏è ${result.message}`;
  }

  if (/^(?:list|show|view)\s+reminders$/i.test(msg) && user?.uid) {
    try {
      const snapshot = await getDocs(collection(db, "users", user.uid, "reminders"));
      const items = snapshot.docs
        .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
        .sort((a, b) => (Number(a.targetAtMs) || 0) - (Number(b.targetAtMs) || 0));

      if (!items.length) return "‚ÑπÔ∏è You have no reminders right now.";

      const lines = items.slice(0, 8).map((entry, index) => `${index + 1}) ${entry.text || "Reminder"}`);
      return `‚è∞ Reminders:<br>${lines.map((line) => `‚Ä¢ ${escapeHtml(line)}`).join("<br>")}`;
    } catch (err) {
      notifyFirestoreError(err);
      return "‚ÑπÔ∏è Could not load reminders right now.";
    }
  }

  if (/^(?:clear|delete|remove)\s+all\s+reminders$/i.test(msg) && user?.uid) {
    try {
      const snapshot = await getDocs(collection(db, "users", user.uid, "reminders"));
      await Promise.all(snapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
      clearAllReminderTimers();
      reminders.innerHTML = "";
      scheduleEmptyState(reminders, ".item-row", "No reminders set yet ‚Äî add one small prompt for today.");
      updateClearDataButtonState();
      return "‚úÖ Cleared all reminders.";
    } catch (err) {
      notifyFirestoreError(err);
      return "‚ÑπÔ∏è Could not clear reminders right now.";
    }
  }

  return null;
}

async function buildSmartAiResponse(input, user) {
  const actionResult = await tryAiAction(input, user);
  if (actionResult) {
    return {
      response: `${actionResult}<br>ü§ñ I can also run: <i>add task ..., set water goal 8, log mood sad, log sleep 7, remind me to ... in 20 min, list reminders, delete reminder 1</i>.`,
      isHtml: true
    };
  }

  const msg = input.toLowerCase();
  const baseName = getUserName(user);
  learnFromUserInput(input);
  const name = buildUserContextLabel(baseName);
  const hour = getServerNowDate().getUTCHours();
  const greeting = hour < 12 ? "Good morning" : hour < 18 ? "Good afternoon" : "Good evening";
  const snapshot = getWellnessSnapshot();
  aiSessionState.lastSnapshot = snapshot;
  const recentContext = aiRecentPrompts.slice(-3).join(" ‚Ä¢ ");
  const mathResult = calculateExpressionFromText(input);
  const emotion = detectEmotionFromText(msg);
  const intent = classifyIntent(input);
  const tone = buildAdaptiveTone(emotion, aiSessionState.turnCount);
  const knowledgeAnswer = buildKnowledgeAnswer(input);
  const compareRequest = parseCompareRequest(input);
  const modePreset = getAiModePreset();
  const trendSignals = buildTrendSignals();
  const priorityBoard = buildPriorityBoard(snapshot, trendSignals);

  aiSessionState.turnCount += 1;
  aiSessionState.lastUserMessage = input;
  aiSessionState.userEmotion = emotion;

  const coachingMoves = buildActionCoaching(snapshot);
  const deepPlan = buildDeepPlan(snapshot);

  const stylePrefix = buildModeAwarePrefix(tone);

  if (compareRequest) {
    const comparison = buildComparisonResponse(compareRequest.left, compareRequest.right, snapshot);
    aiSessionState.lastIntent = "compare";
    aiSessionState.lastAdvice = [comparison.decisionRule];
    return {
      response: `‚öñÔ∏è <b>Comparison: ${escapeHtml(compareRequest.left)} vs ${escapeHtml(compareRequest.right)}</b><br><br><b>Summary</b>: ${comparison.summary}<br><br><b>${escapeHtml(compareRequest.left)} Pros</b><br>‚Ä¢ ${comparison.prosLeft.join("<br>‚Ä¢ ")}<br><br><b>${escapeHtml(compareRequest.right)} Pros</b><br>‚Ä¢ ${comparison.prosRight.join("<br>‚Ä¢ ")}<br><br><b>Decision Rule</b>: ${comparison.decisionRule}`,
      isHtml: true
    };
  }

  if (intent.key === "greeting") {
    const pending = snapshot.pendingTasks;
    const waterLeft = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
    aiSessionState.lastIntent = "greeting";
    return {
      response: `${greeting}, ${name}! üåü Quick status: score ${snapshot.score}/100, ${pending} pending task${pending === 1 ? "" : "s"}, ${waterLeft} glass${waterLeft === 1 ? "" : "es"} left. Want a high-performance 60-minute plan?`,
      isHtml: false
    };
  }

  if (intent.key === "smalltalk-health") {
    aiSessionState.lastIntent = "smalltalk-health";
    return {
      response: `${stylePrefix}I‚Äôm sharp and fully focused, ${name}. I‚Äôm tracking your live pattern (tasks, hydration, sleep, mood) and helping you make high-quality decisions quickly. You‚Äôre at ${snapshot.score}/100 right now.`,
      isHtml: false
    };
  }

  if (intent.key === "smalltalk-activity") {
    aiSessionState.lastIntent = "smalltalk-activity";
    return {
      response: `${stylePrefix}I‚Äôm analyzing your dashboard state in real time: tasks (${snapshot.doneTasks}/${snapshot.totalTasks}), hydration (${snapshot.waterToday}/${snapshot.todayGoal}), sleep (${snapshot.sleepToday || 0}h), and mood. I can either reason deeply or execute direct commands for you.`,
      isHtml: false
    };
  }

  if (intent.key === "identity") {
    aiSessionState.lastIntent = "identity";
    return {
      response: "I‚Äôm your NovaFix AI coach ü§ñ ‚Äî local, context-aware, memory-enabled, and action-capable. I can converse naturally, analyze your state, and execute dashboard actions instantly.",
      isHtml: false
    };
  }

  if (intent.key === "thanks") {
    aiSessionState.lastIntent = "thanks";
    return {
      response: `Always, ${name}. You‚Äôre building momentum. Next best move: ${coachingMoves[0]}`,
      isHtml: false
    };
  }

  if (intent.key === "bye") {
    aiSessionState.lastIntent = "bye";
    return {
      response: `See you soon, ${name} üëã Before you go: ${coachingMoves[0]}`,
      isHtml: false
    };
  }

  if (intent.key === "joke") {
    aiSessionState.lastIntent = "joke";
    return {
      response: "Why did the task finally get done? It stopped dating ‚Äòlater‚Äô and committed to ‚Äònow.‚Äô üòÑ",
      isHtml: false
    };
  }

  if (mathResult) {
    aiSessionState.lastIntent = "math";
    return {
      response: `üß† ${mathResult.expression} = ${mathResult.result}`,
      isHtml: false
    };
  }

  if (intent.key === "analysis") {
    const waterPct = Math.round((snapshot.waterToday / snapshot.todayGoal) * 100);
    const taskPct = snapshot.totalTasks ? Math.round((snapshot.doneTasks / snapshot.totalTasks) * 100) : 0;
    const moodText = snapshot.moodToday || "Not logged";

    let actions = [];
    if (snapshot.waterToday < snapshot.todayGoal) actions.push(`Drink ${Math.max(0, snapshot.todayGoal - snapshot.waterToday)} more glass${snapshot.todayGoal - snapshot.waterToday === 1 ? "" : "es"}.`);
    if (snapshot.sleepToday < 7) actions.push("Target 7‚Äì8 hours sleep tonight.");
    if (snapshot.pendingTasks > 0) actions.push("Finish 1 pending task in the next 25 minutes.");
    if (!snapshot.gratitudeToday) actions.push("Add one gratitude line before bed.");
    if (!snapshot.moodToday) actions.push("Log your mood to improve prediction quality.");
    while (actions.length < 3) actions.push("Keep momentum with one small healthy action now.");

    aiSessionState.lastIntent = "analysis";
    aiSessionState.lastAdvice = actions.slice(0, 3);

    return {
      response: `üìä <b>Deep Wellness Analysis</b><br>‚≠ê Score: <b>${snapshot.score}/100</b><br>üíß Water: ${snapshot.waterToday}/${snapshot.todayGoal} (${Math.max(0, waterPct)}%)<br>üí§ Sleep today: ${snapshot.sleepToday || 0} hrs<br>üßò Mood: ${moodText}<br>üìå Tasks done: ${snapshot.doneTasks}/${snapshot.totalTasks} (${taskPct}%)<br>üôè Gratitude today: ${snapshot.gratitudeToday ? "Yes" : "No"}<br><br><b>Priority ranking (smart order)</b><br>1) ${priorityBoard[0].action}<br>2) ${priorityBoard[1].action}<br>3) ${priorityBoard[2].action}<br><br><b>Best next moves</b><br>1) ${actions[0]}<br>2) ${actions[1]}<br>3) ${actions[2]}${recentContext ? `<br><br>üß† Recent context: <i>${escapeHtml(recentContext)}</i>` : ""}`,
      isHtml: true
    };
  }

  if (intent.key === "decision") {
    aiSessionState.lastIntent = "decision";
    aiSessionState.lastAdvice = priorityBoard.slice(0, 3).map((entry) => entry.action);
    return {
      response: `üß≠ <b>Best decision right now</b><br>Primary move: <b>${priorityBoard[0].action}</b><br><br><b>Why this wins</b><br>‚Ä¢ Impact score: ${priorityBoard[0].impact}<br>‚Ä¢ Urgency score: ${priorityBoard[0].urgency}<br>‚Ä¢ Trend boost: ${priorityBoard[0].trendBoost}<br><br><b>Backup moves</b><br>2) ${priorityBoard[1].action}<br>3) ${priorityBoard[2].action}`,
      isHtml: true
    };
  }

  if (intent.key === "why") {
    const reasons = buildWhySummary(snapshot, trendSignals);
    aiSessionState.lastIntent = "why";
    aiSessionState.lastAdvice = reasons;
    return {
      response: `üîç <b>Why this is your current state</b><br>‚Ä¢ ${reasons.join("<br>‚Ä¢ ")}<br><br><b>Trend signals</b><br>‚Ä¢ Mood delta: ${trendSignals.moodDelta.toFixed(2)}<br>‚Ä¢ Water delta: ${trendSignals.waterDelta.toFixed(2)}<br>‚Ä¢ Sleep delta: ${trendSignals.sleepDelta.toFixed(2)}h<br>‚Ä¢ Task delta: ${trendSignals.taskDelta.toFixed(2)} completed/day<br><br><b>Most leverage move</b>: ${priorityBoard[0].action}`,
      isHtml: true
    };
  }

  if (intent.key === "optimize") {
    aiSessionState.lastIntent = "optimize";
    aiSessionState.lastAdvice = priorityBoard.slice(0, 4).map((entry) => entry.action);
    return {
      response: `‚öôÔ∏è <b>Optimization plan (high leverage)</b><br>1) ${priorityBoard[0].action}<br>2) ${priorityBoard[1].action}<br>3) ${priorityBoard[2].action}<br>4) ${priorityBoard[3].action}<br><br><b>Execution rule</b>: finish step 1 fully before switching context.` ,
      isHtml: true
    };
  }

  if (intent.key === "plan") {
    const planItems = deepPlan;
    aiSessionState.lastIntent = "plan";
    aiSessionState.lastAdvice = planItems;
    const depthNote = modePreset.depth >= 4
      ? "<br><b>Extra layer</b>: execute step 1 immediately, then re-evaluate after 25 minutes."
      : "";
    return {
      response: `üóÇÔ∏è <b>Your 60-min execution plan</b><br>‚Ä¢ ${planItems[0]}<br>‚Ä¢ ${planItems[1]}<br>‚Ä¢ ${planItems[2]}<br>‚Ä¢ ${planItems[3]}${depthNote}<br><br><b>Command mode</b>: say <i>add task ...</i> or <i>remind me to ... in 25 min</i> and I‚Äôll execute instantly.`,
      isHtml: true
    };
  }

  if (intent.key === "followup") {
    aiSessionState.lastIntent = "followup";
    const advice = aiSessionState.lastAdvice.length ? aiSessionState.lastAdvice : coachingMoves;
    return {
      response: `Perfect. Next level plan:<br>1) ${advice[0]}<br>2) ${advice[1]}<br>3) ${advice[2]}<br><br><b>If-then guardrail</b>: if you stall for 5+ minutes, switch to this immediate move ‚Äî ${priorityBoard[0].action}<br><br>If you want execution, use direct commands and I‚Äôll run them immediately.`,
      isHtml: true
    };
  }

  if (intent.key === "stress") {
    aiSessionState.lastIntent = "stress";
    aiSessionState.lastAdvice = [
      "Do 6 rounds of 4-4-6 breathing.",
      "Drink one glass of water.",
      "Start one 10-minute micro-task."
    ];
    return {
      response: `I hear you, ${name}. Let‚Äôs use a fast reset: 6 breathing rounds (4-4-6), drink water, then do one 10-minute micro-task. Reply ‚Äústart reset‚Äù and I‚Äôll guide step-by-step.`,
      isHtml: false
    };
  }

  if (intent.key === "sleep") {
    aiSessionState.lastIntent = "sleep";
    return {
      response: `Sleep protocol: no caffeine after 2 PM, dim lights 60 min pre-bed, and no scrolling in bed. Latest logged sleep: ${snapshot.sleepToday || (sleepHistory[sleepHistory.length-1] || 0)} hrs.`,
      isHtml: false
    };
  }

  if (intent.key === "water") {
    const left = Math.max(0, snapshot.todayGoal - snapshot.waterToday);
    aiSessionState.lastIntent = "water";
    return {
      response: `Hydration check üíß You‚Äôre at ${snapshot.waterToday}/${snapshot.todayGoal}. Remaining: ${left} glass${left === 1 ? "" : "es"}. Want me to set a reminder right now?`,
      isHtml: false
    };
  }

  if (intent.key === "productivity") {
    aiSessionState.lastIntent = "productivity";
    return {
      response: `Focus mode ‚ö° Completed ${snapshot.doneTasks}/${snapshot.totalTasks}. Try: pick one pending task, 25-min timer, then 5-min break. Say ‚Äúadd task ‚Ä¶‚Äù and I‚Äôll add it instantly.`,
      isHtml: false
    };
  }

  if (intent.key === "gratitude") {
    aiSessionState.lastIntent = "gratitude";
    return {
      response: "Gratitude prompt: ‚ÄòOne small thing that made today easier was‚Ä¶‚Äô Want me to save your line now? Say: add gratitude <your text> üôè",
      isHtml: false
    };
  }

  if (intent.key === "capabilities") {
    aiSessionState.lastIntent = "capabilities";
    return {
      response: "I can chat naturally, reason over your context, compare options, remember user facts, and execute app actions. Commands: mode strict|coach|balanced|creative, remember that..., show memory, add task..., set water goal 8, log mood sad, log sleep 7, add gratitude..., remind me to ... in 20 min, list reminders, delete reminder 1, clear all reminders.",
      isHtml: false
    };
  }

  if (knowledgeAnswer) {
    aiSessionState.lastIntent = "knowledge";
    aiSessionState.lastAdvice = coachingMoves;
    return {
      response: `${stylePrefix}${knowledgeAnswer}<br><br><b>Applied to you now</b>: ${coachingMoves[0]}`,
      isHtml: true
    };
  }

  if (emotion === "low") {
    aiSessionState.lastIntent = "emotional-support";
    aiSessionState.lastAdvice = [
      "Slow breathing for 60‚Äì90 seconds.",
      "Hydrate now.",
      "Start a tiny 10-minute task."
    ];
    return {
      response: `You‚Äôre not alone, ${name}. Let‚Äôs reduce pressure: one deep breath cycle, one sip of water, one tiny win in 10 minutes. I can help you pick that tiny win now.`,
      isHtml: false
    };
  }

  if (emotion === "positive") {
    aiSessionState.lastIntent = "positive-momentum";
    return {
      response: `Love that energy, ${name} üî• Best use of momentum: ${coachingMoves[0]} Then I‚Äôll help you stack the next move.`,
      isHtml: false
    };
  }

  aiSessionState.lastIntent = "fallback";
  aiSessionState.conversationSummary = `Last topic: ${intent.key}; mood: ${emotion}; score: ${snapshot.score}`;
  const personalGoal = aiSessionState.userFacts.goal ? `<br>üéØ Your stated goal: <i>${escapeHtml(aiSessionState.userFacts.goal)}</i>` : "";

  if (modePreset.style === "ultra") {
    return {
      response: buildUltraFallback(snapshot, name),
      isHtml: true
    };
  }

  return {
    response: `üß† I got your context and here‚Äôs the best move stack now:<br>1) ${coachingMoves[0]}<br>2) ${coachingMoves[1]}<br>3) ${coachingMoves[2]}${personalGoal}<br><br>I can talk naturally or execute commands immediately.`,
    isHtml: true
  };
}

function setChatText(textNode, text, isHtml) {
  if (isHtml) textNode.innerHTML = text;
  else textNode.textContent = text;
}

function renderChatMessage(role, messageText, isHtml, chatId, fieldName) {
  clearStatusState(chat);
  const row = document.createElement("div");
  row.className = "chat-message";

  const textNode = document.createElement("div");
  textNode.className = "chat-text";
  textNode.dataset.rawText = messageText;
  setChatText(textNode, `${role === "user" ? "You" : "AI"}: ${messageText}`, isHtml);

  row.append(textNode);

  if (role === "user") {
    const editBtn = document.createElement("button");
    editBtn.className = "chat-edit-btn";
    editBtn.textContent = "Edit";
    editBtn.onclick = () => editChatMessage(chatId, fieldName, textNode, role);
    row.append(editBtn);
  }

  chat.appendChild(row);
  updateAiLimitUI();
  chat.scrollTop = chat.scrollHeight;
}

async function editChatMessage(chatId, fieldName, textNode, role) {
  const user = auth.currentUser;
  if (user) {
    await ensureAiUsageCurrent(user.uid);
    const dailyLimit = getCurrentAiDailyLimit();
    if (aiUsageCount >= dailyLimit) {
      updateAiLimitUI();
      alert(`Daily AI limit reached (${dailyLimit}/${dailyLimit}). Resets at 00:00 server time. Come back tomorrow.`);
      return;
    }
  }

  const currentText = textNode.dataset.rawText || "";
  const updatedText = prompt("Edit message", currentText);
  if (updatedText === null) return;

  const nextText = updatedText.trim();
  if (!nextText) {
    alert("Message cannot be empty.");
    return;
  }

  textNode.dataset.rawText = nextText;
  setChatText(textNode, `${role === "user" ? "You" : "AI"}: ${nextText}`, false);

  if (!user || !chatId) return;

  try {
    const snapshot = await getDocs(collection(db, "users", user.uid, "aiChats"));
    const chatEntries = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.createdAt?.toMillis?.() ?? new Date(a.createdAt || 0).getTime();
        const bTime = b.createdAt?.toMillis?.() ?? new Date(b.createdAt || 0).getTime();
        return aTime - bTime;
      });

    const editedIndex = chatEntries.findIndex((entry) => entry.id === chatId);
    if (editedIndex < 0) return;

    const smart = await buildSmartAiResponse(nextText, user);
    await updateDoc(doc(db, "users", user.uid, "aiChats", chatId), {
      userMessage: nextText,
      aiResponse: smart.response,
      aiResponseIsHtml: smart.isHtml,
      updatedAt: serverTimestamp()
    });

    const entriesAfterEdited = chatEntries.slice(editedIndex + 1);
    if (entriesAfterEdited.length) {
      await Promise.all(
        entriesAfterEdited.map((entry) =>
          deleteDoc(doc(db, "users", user.uid, "aiChats", entry.id))
        )
      );
    }

    await loadAiChats(user.uid);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function renderChatPair(entry) {
  renderChatMessage("user", entry.userMessage || "", false, entry.id, "userMessage");
  renderChatMessage("ai", entry.aiResponse || "", !!entry.aiResponseIsHtml, entry.id, "aiResponse");
}

async function loadAiChats(userId) {
  chat.innerHTML = "";
  aiRecentPrompts.length = 0;
  aiSessionState.lastIntent = "";
  aiSessionState.lastAdvice = [];
  aiSessionState.lastUserMessage = "";
  aiSessionState.conversationSummary = "";
  aiSessionState.topicHistory.length = 0;

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "aiChats"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.createdAt?.toMillis?.() ?? new Date(a.createdAt || 0).getTime();
        const bTime = b.createdAt?.toMillis?.() ?? new Date(b.createdAt || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      if (entry.userMessage) rememberPrompt(entry.userMessage);
      renderChatPair(entry);
    });
    if (!docs.length) {
      setEmptyState(chat, "No AI chats yet ‚Äî ask one question to get started.");
    }
    updateAiLimitUI();
    updateClearDataButtonState();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function storeAiChat(userId, userMessage, aiResponse, aiResponseIsHtml) {
  try {
    const ref = await addDoc(
      collection(db, "users", userId, "aiChats"),
      {
        userMessage,
        aiResponse,
        aiResponseIsHtml,
        createdAt: serverTimestamp()
      }
    );
    return ref.id;
  } catch (err) {
    notifyFirestoreError(err);
    return null;
  }
}

async function clearAiChats() {
  const user = auth.currentUser;
  if (!user) return;
  if (!confirm("Clear all AI conversations?")) return;

  try {
    const snapshot = await getDocs(collection(db, "users", user.uid, "aiChats"));
    if (!snapshot.docs.length) {
      setEmptyState(chat, "No AI chats yet ‚Äî ask one question to get started.");
      showToast("There was nothing to clear.");
      updateClearDataButtonState();
      return;
    }

    if (pendingAiClearOperation?.timerId) {
      clearTimeout(pendingAiClearOperation.timerId);
      pendingAiClearOperation = null;
    }

    const docsToDelete = snapshot.docs.map((docSnap) => ({ id: docSnap.id, ref: docSnap.ref, data: docSnap.data() }));

    chat.innerHTML = "";
    aiRecentPrompts.length = 0;
    aiSessionState.lastIntent = "";
    aiSessionState.lastAdvice = [];
    aiSessionState.lastUserMessage = "";
    aiSessionState.conversationSummary = "";
    aiSessionState.topicHistory.length = 0;

    const finalizeDelete = async () => {
      try {
        await Promise.all(docsToDelete.map((entry) => deleteDoc(entry.ref)));
      } catch (err) {
        notifyFirestoreError(err);
      }
      pendingAiClearOperation = null;
      scheduleEmptyState(chat, ".chat-message", "No AI chats yet ‚Äî ask one question to get started.");
      updateClearDataButtonState();
    };

    const timerId = setTimeout(finalizeDelete, 5000);
    pendingAiClearOperation = { timerId };

    showToast("AI chats cleared.", {
      actionLabel: "Undo",
      duration: 5000,
      onAction: async () => {
        if (pendingAiClearOperation?.timerId) clearTimeout(pendingAiClearOperation.timerId);
        pendingAiClearOperation = null;
        await loadAiChats(user.uid);
        showToast("AI chats restored.");
        updateClearDataButtonState();
      }
    });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function aiChat(){
  if (aiChatSubmitting) return;
  const input = aiInput.value.trim();
  if(!input) return;
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  aiChatSubmitting = true;
  if (aiTalkBtn) aiTalkBtn.disabled = true;

  try {
    await ensureAiUsageCurrent(user.uid);
    const dailyLimit = getCurrentAiDailyLimit();
    const quotaResult = await reserveAiQuota(user.uid, dailyLimit);
    if (!quotaResult.ok) {
      renderChatMessage("ai", "Daily AI limit reached for now. You can continue after 00:00 server time. Come back tomorrow.", false, null, null);
      updateAiLimitUI();
      aiInput.value = "";
      return;
    }

    try {
      const smart = await buildSmartAiResponse(input, user);
      const response = smart.response;
      const responseIsHtml = smart.isHtml;
      rememberPrompt(input);

      const chatId = await storeAiChat(user.uid, input, response, responseIsHtml);
      if (!chatId) {
        await rollbackAiQuota(user.uid);
        return;
      }

      renderChatPair({
        id: chatId,
        userMessage: input,
        aiResponse: response,
        aiResponseIsHtml: responseIsHtml
      });
      updateAiLimitUI();
      updateClearDataButtonState();
      aiInput.value="";
    } catch (err) {
      await rollbackAiQuota(user.uid);
      notifyFirestoreError(err);
    }
  } finally {
    aiChatSubmitting = false;
    updateAiLimitUI();
  }
}

// Reminders
function clearReminderTimer(reminderId) {
  const timerId = reminderIntervals.get(reminderId);
  if (timerId) {
    clearInterval(timerId);
    reminderIntervals.delete(reminderId);
  }
}

function clearAllReminderTimers() {
  reminderIntervals.forEach((timerId) => clearInterval(timerId));
  reminderIntervals.clear();
}

async function deleteReminderFromAi(userId, query) {
  try {
    const snapshot = await getDocs(collection(db, "users", userId, "reminders"));
    const remindersList = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => (Number(a.targetAtMs) || 0) - (Number(b.targetAtMs) || 0));

    if (!remindersList.length) {
      return { ok: false, message: "No reminders found." };
    }

    const trimmedQuery = (query || "").trim();
    let targetReminder = null;

    if (!trimmedQuery) {
      targetReminder = remindersList[0];
    } else if (/^\d+$/.test(trimmedQuery)) {
      const index = Number(trimmedQuery) - 1;
      if (index >= 0 && index < remindersList.length) {
        targetReminder = remindersList[index];
      }
    }

    if (!targetReminder && trimmedQuery) {
      const lowered = trimmedQuery.toLowerCase();
      targetReminder = remindersList.find((entry) => (entry.text || "").toLowerCase().includes(lowered));
    }

    if (!targetReminder) {
      return { ok: false, message: `No reminder matched \"${trimmedQuery}\".` };
    }

    await deleteDoc(doc(db, "users", userId, "reminders", targetReminder.id));
    clearReminderTimer(targetReminder.id);
    await loadReminders(userId);

    return { ok: true, entry: targetReminder };
  } catch (err) {
    notifyFirestoreError(err);
    return { ok: false, message: "Could not delete reminder right now." };
  }
}

function renderReminder(entry) {
  clearStatusState(reminders);
  const li = document.createElement("li");
  li.className = "item-row";

  const label = document.createElement("span");
  label.className = "item-text";
  const reminderTextValue = entry.text || "Reminder";
  const reminderMinutes = Number(entry.minutes) || 0;
  const targetAtMs = Number(entry.targetAtMs) || (getServerNowDate().getTime() + reminderMinutes * 60000);

  const actions = document.createElement("div");
  actions.className = "item-actions";

  const deleteBtn = document.createElement("button");
  deleteBtn.className = "remove-entry-btn";
  deleteBtn.textContent = "Delete";
  deleteBtn.onclick = async () => {
    const user = auth.currentUser;
    clearReminderTimer(entry.id);

    if (user && entry.id) {
      try {
        await deleteDoc(doc(db, "users", user.uid, "reminders", entry.id));
        await updateReminderLimitUI(user.uid);
      } catch (err) {
        notifyFirestoreError(err);
      }
    }
    li.remove();
    scheduleEmptyState(reminders, ".item-row", "No reminders set yet ‚Äî add one small prompt for today.");
    updateClearDataButtonState();

    if (user) {
      await updateReminderLimitUI(user.uid);
    }
  };

  const setLabelText = (secondsLeft) => {
    if (secondsLeft <= 0) {
      label.textContent = `‚Ä¢ ${reminderTextValue} ‚Äì Time's up!`;
      return;
    }
    const mins = Math.floor(secondsLeft / 60);
    const secs = secondsLeft % 60;
    label.textContent = `‚Ä¢ ${reminderTextValue} ‚Äì ${mins}m ${secs}s`;
  };

  let secondsRemaining = Math.max(0, Math.ceil((targetAtMs - getServerNowDate().getTime()) / 1000));
  setLabelText(secondsRemaining);

  if (secondsRemaining > 0) {
    const audio = document.getElementById("reminderSound");
    const timer = setInterval(() => {
      secondsRemaining -= 1;
      if (secondsRemaining <= 0) {
        clearReminderTimer(entry.id);
        setLabelText(0);
        if (audio) audio.play();
        return;
      }
      setLabelText(secondsRemaining);
    }, 1000);
    if (entry.id) reminderIntervals.set(entry.id, timer);
  }

  actions.append(deleteBtn);
  li.append(label, actions);
  reminders.appendChild(li);
}

async function loadReminders(userId) {
  reminders.innerHTML = "";
  clearAllReminderTimers();

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "reminders"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => (Number(a.targetAtMs) || 0) - (Number(b.targetAtMs) || 0));

    docs.forEach((entry) => renderReminder(entry));
    if (!docs.length) {
      setEmptyState(reminders, "No reminders set yet ‚Äî add one small prompt for today.");
    }
    await updateReminderLimitUI(userId);
    updateClearDataButtonState();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function addReminder() {
  if (reminderSubmitting) return;
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  const t = reminderText.value.trim();
  const m = +reminderMinutes.value;
  if (!t || m <= 0) return;

  if (t.length > REMINDER_MAX_TEXT_LENGTH) {
    showToast(`Reminder text is too long. Maximum is ${REMINDER_MAX_TEXT_LENGTH} characters.`);
    return;
  }

  if (m > REMINDER_MAX_MINUTES) {
    showToast(`Reminder time is too high. Maximum is ${REMINDER_MAX_MINUTES} minutes.`);
    return;
  }

  reminderSubmitting = true;
  if (reminderSetBtn) reminderSetBtn.disabled = true;

  try {
    await ensureDailyUsageCurrent(user.uid, { skipReminderRefresh: true });

    const quotaResult = await reserveDailyQuota(user.uid, "reminderCount", REMINDER_DAILY_LIMIT);
    if (!quotaResult.ok) {
      showToast(`You‚Äôve reached today‚Äôs reminder limit (${REMINDER_DAILY_LIMIT}/day). Come back tomorrow.`);
      await updateReminderLimitUI(user.uid);
      return;
    }

    const targetAtMs = getServerNowDate().getTime() + (m * 60 * 1000);

    try {
      const ref = await addDoc(collection(db, "users", user.uid, "reminders"), {
        text: t,
        minutes: m,
        targetAtMs,
        createdAt: serverTimestamp()
      });

      renderReminder({ id: ref.id, text: t, minutes: m, targetAtMs });
      reminderText.value = "";
      reminderMinutes.value = "";
      showToast(`Reminder set. ${getRandomCheer()}`);
      await trimCollectionToMaxEntries(user.uid, "reminders", MAX_REMINDER_ENTRIES, (entry) => {
        return Number(entry.targetAtMs) || toDateSafe(entry.createdAt)?.getTime?.() || 0;
      });
      await updateReminderLimitUI(user.uid);
      updateClearDataButtonState();
    } catch (err) {
      await rollbackDailyQuota(user.uid, "reminderCount");
      notifyFirestoreError(err);
    }
  } finally {
    reminderSubmitting = false;
    await updateReminderLimitUI(user.uid);
  }
}

// Tasks
function renderTask(entry) {
  clearStatusState(taskList);
  const li = document.createElement("li");
  li.className = "item-row";
  const span = document.createElement("span");
  span.className = "item-text";
  span.textContent = entry.text;
  if (entry.completed) span.classList.add("task-done");

  const actions = document.createElement("div");
  actions.className = "item-actions";

  const toggleBtn = document.createElement("button");
  toggleBtn.textContent = entry.completed ? "‚úÖ" : "‚¨ú";
  toggleBtn.title = "Toggle complete";
  toggleBtn.onclick = async () => {
    entry.completed = !entry.completed;
    entry.completedAt = entry.completed ? getServerNowDate() : null;
    span.classList.toggle("task-done", entry.completed);
    toggleBtn.textContent = entry.completed ? "‚úÖ" : "‚¨ú";

    const listIndex = taskEntries.findIndex((taskItem) => taskItem.id === entry.id);
    if (listIndex >= 0) {
      taskEntries[listIndex].completed = entry.completed;
      taskEntries[listIndex].completedAt = entry.completedAt;
    }
    updateInsights();

    const user = auth.currentUser;
    if (!user || !entry.id) return;
    try {
      await updateDoc(doc(db, "users", user.uid, "tasks", entry.id), {
        completed: entry.completed,
        completedAt: entry.completed ? serverTimestamp() : null
      });
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  const editBtn = document.createElement("button");
  editBtn.textContent = "‚úèÔ∏è";
  editBtn.onclick = async () => {
    const newText = prompt("Edit task", span.textContent);
    if (!newText || !newText.trim()) return;
    span.textContent = newText.trim();

    const user = auth.currentUser;
    if (!user || !entry.id) return;
    try {
      await updateDoc(doc(db, "users", user.uid, "tasks", entry.id), { text: newText.trim() });
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  const deleteBtn = document.createElement("button");
  deleteBtn.classList.add("remove-entry-btn");
  deleteBtn.textContent = "üóëÔ∏è";
  deleteBtn.onclick = async () => {
    const user = auth.currentUser;
    if (!user || !entry.id) {
      const fallbackIndex = taskEntries.findIndex((taskItem) => taskItem.id === entry.id);
      if (fallbackIndex >= 0) taskEntries.splice(fallbackIndex, 1);
      updateInsights();
      updateTaskLimitUI();
      li.remove();
      scheduleEmptyState(taskList, ".item-row", "No tasks yet ‚Äî add one quick win to begin.");
      return;
    }
    try {
      await deleteDoc(doc(db, "users", user.uid, "tasks", entry.id));
      const listIndex = taskEntries.findIndex((taskItem) => taskItem.id === entry.id);
      if (listIndex >= 0) taskEntries.splice(listIndex, 1);
      updateInsights();
      updateTaskLimitUI();
      li.remove();
      scheduleEmptyState(taskList, ".item-row", "No tasks yet ‚Äî add one quick win to begin.");
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  actions.append(toggleBtn, editBtn, deleteBtn);
  li.append(span, actions);
  taskList.appendChild(li);
}

async function loadTasks(userId) {
  taskList.innerHTML = "";
  taskEntries.length = 0;
  try {
    const snapshot = await getDocs(collection(db, "users", userId, "tasks"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });
    docs.forEach((entry) => {
      const normalized = {
        ...entry,
        completed: !!entry.completed,
        completedAt: toDateSafe(entry.completedAt)
      };
      taskEntries.push(normalized);
      renderTask(normalized);
    });
    if (!docs.length) {
      setEmptyState(taskList, "No tasks yet ‚Äî add one quick win to begin.");
    }
    updateTaskLimitUI();
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function addTask(){
  if (taskSubmitting) return;
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  const t=task.value.trim();
  if(!t)return;

  taskSubmitting = true;
  if (taskAddBtn) taskAddBtn.disabled = true;

  try {
    await ensureDailyUsageCurrent(user.uid, { skipReminderRefresh: true });

    const quotaResult = await reserveDailyQuota(user.uid, "taskCount", TASK_DAILY_LIMIT);
    if (!quotaResult.ok) {
      showToast(`You‚Äôve reached today‚Äôs task limit (${TASK_DAILY_LIMIT}/day). Come back tomorrow.`);
      updateTaskLimitUI();
      return;
    }

    try {
      const ref = await addDoc(collection(db, "users", user.uid, "tasks"), {
        text: t,
        completed: false,
        completedAt: null,
        time: serverTimestamp()
      });
      const newTask = { id: ref.id, text: t, completed: false, completedAt: null, time: getServerNowDate() };
      taskEntries.push(newTask);
      renderTask(newTask);
      showToast(`Task added. ${getRandomCheer()}`);
      updateInsights();
      task.value="";
      await trimCollectionToMaxEntries(user.uid, "tasks", MAX_TASK_ENTRIES, (entry) => toDateSafe(entry.time)?.getTime?.() || 0);
      updateTaskLimitUI();
    } catch (err) {
      await rollbackDailyQuota(user.uid, "taskCount");
      notifyFirestoreError(err);
    }
  } finally {
    taskSubmitting = false;
    updateTaskLimitUI();
  }
}

// Finance
function calculateFinance(){
  const cost = parseFloat(gCost.value) || 0;
  const months = parseFloat(gMonths.value) || 1;
  const buf = parseFloat(buffer.value) || 0;

  const total = cost * months * (1 + buf/100);
  const monthly = total / months;

  financeResult.innerText = `Total: ‚Çπ${total.toFixed(0)} | Monthly: ‚Çπ${monthly.toFixed(0)}`;
}

// Mood
function renderMoodLog(entry) {
  clearStatusState(moodLogs);
  const moodRow = document.createElement("div");
  moodRow.className = "mood-item";

  const moodLabel = document.createElement("span");
  const rawTime = entry.time?.toDate?.() ?? new Date(entry.time || getServerNowDate().getTime());
  moodLabel.textContent = `${rawTime.toLocaleTimeString()} - ${entry.mood}`;

  const removeBtn = document.createElement("button");
  removeBtn.className = "mood-remove remove-entry-btn";
  removeBtn.textContent = "Remove";
  removeBtn.onclick = () => deleteMoodLog(entry.id, moodRow, entry.mood);

  moodRow.append(moodLabel, removeBtn);
  moodLogs.appendChild(moodRow);
}

async function deleteMoodLog(moodId, moodElement, moodValue) {
  const user = auth.currentUser;
  if (!user || !moodId) return;

  try {
    await deleteDoc(doc(db, "users", user.uid, "moods", moodId));
    moodElement.remove();
    const moodIndex = moodHistory.findIndex((m) => m === moodValue);
    if (moodIndex >= 0) moodHistory.splice(moodIndex, 1);
    updateMoodLimitUI();
    scheduleEmptyState(moodLogs, ".mood-item", "No mood logs yet ‚Äî one check-in is enough to start.");
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadMoods(userId) {
  moodLogs.innerHTML = "";
  moodHistory.length = 0;
  moodDates.length = 0;

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "moods"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      moodHistory.push(entry.mood);
      const moodTime = entry.time?.toDate?.() ?? new Date(entry.time || getServerNowDate().getTime());
      moodDates.push(moodTime);
      renderMoodLog(entry);
    });
    if (!docs.length) {
      setEmptyState(moodLogs, "No mood logs yet ‚Äî one check-in is enough to start.");
    }
    updateMoodLimitUI();
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveMood() {
  if (moodSubmitting) return;
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  const moodValue = String(mood?.value || "").trim();
  if (!moodValue) {
    showToast("Please select a mood first.");
    return;
  }

  moodSubmitting = true;
  if (moodSaveBtn) moodSaveBtn.disabled = true;

  try {
    await ensureDailyUsageCurrent(user.uid, { skipReminderRefresh: true });

    const quotaResult = await reserveDailyQuota(user.uid, "moodCount", MOOD_DAILY_LIMIT);
    if (!quotaResult.ok) {
      showToast(`You‚Äôve reached today‚Äôs mood log limit (${MOOD_DAILY_LIMIT}/day). Come back tomorrow.`);
      updateMoodLimitUI();
      return;
    }

    try {
      const moodRef = await addDoc(
        collection(db, "users", user.uid, "moods"),
        {
          mood: moodValue,
          uid: user.uid,
          email: user.email || null,
          time: serverTimestamp()
        }
      );

      moodHistory.push(moodValue);
      moodDates.push(getServerNowDate());
      renderMoodLog({ id: moodRef.id, mood: moodValue, time: getServerNowDate() });
      showToast(`Mood saved. ${getRandomCheer()}`);
      updateInsights();
      await trimCollectionToMaxEntries(user.uid, "moods", MAX_MOOD_ENTRIES, (entry) => toDateSafe(entry.time)?.getTime?.() || 0);
      updateMoodLimitUI();
    } catch (err) {
      await rollbackDailyQuota(user.uid, "moodCount");
      notifyFirestoreError(err);
    }
  } finally {
    moodSubmitting = false;
    updateMoodLimitUI();
  }
}

// Water
let waterGoal=0;
function updateWaterProgress() {
  const todayKey = getTodayKey();
  let latestTodayValue = 0;
  for (let index = waterHistory.length - 1; index >= 0; index -= 1) {
    const dateKey = dateToKey(waterDates[index]);
    if (dateKey === todayKey) {
      latestTodayValue = Number(waterHistory[index]) || 0;
      break;
    }
  }
  const percent = waterGoal > 0 ? Math.round((latestTodayValue / waterGoal) * 100) : 0;
  waterProgress.innerText = `${latestTodayValue}/${waterGoal} (${percent}%)`;
  updateWaterClearButtonState();
  updateInsights();
}

function updateWaterClearButtonState() {
  if (!waterClearBtn) return;
  const hasWaterLogs = waterHistory.length > 0 || waterDates.length > 0;
  const hasGoal = (Number(waterGoal) || 0) > 0;
  waterClearBtn.disabled = !(hasWaterLogs || hasGoal);
}

async function setWaterGoal(){
  const user = auth.currentUser;
  waterGoal = +waterGoalInput.value || 0;
  updateWaterProgress();

  if (waterGoal > 0) {
    alert(`‚úÖ Water goal set to ${waterGoal} glasses.`);
  } else {
    alert("‚ÑπÔ∏è Water goal cleared.");
  }

  if (!user) return;
  try {
    const todayKey = getTodayKey();
    await setDoc(doc(db, "users", user.uid, "settings", "water"), {
      goal: waterGoal,
      goalDateKey: todayKey,
      lastResetDateKey: todayKey
    }, { merge: true });
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadWaterData(userId) {
  waterHistory.length = 0;
  waterDates.length = 0;

  try {
    const todayKey = getTodayKey();
    let shouldResetDayData = false;
    const waterSettings = await getDoc(doc(db, "users", userId, "settings", "water"));
    if (waterSettings.exists()) {
      const settings = waterSettings.data();
      const savedGoal = Number(settings.goal) || 0;
      const goalDateKey = settings.goalDateKey || null;
      const lastResetDateKey = settings.lastResetDateKey || null;

      if (lastResetDateKey && lastResetDateKey !== todayKey) {
        shouldResetDayData = true;
      } else if (!lastResetDateKey) {
        await setDoc(doc(db, "users", userId, "settings", "water"), {
          lastResetDateKey: todayKey
        }, { merge: true });
      }

      if (!shouldResetDayData && savedGoal > 0 && goalDateKey && goalDateKey !== todayKey) {
        shouldResetDayData = true;
      }

      if (shouldResetDayData) {
        await resetWaterDayData(userId, todayKey);
        waterGoal = 0;
      } else {
        waterGoal = savedGoal;
      }
    } else {
      waterGoal = 0;
      await setDoc(doc(db, "users", userId, "settings", "water"), {
        goal: 0,
        goalDateKey: todayKey,
        lastResetDateKey: todayKey
      }, { merge: true });
    }
    waterGoalInput.value = waterGoal || "";

    const snapshot = await getDocs(collection(db, "users", userId, "waterIntake"));
    const docs = snapshot.docs
      .map((docSnap) => docSnap.data())
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      if (entry.glasses) {
        waterHistory.push(entry.glasses);
        const waterTime = entry.time?.toDate?.() ?? new Date(entry.time || getServerNowDate().getTime());
        waterDates.push(waterTime);
      }
    });

    updateWaterLimitUI();
    updateWaterProgress();
    updateWaterClearButtonState();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveWater() {
  if (waterSubmitting) return;
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  const v = +waterInput.value;
  if (!v) return; // ignore empty or 0 input
  if (v > WATER_MAX_GLASSES_PER_ENTRY) {
    showToast(`You can log a maximum of ${WATER_MAX_GLASSES_PER_ENTRY} glasses at once.`);
    return;
  }

  waterSubmitting = true;
  if (waterTrackBtn) waterTrackBtn.disabled = true;

  try {
    await ensureDailyUsageCurrent(user.uid, { skipReminderRefresh: true });

    const quotaResult = await reserveDailyQuota(user.uid, "waterCount", WATER_DAILY_LIMIT);
    if (!quotaResult.ok) {
      showToast(`You‚Äôve reached today‚Äôs water log limit (${WATER_DAILY_LIMIT}/day). Come back tomorrow.`);
      updateWaterLimitUI();
      return;
    }

    waterHistory.push(v);

    try {
      await addDoc(collection(db, "users", user.uid, "waterIntake"), {
        glasses: v,
        time: serverTimestamp()
      });
      waterDates.push(getServerNowDate());
      updateWaterProgress();
      waterInput.value = "";
      showToast(`Water logged. ${getRandomCheer()}`);
      await trimCollectionToMaxEntries(user.uid, "waterIntake", MAX_WATER_ENTRIES, (entry) => toDateSafe(entry.time)?.getTime?.() || 0);
      updateWaterLimitUI();
    } catch (err) {
      waterHistory.pop();
      await rollbackDailyQuota(user.uid, "waterCount");
      notifyFirestoreError(err);
    }
  } finally {
    waterSubmitting = false;
    updateWaterLimitUI();
  }
}

async function clearWaterData() {
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  const confirmed = confirm("Clear your current water intake and goal?");
  if (!confirmed) return;

  if (pendingWaterClearOperation?.timerId) {
    clearTimeout(pendingWaterClearOperation.timerId);
    pendingWaterClearOperation = null;
  }

  const previousHistory = [...waterHistory];
  const previousDates = [...waterDates];
  const previousGoal = Number(waterGoal) || 0;

  waterHistory.length = 0;
  waterDates.length = 0;
  waterGoal = 0;
  waterGoalInput.value = "";
  waterInput.value = "";
  updateWaterProgress();
  updateWaterLimitUI();
  updateWaterClearButtonState();

  const finalizeDelete = async () => {
    try {
      const intakeSnapshot = await getDocs(collection(db, "users", user.uid, "waterIntake"));
      await Promise.all(intakeSnapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
      await setDoc(doc(db, "users", user.uid, "settings", "water"), {
        goal: 0,
        goalDateKey: getTodayKey(),
        lastResetDateKey: getTodayKey()
      }, { merge: true });
    } catch (err) {
      notifyFirestoreError(err);
    }
    pendingWaterClearOperation = null;
  };

  pendingWaterClearOperation = {
    timerId: setTimeout(finalizeDelete, 5000)
  };

  showToast("Water data cleared.", {
    actionLabel: "Undo",
    duration: 5000,
    onAction: async () => {
      if (pendingWaterClearOperation?.timerId) clearTimeout(pendingWaterClearOperation.timerId);
      pendingWaterClearOperation = null;

      waterHistory.length = 0;
      waterDates.length = 0;
      previousHistory.forEach((value) => waterHistory.push(value));
      previousDates.forEach((value) => waterDates.push(value));
      waterGoal = previousGoal;
      waterGoalInput.value = previousGoal ? String(previousGoal) : "";
      waterInput.value = "";
      updateWaterProgress();
      updateWaterLimitUI();
      updateWaterClearButtonState();

      if (previousHistory.length) {
        try {
          const intakeSnapshot = await getDocs(collection(db, "users", user.uid, "waterIntake"));
          await Promise.all(intakeSnapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
          for (let i = 0; i < previousHistory.length; i += 1) {
            await addDoc(collection(db, "users", user.uid, "waterIntake"), {
              glasses: Number(previousHistory[i]) || 0,
              time: previousDates[i] || getServerNowDate()
            });
          }
          await setDoc(doc(db, "users", user.uid, "settings", "water"), {
            goal: previousGoal,
            goalDateKey: getTodayKey(),
            lastResetDateKey: getTodayKey()
          }, { merge: true });
        } catch (err) {
          notifyFirestoreError(err);
        }
      }

      showToast("Water data restored.");
    }
  });
}

// Sleep
async function loadSleepData(userId) {
  sleepHistory.length = 0;
  sleepDates.length = 0;
  sleepResult.innerText = "";

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "sleepLogs"));
    const docs = snapshot.docs
      .map((docSnap) => docSnap.data())
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      if (entry.hours) {
        sleepHistory.push(entry.hours);
        const sleepTime = entry.time?.toDate?.() ?? new Date(entry.time || getServerNowDate().getTime());
        sleepDates.push(sleepTime);
      }
    });

    if (sleepHistory.length) {
      const latest = sleepHistory[sleepHistory.length - 1];
      sleepResult.innerText = `${latest} hrs üí§`;
    }
    updateSleepLimitUI();
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveSleep(){
  if (sleepSubmitting) return;
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  const hours = +sleepInput.value;
  if (!hours) return;

  sleepSubmitting = true;
  if (sleepSaveBtn) sleepSaveBtn.disabled = true;

  try {
    await ensureDailyUsageCurrent(user.uid, { skipReminderRefresh: true });

    const quotaResult = await reserveDailyQuota(user.uid, "sleepCount", SLEEP_DAILY_LIMIT);
    if (!quotaResult.ok) {
      showToast(`You‚Äôve reached today‚Äôs sleep log limit (${SLEEP_DAILY_LIMIT}/day). Come back tomorrow.`);
      updateSleepLimitUI();
      return;
    }

    sleepHistory.push(hours);
    sleepDates.push(getServerNowDate());
    sleepResult.innerText = `${hours} hrs üí§`;
    updateInsights();

    try {
      await addDoc(collection(db, "users", user.uid, "sleepLogs"), {
        hours,
        time: serverTimestamp()
      });
      sleepInput.value = "";
      showToast(`Sleep logged. ${getRandomCheer()}`);
      await trimCollectionToMaxEntries(user.uid, "sleepLogs", MAX_SLEEP_ENTRIES, (entry) => toDateSafe(entry.time)?.getTime?.() || 0);
      updateSleepLimitUI();
    } catch (err) {
      sleepHistory.pop();
      sleepDates.pop();
      await rollbackDailyQuota(user.uid, "sleepCount");
      notifyFirestoreError(err);
    }
  } finally {
    sleepSubmitting = false;
    updateSleepLimitUI();
  }
}

// Time Mirror
function timeTraveller() {
  const goalText = futureTask.value.trim();
  if (!goalText) {
    showToast("Enter a goal to preview your future outcome.");
    return;
  }

  const snapshot = getWellnessSnapshot();
  const lower = goalText.toLowerCase();

  const goalType =
    /study|exam|learn|course|revision|assignment/.test(lower) ? "learning" :
    /workout|gym|run|fitness|exercise|walk/.test(lower) ? "fitness" :
    /project|build|launch|startup|business|client|career/.test(lower) ? "career" :
    /sleep|rest|bed|wake/.test(lower) ? "recovery" :
    /water|hydrate|hydration/.test(lower) ? "hydration" :
    "general";

  const energyState = snapshot.sleepToday >= 7 ? "steady" : "low";
  const focusState = snapshot.pendingTasks <= 2 ? "clear" : "crowded";
  const hydrationLeft = Math.max(0, snapshot.todayGoal - snapshot.waterToday);

  const typeBoost = {
    learning: "your understanding compounds and recall becomes faster",
    fitness: "your energy improves and stress load drops noticeably",
    career: "your momentum builds and confidence in execution rises",
    recovery: "your nervous system settles and tomorrow starts stronger",
    hydration: "your focus gets sharper and fatigue drops in the next few hours",
    general: "your consistency grows and your confidence rises"
  };

  const skipCost = {
    learning: "you carry cognitive friction and last-minute pressure",
    fitness: "stress stays high and motivation weakens tomorrow",
    career: "momentum stalls and the task feels heavier later",
    recovery: "fatigue compounds and tomorrow starts with lower focus",
    hydration: "mental clarity dips and energy feels flat",
    general: "the task becomes heavier emotionally and mentally"
  };

  const firstStep =
    goalType === "learning" ? "Open your notes and do a 15-minute focused sprint." :
    goalType === "fitness" ? "Do a 5-minute warm-up and start the first set." :
    goalType === "career" ? "Break this into one shippable 20-minute action." :
    goalType === "recovery" ? "Set a wind-down alarm and reduce screen/light now." :
    goalType === "hydration" ? "Drink one glass now, then set a 30-minute follow-up." :
    "Do one 10-minute starter action right now.";

  const readinessHint = `${energyState === "steady" ? "Energy is on your side" : "Energy is low, so start tiny"} ‚Ä¢ ${focusState === "clear" ? "task load is manageable" : "task load is crowded"}${hydrationLeft > 0 ? ` ‚Ä¢ ${hydrationLeft} glass(es) hydration gap` : ""}`;

  timeMirror.innerHTML = `
    <p>‚ú® <b>Future if you do "${escapeHtml(goalText)}"</b><br>
    In 24 hours: ${typeBoost[goalType]}, and your self-trust strengthens. üí™</p>
    <p>‚è≥ <b>Future if you delay it</b><br>
    In 24 hours: ${skipCost[goalType]}, and starting feels harder than it is now. üòî</p>
    <p>üß≠ <b>Best first step</b><br>${firstStep}</p>
    <p>üìå <small>${readinessHint}</small></p>
  `;

  futureTask.value = "";
}

// Quotes
const quotes=["üå± 'The journey of a thousand miles begins with one step.' ‚Äì Lao Tzu","üí™ 'Your body can stand almost anything. It‚Äôs your mind that you have to convince.'","‚òÄÔ∏è 'Every morning we are born again. What we do today matters most.' ‚Äì Buddha","üåü 'Success is the sum of small efforts repeated day in and day out.' ‚Äì Robert Collier","üßò 'Happiness is not something ready-made. It comes from your own actions.' ‚Äì Dalai Lama","üî• 'Don‚Äôt watch the clock; do what it does. Keep going.' ‚Äì Sam Levenson"];
function newQuote(){quoteDisplay.innerText=quotes[Math.floor(Math.random()*quotes.length)];}
newQuote();

// Gratitude
function renderGratitude(entry) {
  clearStatusState(gratitudeLogs);
  const row = document.createElement("div");
  row.className = "item-row";
  const rawTime = entry.time?.toDate?.() ?? new Date(entry.time || getServerNowDate().getTime());

  const label = document.createElement("span");
  label.className = "item-text";
  label.textContent = `${rawTime.toLocaleTimeString()} - ${entry.text}`;

  const actions = document.createElement("div");
  actions.className = "item-actions";

  const editBtn = document.createElement("button");
  editBtn.textContent = "‚úèÔ∏è";
  editBtn.onclick = async () => {
    const nextText = prompt("Edit gratitude", entry.text || "");
    if (!nextText || !nextText.trim()) return;

    const user = auth.currentUser;
    if (!user || !entry.id) return;

    try {
      await updateDoc(doc(db, "users", user.uid, "gratitudeLogs", entry.id), {
        text: nextText.trim()
      });
      entry.text = nextText.trim();
      label.textContent = `${rawTime.toLocaleTimeString()} - ${entry.text}`;
      const listIndex = gratitudeEntries.findIndex((item) => item.id === entry.id);
      if (listIndex >= 0) gratitudeEntries[listIndex].text = entry.text;
      updateInsights();
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  const deleteBtn = document.createElement("button");
  deleteBtn.classList.add("remove-entry-btn");
  deleteBtn.textContent = "üóëÔ∏è";
  deleteBtn.onclick = async () => {
    const user = auth.currentUser;
    if (!user || !entry.id) {
      const fallbackIndex = gratitudeEntries.findIndex((item) => item.id === entry.id);
      if (fallbackIndex >= 0) gratitudeEntries.splice(fallbackIndex, 1);
      updateInsights();
      row.remove();
      scheduleEmptyState(gratitudeLogs, ".item-row", "No gratitude notes yet ‚Äî add one small win from today.");
      return;
    }

    try {
      await deleteDoc(doc(db, "users", user.uid, "gratitudeLogs", entry.id));
      const listIndex = gratitudeEntries.findIndex((item) => item.id === entry.id);
      if (listIndex >= 0) gratitudeEntries.splice(listIndex, 1);
      updateInsights();
      updateGratitudeLimitUI();
      row.remove();
      scheduleEmptyState(gratitudeLogs, ".item-row", "No gratitude notes yet ‚Äî add one small win from today.");
    } catch (err) {
      notifyFirestoreError(err);
    }
  };

  actions.append(editBtn, deleteBtn);
  row.append(label, actions);
  gratitudeLogs.appendChild(row);
}

async function loadGratitude(userId) {
  gratitudeLogs.innerHTML = "";
  gratitudeEntries.length = 0;

  try {
    const snapshot = await getDocs(collection(db, "users", userId, "gratitudeLogs"));
    const docs = snapshot.docs
      .map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
      .sort((a, b) => {
        const aTime = a.time?.toMillis?.() ?? new Date(a.time || 0).getTime();
        const bTime = b.time?.toMillis?.() ?? new Date(b.time || 0).getTime();
        return aTime - bTime;
      });

    docs.forEach((entry) => {
      gratitudeEntries.push(entry);
      renderGratitude(entry);
    });
    if (!docs.length) {
      setEmptyState(gratitudeLogs, "No gratitude notes yet ‚Äî add one small win from today.");
    }
    updateGratitudeLimitUI();
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function saveGratitude(){
  if (gratitudeSubmitting) return;
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }

  const t=gratitudeInput.value.trim();
  if(!t)return;

  gratitudeSubmitting = true;
  if (gratitudeSaveBtn) gratitudeSaveBtn.disabled = true;

  try {
    await ensureDailyUsageCurrent(user.uid);

    const quotaResult = await reserveDailyQuota(user.uid, "gratitudeCount", GRATITUDE_DAILY_LIMIT);
    if (!quotaResult.ok) {
      showToast(`You‚Äôve reached today‚Äôs gratitude limit (${GRATITUDE_DAILY_LIMIT}/day). Come back tomorrow.`);
      updateGratitudeLimitUI();
      return;
    }

    try {
      const ref = await addDoc(collection(db, "users", user.uid, "gratitudeLogs"), {
        text: t,
        time: serverTimestamp()
      });
      const entry = { id: ref.id, text: t, time: getServerNowDate() };
      gratitudeEntries.push(entry);
      renderGratitude(entry);
      showToast(`Gratitude saved. ${getRandomCheer()}`);
      updateInsights();
      gratitudeInput.value="";
      await trimCollectionToMaxEntries(user.uid, "gratitudeLogs", MAX_GRATITUDE_ENTRIES, (entryItem) => toDateSafe(entryItem.time)?.getTime?.() || 0);
      updateGratitudeLimitUI();
    } catch (err) {
        await rollbackDailyQuota(user.uid, "gratitudeCount");
      notifyFirestoreError(err);
    }
  } finally {
    gratitudeSubmitting = false;
    updateGratitudeLimitUI();
  }
}

async function exportAllData() {
  const user = auth.currentUser;
  if (!user) {
    alert("Please sign in first.");
    return;
  }

  try {
    const waterSettingsSnap = await getDoc(doc(db, "users", user.uid, "settings", "water"));
    const dailyChallengeSnap = await getDoc(doc(db, "users", user.uid, "settings", "dailyChallenge"));
    const weeklyTargetsSnap = await getDoc(doc(db, "users", user.uid, "settings", "weeklyTargets"));
    const habitQuestSnap = await getDoc(doc(db, "users", user.uid, "settings", "habitQuest"));
    const insightsSnap = await getDoc(doc(db, "users", user.uid, "insights", "current"));
    const insightsBarGraphsSnap = await getDoc(doc(db, "users", user.uid, "insights", "barGraphs"));
    const [
      moodsSnap,
      tasksSnap,
      waterSnap,
      sleepSnap,
      gratitudeSnap,
      aiSnap,
      challengeHistorySnap,
      rescueEventsSnap
    ] = await Promise.all([
      getDocs(collection(db, "users", user.uid, "moods")),
      getDocs(collection(db, "users", user.uid, "tasks")),
      getDocs(collection(db, "users", user.uid, "waterIntake")),
      getDocs(collection(db, "users", user.uid, "sleepLogs")),
      getDocs(collection(db, "users", user.uid, "gratitudeLogs")),
      getDocs(collection(db, "users", user.uid, "aiChats")),
      getDocs(collection(db, "users", user.uid, "challengeHistory")),
      getDocs(collection(db, "users", user.uid, "rescueEvents"))
    ]);

    const toExport = {
      exportedAt: getServerNowDate().toISOString(),
      user: {
        uid: user.uid,
        email: user.email || null,
        name: user.displayName || null
      },
      waterSettings: waterSettingsSnap.exists() ? waterSettingsSnap.data() : null,
      dailyChallengeSettings: dailyChallengeSnap.exists() ? dailyChallengeSnap.data() : null,
      weeklyTargets: weeklyTargetsSnap.exists() ? weeklyTargetsSnap.data() : null,
      habitQuest: habitQuestSnap.exists() ? habitQuestSnap.data() : null,
      insightsCurrent: insightsSnap.exists() ? insightsSnap.data() : null,
      insightsBarGraphs: insightsBarGraphsSnap.exists() ? insightsBarGraphsSnap.data() : null,
      moods: moodsSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      tasks: tasksSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      waterIntake: waterSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      sleepLogs: sleepSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      gratitudeLogs: gratitudeSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      aiChats: aiSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      challengeHistory: challengeHistorySnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() })),
      rescueEvents: rescueEventsSnap.docs.map((docSnap) => ({ id: docSnap.id, ...docSnap.data() }))
    };

    const blob = new Blob([JSON.stringify(toExport, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `novafix-export-${getServerNowDate().toISOString().slice(0, 10)}.json`;
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
  } catch (err) {
    notifyFirestoreError(err);
  }
}

function normalizeExportTime(value) {
  if (!value) return getServerNowDate();

  if (typeof value === "string" || typeof value === "number") {
    const asDate = new Date(value);
    if (!Number.isNaN(asDate.getTime())) return asDate;
  }

  if (typeof value === "object") {
    if (typeof value.seconds === "number") {
      return new Date((value.seconds * 1000) + Math.floor((value.nanoseconds || 0) / 1e6));
    }
    if (typeof value._seconds === "number") {
      return new Date((value._seconds * 1000) + Math.floor((value._nanoseconds || 0) / 1e6));
    }
  }

  const fallback = new Date(value);
  if (!Number.isNaN(fallback.getTime())) return fallback;
  return getServerNowDate();
}

function startImportData() {
  const user = auth.currentUser;
  if (!user) {
    showToast("Please sign in first.");
    return;
  }
  if (importFileInput) importFileInput.click();
}

async function clearUserCollection(userId, collectionName) {
  const snapshot = await getDocs(collection(db, "users", userId, collectionName));
  await Promise.all(snapshot.docs.map((docSnap) => deleteDoc(docSnap.ref)));
}

async function importDataFileChange(event) {
  const user = auth.currentUser;
  const selectedFile = event?.target?.files?.[0];

  if (!user || !selectedFile) return;

  const confirmed = confirm("Warning: current data will be destroyed and new data will be imported. Continue?");
  if (!confirmed) {
    event.target.value = "";
    return;
  }

  try {
    const rawText = await selectedFile.text();
    const payload = JSON.parse(rawText);

    const targetCollections = ["moods", "tasks", "waterIntake", "sleepLogs", "gratitudeLogs", "aiChats", "challengeHistory", "rescueEvents"];
    await Promise.all(targetCollections.map((name) => clearUserCollection(user.uid, name)));
    await deleteDoc(doc(db, "users", user.uid, "settings", "water")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "dailyChallenge")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "weeklyTargets")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "settings", "habitQuest")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "insights", "current")).catch(() => {});
    await deleteDoc(doc(db, "users", user.uid, "insights", "barGraphs")).catch(() => {});
    persistedBarGraphs = null;

    const moods = Array.isArray(payload.moods) ? payload.moods : [];
    const tasks = Array.isArray(payload.tasks) ? payload.tasks : [];
    const waterIntake = Array.isArray(payload.waterIntake) ? payload.waterIntake : [];
    const sleepLogs = Array.isArray(payload.sleepLogs) ? payload.sleepLogs : [];
    const gratitudeLogs = Array.isArray(payload.gratitudeLogs) ? payload.gratitudeLogs : [];
    const aiChats = Array.isArray(payload.aiChats) ? payload.aiChats : [];
    const challengeHistory = Array.isArray(payload.challengeHistory) ? payload.challengeHistory : [];
    const rescueEventsPayload = Array.isArray(payload.rescueEvents) ? payload.rescueEvents : [];

    await Promise.all(moods.map((entry) => addDoc(collection(db, "users", user.uid, "moods"), {
      mood: entry.mood || "",
      uid: user.uid,
      email: user.email || null,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(tasks.map((entry) => addDoc(collection(db, "users", user.uid, "tasks"), {
      text: entry.text || "",
      completed: !!entry.completed,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(waterIntake.map((entry) => addDoc(collection(db, "users", user.uid, "waterIntake"), {
      glasses: Number(entry.glasses) || 0,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(sleepLogs.map((entry) => addDoc(collection(db, "users", user.uid, "sleepLogs"), {
      hours: Number(entry.hours) || 0,
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(gratitudeLogs.map((entry) => addDoc(collection(db, "users", user.uid, "gratitudeLogs"), {
      text: entry.text || "",
      time: normalizeExportTime(entry.time)
    })));

    await Promise.all(aiChats.map((entry) => addDoc(collection(db, "users", user.uid, "aiChats"), {
      userMessage: entry.userMessage || "",
      aiResponse: entry.aiResponse || "",
      aiResponseIsHtml: !!entry.aiResponseIsHtml,
      createdAt: normalizeExportTime(entry.createdAt)
    })));

    await Promise.all(challengeHistory.map((entry) => {
      const dateKey = entry.dateKey || (typeof entry.id === "string" ? entry.id : "");
      if (!dateKey) return Promise.resolve();
      return setDoc(doc(db, "users", user.uid, "challengeHistory", dateKey), {
        completed: !!entry.completed,
        challenge: entry.challenge || "",
        dateKey,
        updatedAt: normalizeExportTime(entry.updatedAt || entry.time)
      }, { merge: true });
    }));

    await Promise.all(rescueEventsPayload.map((entry) => addDoc(collection(db, "users", user.uid, "rescueEvents"), {
      level: entry.level || "",
      reason: entry.reason || "",
      time: normalizeExportTime(entry.time || entry.createdAt || entry.updatedAt)
    })));

    if (payload.waterSettings && typeof payload.waterSettings.goal !== "undefined") {
      await setDoc(doc(db, "users", user.uid, "settings", "water"), {
        goal: Number(payload.waterSettings.goal) || 0
      }, { merge: true });
    }

    if (payload.dailyChallengeSettings) {
      await setDoc(doc(db, "users", user.uid, "settings", "dailyChallenge"), {
        challenge: payload.dailyChallengeSettings.challenge || "",
        completed: !!payload.dailyChallengeSettings.completed,
        dateKey: payload.dailyChallengeSettings.dateKey || getTodayKey(),
        updatedAt: normalizeExportTime(payload.dailyChallengeSettings.updatedAt)
      }, { merge: true });
    }

    if (payload.weeklyTargets) {
      await setDoc(doc(db, "users", user.uid, "settings", "weeklyTargets"), {
        waterGoal: Number(payload.weeklyTargets.waterGoal) || 0,
        sleepTarget: Number(payload.weeklyTargets.sleepTarget) || 8,
        taskTarget: Number(payload.weeklyTargets.taskTarget) || 5,
        updatedAt: normalizeExportTime(payload.weeklyTargets.updatedAt)
      }, { merge: true });
    }

    if (payload.habitQuest) {
      await setDoc(doc(db, "users", user.uid, "settings", "habitQuest"), {
        dateKey: payload.habitQuest.dateKey || getTodayKey(),
        xp: Number(payload.habitQuest.xp) || 0,
        level: Number(payload.habitQuest.level) || 1,
        shield: !!payload.habitQuest.shield,
        quests: Array.isArray(payload.habitQuest.quests) ? payload.habitQuest.quests : [],
        updatedAt: normalizeExportTime(payload.habitQuest.updatedAt)
      }, { merge: true });
    }

    if (payload.insightsCurrent) {
      await setDoc(doc(db, "users", user.uid, "insights", "current"), {
        ...payload.insightsCurrent,
        updatedAt: normalizeExportTime(payload.insightsCurrent.updatedAt)
      }, { merge: true });
    }

    if (payload.insightsBarGraphs) {
      await setDoc(doc(db, "users", user.uid, "insights", "barGraphs"), {
        ...payload.insightsBarGraphs,
        updatedAt: normalizeExportTime(payload.insightsBarGraphs.updatedAt)
      }, { merge: true });
      persistedBarGraphs = payload.insightsBarGraphs;
    }

    await Promise.all([
      loadDailyChallenge(user.uid),
      loadDailyUsage(user.uid),
      loadMoods(user.uid),
      loadAiChats(user.uid),
      loadTasks(user.uid),
      loadWeeklyTargets(user.uid),
      loadRescueEvents(user.uid),
      loadHabitQuest(user.uid),
      loadWaterData(user.uid),
      loadSleepData(user.uid),
      loadGratitude(user.uid)
    ]);

    if (!moodHistory.length && !taskEntries.length && !gratitudeEntries.length) {
      showToast("Import completed. Add your first check-in to start momentum.");
    } else {
      showToast("Data import complete.");
    }
  } catch (err) {
    notifyFirestoreError(err);
  } finally {
    event.target.value = "";
  }
}

// Daily Challenge
const dailyChallenges = [
  "Finish 1 small task you‚Äôve been putting off.",
  "Learn 1 new word or fact today.",
  "Clean or organize one small area of your room/desk.",
  "Write down 3 things you‚Äôre grateful for.",
  "Smile at 3 people today.",
  "Avoid social media for 1 hour.",
  "Try a new hobby for 15 minutes.",
  "Drink 1 extra glass of water today.",
  "Take a 5-minute stretch break every 2 hours.",
  "Eat a fruit or vegetable with every meal.",
  "Meditate for 5‚Äì10 minutes.",
  "Read 5 pages of a book.",
  "Take a 10-minute walk without your phone.",
  "Do 20 squats or 15 push-ups.",
  "Write one short journal entry about your day.",
  "Complete one pending task before noon.",
  "Declutter 10 items from your workspace.",
  "Practice deep breathing for 3 minutes.",
  "Spend 15 minutes learning a new skill.",
  "No sugary drink for the next 12 hours.",
  "Drink water before every meal today.",
  "Sleep 30 minutes earlier tonight.",
  "Send one kind message to a friend or family member.",
  "Do a 5-minute posture check and correction.",
  "Complete one task in a 25-minute focus sprint.",
  "Write your top 3 priorities for tomorrow.",
  "Listen to calming music for 10 minutes.",
  "Avoid doom-scrolling after dinner.",
  "Take a screen break for 20 minutes.",
  "Do a 10-minute room reset.",
  "Try a healthy snack instead of junk food once today.",
  "Spend 10 minutes in sunlight.",
  "Track and finish one important task fully.",
  "Do a quick gratitude walk and notice 3 good things.",
  "Practice a hobby for 20 minutes.",
  "Review your expenses for the day in 5 minutes.",
  "Write one positive affirmation and repeat it 5 times.",
  "No phone for the first 30 minutes after waking up.",
  "Complete your toughest task first.",
  "Do a 5-minute stretching routine before sleep."
];

function pickFreshDailyChallengeText(excludeText = "") {
  const filtered = dailyChallenges.filter((entry) => String(entry || "") !== String(excludeText || ""));
  const pool = filtered.length ? filtered : dailyChallenges;
  const index = Math.floor(Math.random() * pool.length);
  return pool[index] || pickChallengeForDate(getTodayKey());
}

async function assignFreshDailyChallenge(userId, excludeText = "") {
  const todayKey = getTodayKey();
  const challenge = pickFreshDailyChallengeText(excludeText);

  currentChallengeDateKey = todayKey;
  currentChallengeText = challenge;
  dailyChallengeCompleted = false;
  dailyChallengeElement.innerText = challenge;
  challengeResultElement.innerText = "";
  updateChallengeCompleteButtonState();

  if (userId) {
    try {
      await setDoc(doc(db, "users", userId, "settings", "dailyChallenge"), {
        challenge,
        completed: false,
        dateKey: todayKey,
        timeZone: userTimeZone,
        updatedAt: serverTimestamp()
      }, { merge: true });
    } catch (err) {
      notifyFirestoreError(err);
    }
  }

  updateInsights();
}

// ---------- Function to pick a random daily challenge ----------
function pickDailyChallenge() {
  const todayKey = getTodayKey();
  const challenge = pickChallengeForDate(todayKey);
  currentChallengeDateKey = todayKey;
  currentChallengeText = challenge;
  dailyChallengeElement.innerText = challenge;
  challengeResultElement.innerText = "";
  dailyChallengeCompleted = false;
  updateChallengeCompleteButtonState();
  updateInsights();
}

function updateChallengeCompleteButtonState() {
  if (!challengeCompleteBtn) return;
  challengeCompleteBtn.disabled = !!dailyChallengeCompleted;
}

async function saveDailyChallengeState() {
  const user = auth.currentUser;
  if (!user) return;

  const todayKey = getTodayKey();
  try {
    await setDoc(doc(db, "users", user.uid, "settings", "dailyChallenge"), {
      challenge: currentChallengeText,
      completed: dailyChallengeCompleted,
      dateKey: todayKey,
      timeZone: userTimeZone,
      updatedAt: serverTimestamp()
    }, { merge: true });

    if (dailyChallengeCompleted) {
      await setDoc(doc(db, "users", user.uid, "challengeHistory", todayKey), {
        completed: true,
        challenge: currentChallengeText,
        dateKey: todayKey,
        updatedAt: serverTimestamp()
      }, { merge: true });
    }
  } catch (err) {
    notifyFirestoreError(err);
  }
}

async function loadDailyChallenge(userId) {
  const todayKey = getTodayKey();
  challengeDates.length = 0;

  try {
    const [challengeSettingsSnap, historySnap] = await Promise.all([
      getDoc(doc(db, "users", userId, "settings", "dailyChallenge")),
      getDocs(collection(db, "users", userId, "challengeHistory"))
    ]);

    historySnap.docs.forEach((docSnap) => {
      const data = docSnap.data();
      if (!data.completed) return;
      const key = data.dateKey || docSnap.id;
      const parsed = dateKeyToDate(key);
      if (parsed) challengeDates.push(parsed);
    });

    let challenge = pickChallengeForDate(todayKey);
    let completed = false;

    if (challengeSettingsSnap.exists()) {
      const settings = challengeSettingsSnap.data();
      if (settings.dateKey === todayKey) {
        challenge = settings.challenge || challenge;
        completed = !!settings.completed;
      }
    }

    currentChallengeDateKey = todayKey;
    currentChallengeText = challenge;
    dailyChallengeCompleted = completed;
    dailyChallengeElement.innerText = challenge;
    challengeResultElement.innerText = completed ? "‚úÖ Challenge completed! Great job!" : "";
    updateChallengeCompleteButtonState();

    if (completed) {
      const parsedToday = dateKeyToDate(todayKey);
      if (parsedToday && !challengeDates.some((date) => dateToKey(date) === todayKey)) {
        challengeDates.push(parsedToday);
      }
    }

    await saveDailyChallengeState();
    updateInsights();
  } catch (err) {
    notifyFirestoreError(err);
    pickDailyChallenge();
  }
}

// Initialize daily challenge on page load
pickDailyChallenge();

// Complete challenge function
async function completeChallenge() {
  if (dailyChallengeCompleted) {
    challengeResultElement.innerText = "‚úÖ Challenge already completed for today.";
    updateChallengeCompleteButtonState();
    return;
  }

  dailyChallengeCompleted = true;
  const todayKey = getTodayKey();
  const parsedToday = dateKeyToDate(todayKey);
  if (parsedToday && !challengeDates.some((date) => dateToKey(date) === todayKey)) {
    challengeDates.push(parsedToday);
  }

  challengeResultElement.innerText = "‚úÖ Challenge completed! Great job!";
  updateChallengeCompleteButtonState();
  updateInsights();
  await saveDailyChallengeState();
}

Object.assign(window, {
  handleAuth,
  resendVerificationEmailFromModal,
  toggleAuth,
  toggleAccountPanel,
  closeAccountPanel,
  clearAllAccountData,
  runCrashRescueFlow,
  setNextWeekTargets,
  applyRecoverySchedule,
  nextInsightMetric,
  signOutUser,
  aiChat,
  clearAiChats,
  addReminder,
  addTask,
  calculateFinance,
  saveMood,
  setWaterGoal,
  saveWater,
  clearWaterData,
  saveSleep,
  timeTraveller,
  newQuote,
  saveGratitude,
  completeChallenge,
  exportAllData,
  startImportData,
  importDataFileChange,
  nextWelcomeGuideStep,
  skipWelcomeGuide,
  handleGoogleAuth,
  sendResetPasswordEmail,
  sendAccountResetPasswordEmail,
  refreshStartupPlan,
  applyStartupPlanAsTasks,
  generateStartupWeeklyReport,
  copyStartupWeeklyReport
});

</script>
</body>
</html>
